
leds.elf:     file format elf32-msp430

SYMBOL TABLE:
0000ffe8 l    d  __interrupt_vector_5	00000000 __interrupt_vector_5
0000fff0 l    d  __interrupt_vector_9	00000000 __interrupt_vector_9
0000fffe l    d  __reset_vector	00000000 __reset_vector
00008000 l    d  .rodata	00000000 .rodata
00008010 l    d  .text	00000000 .text
00004000 l    d  .data	00000000 .data
00004004 l    d  .bss	00000000 .bss
00004218 l    d  .noinit	00000000 .noinit
00000000 l    d  .MP430.attributes	00000000 .MP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 qwark.c
0000804c l       .text	00000000 __qwark_retry_1st_setup
00008040 l       .text	00000000 __qwark_restore_2nd_setup
00008060 l       .text	00000000 __qwark_retry_2nd_setup
00008034 l       .text	00000000 __qwark_restore_1st_setup
000080ee l       .text	00000000 __system_restore
00008070 l       .text	00000000 __second_stage_retry
000080ae l       .text	00000000 _stack_write_back_retry
00008078 l       .text	00000000 _retry_second_phase_commit_strt
00008094 l       .text	00000000 _retry_byte_copy
000080ae l       .text	00000000 __retry_complete
000080d8 l       .text	00000000 _second_phase_retry_finished
000080c6 l       .text	00000000 _second_phase_retry_stack_cpy
000080e8 l       .text	00000000 __set_flag_complete
00008120 l       .text	00000000 __erase_stack
00008130 l       .text	00000000 __deletion_stack_complete
0000818a l       .text	00000000 __Second_buffer_restore_stack
00008138 l       .text	00000000 __First_buffer_restore_stack
000085b2 l       .text	00000000 __second_buffer_init
000085b6 l       .text	00000000 __first_phase_commit
000085c8 l       .text	00000000 __continue_first_phase_commit
00008660 l       .text	00000000 __seg_logic
00008654 l       .text	00000000 _scratchpad_addr_cpy
00008682 l       .text	00000000 __segmentation_isr
0000868a l       .text	00000000 __commit_th
00008692 l       .text	00000000 __commit_th_cmp
000086a0 l       .text	00000000 __commit_on_2nd
000086a4 l       .text	00000000 _chkpt_stack
000086ac l       .text	00000000 __first_stack_chkpt_setup
000086be l       .text	00000000 __segmentation_logic
00008716 l       .text	00000000 __copy_stack
000086d0 l       .text	00000000 __sp_seg_define
000086dc l       .text	00000000 __sp_overlap
00008726 l       .text	00000000 __stack_chkpt_end
0000870e l       .text	00000000 __sp_pre_copy
000086fa l       .text	00000000 __overlap_copy
0000870a l       .text	00000000 __sp_ovl_copy
00008734 l       .text	00000000 __set_flag_2nd
00008738 l       .text	00000000 _WAR_commit
00008786 l       .text	00000000 _stack_write_back
0000874e l       .text	00000000 _second_phase_commit_strt
0000876c l       .text	00000000 _byte_copy
00008760 l       .text	00000000 _pre_end_copy
000087b0 l       .text	00000000 _chkpt_finished
0000879e l       .text	00000000 _second_phase_stack_cpy
000087ea l       .text	00000000 __pre_finish_2nd_buffer
0000881a l       .text	00000000 _finish
00000000 l    df *ABS*	00000000 timerA.c
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
00008236 l       .text	00000000 _msp430_run_array
00008244 l       .text	00000000 _msp430_run_done
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtbegin.o
00008008 l     O .rodata	00000000 __CTOR_LIST__
0000800c l     O .rodata	00000000 __DTOR_LIST__
00008000 l     O .rodata	00000000 __EH_FRAME_BEGIN__
00008ac0 l     O .text	00000000 __TMC_LIST__
00008246 l     F .text	00000000 deregister_tm_clones
00008260 l     F .text	00000000 register_tm_clones
0000828e l     F .text	00000000 __do_global_dtors_aux
00004004 l     O .bss	00000000 completed.3056
00004006 l     O .bss	00000000 dtor_idx.3058
000082dc l     F .text	00000000 frame_dummy
00004008 l     O .bss	00000000 object.3071
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtend.o
0000800a l     O .rodata	00000000 __CTOR_END__
00008000 l     O .rodata	00000000 __FRAME_END__
00008a8a l     F .text	00000000 __do_global_ctors_aux
00000000 l    df *ABS*	00000000 crt_bss.o
00000000 l    df *ABS*	00000000 crt_movedata.o
00000000 l    df *ABS*	00000000 crt_main.o
00000000 l    df *ABS*	00000000 main.c
000082f4 l     F .text	00000082 reflect
00000000 l    df *ABS*	00000000 slli.o
00000000 l    df *ABS*	00000000 srli.o
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 lib_a-memmove.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crtn.o
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 
00008010 l       .text	00000000 _start
00008944 g       .text	00000000 .hidden __mspabi_slll_9
00008934 g       .text	00000000 .hidden __mspabi_slll_13
0000898e g       .text	00000000 .hidden __mspabi_srli_9
000089de g       .text	00000000 .hidden __mspabi_srll_10
0000898a g       .text	00000000 .hidden __mspabi_srli_10
0000890e g       .text	00000000 .hidden __mspabi_slli_9
00008976 g       .text	00000000 .hidden __mspabi_srli_15
00008a3e g     F .text	00000038 memmove
000089a2 g       .text	00000000 .hidden __mspabi_srli_4
00008908 g       .text	00000000 .hidden __mspabi_slli_12
00008996 g       .text	00000000 .hidden __mspabi_srli_7
000089f0 g       .text	00000000 .hidden __mspabi_srll_7
00008a08 g       .text	00000000 .hidden __mspabi_srll_3
000088f4 g       .text	00000000 .hidden __mspabi_func_epilog_6
00008ac0 g     O .text	00000000 .hidden __TMC_END__
000089cc g       .text	00000000 .hidden __mspabi_srll_13
0000800e g     O .rodata	00000000 .hidden __DTOR_END__
00008004 g       .rodata	00000000 __fini_array_end
00008982 g       .text	00000000 .hidden __mspabi_srli_12
00008010 g     F .text	00000004 __crt0_start
0000893c g       .text	00000000 .hidden __mspabi_slll_11
0000892c g       .text	00000000 .hidden __mspabi_slll_15
00008904 g       .text	00000000 .hidden __mspabi_slli_14
00008918 g       .text	00000000 .hidden __mspabi_slli_4
000081de g     F .text	0000000e __crt0_init_bss
00000214 g       *ABS*	00000000 __bsssize
00008960 g       .text	00000000 .hidden __mspabi_slll_2
00008200 g     F .text	0000000a __crt0_call_init_then_main
000088fe g       .text	00000000 .hidden __mspabi_func_epilog_1
00008926 g       .text	00000000 .hidden __mspabi_slli
000088fa g       .text	00000000 .hidden __mspabi_func_epilog_3
000089fc g       .text	00000000 .hidden __mspabi_srll_5
000089ba g       .text	00000000 .hidden __mspabi_srli
000089d8 g       .text	00000000 .hidden __mspabi_srll_11
00008954 g       .text	00000000 .hidden __mspabi_slll_5
0000890a g       .text	00000000 .hidden __mspabi_slli_11
0000891a g       .text	00000000 .hidden __mspabi_slli_3
0000899e g       .text	00000000 .hidden __mspabi_srli_5
00008376 g     F .text	00000082 crcSlow
00000000  w      *UND*	00000000 __deregister_frame_info
00004218 g       .noinit	00000000 end
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
0000891c g       .text	00000000 .hidden __mspabi_slli_2
000089f6 g       .text	00000000 .hidden __mspabi_srll_6
00008950 g       .text	00000000 .hidden __mspabi_slll_6
00008958 g       .text	00000000 .hidden __mspabi_slll_4
00008948 g       .text	00000000 .hidden __mspabi_slll_8
00008226 g     F .text	00000000 _msp430_run_fini_array
000089ae g       .text	00000000 .hidden __mspabi_srli_1
000089c6 g       .text	00000000 .hidden __mspabi_srll_14
00008914 g       .text	00000000 .hidden __mspabi_slli_6
00008014 g     F .text	000001ca qwark_restore
0000897a g       .text	00000000 .hidden __mspabi_srli_14
00000004 g       *ABS*	00000000 __romdatacopysize
000084f0 g     F .text	0000002c init
00008930 g       .text	00000000 .hidden __mspabi_slll_14
000083f8 g     F .text	00000082 crcInit
00008986 g       .text	00000000 .hidden __mspabi_srli_11
0000894c g       .text	00000000 .hidden __mspabi_slll_7
00004216 g     O .bss	00000002 periodic_val
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
00008004 g       .rodata	00000000 __fini_array_start
00000000  w      *ABS*	00000000 __rom_highdatacopysize
00008aa4 g       .text	00000000 __msp430_init
00008a76 g     F .text	00000014 memset
00008938 g       .text	00000000 .hidden __mspabi_slll_12
0000851c g     F .text	00000076 main
0000888e g     F .text	00000022 ta_wait
00008a02 g       .text	00000000 .hidden __mspabi_srll_4
00008004 g       .rodata	00000000 __init_array_end
000089aa g       .text	00000000 .hidden __mspabi_srli_2
0000891e g       .text	00000000 .hidden __mspabi_slli_1
00000000  w      *ABS*	00000000 __high_bsssize
0000895c g       .text	00000000 .hidden __mspabi_slll_3
00000000  w      *ABS*	00000000 __rom_highdatastart
000088b0 g     F .text	00000042 INT_timerA1
00008ac0 g       .text	00000000 __msp430_fini_end
00004002 g     O .data	00000002 crc_fast_output
000089d2 g       .text	00000000 .hidden __mspabi_srll_12
00008916 g       .text	00000000 .hidden __mspabi_slli_5
00008ac0 g       *ABS*	00000000 __romdatastart
00008906 g       .text	00000000 .hidden __mspabi_slli_13
0000820a g     F .text	00000000 _msp430_run_init_array
0000886c g     F .text	00000022 ta_wait_no_lpm
0000899a g       .text	00000000 .hidden __mspabi_srli_6
0000847a g     F .text	00000076 crcFast
00008004 g       .rodata	00000000 __preinit_array_end
00004000 g     O .data	00000002 crc_slow_output
0000890c g       .text	00000000 .hidden __mspabi_slli_10
000089a6 g       .text	00000000 .hidden __mspabi_srli_3
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
00004004 g       .bss	00000000 __bssstart
000088f6 g       .text	00000000 .hidden __mspabi_func_epilog_5
00008970 g       .text	00000000 .hidden __mspabi_slll
00008000 g       .noinit	00000000 __stack
00008592 g     F .text	000002da INT_Qwark
000089e4 g       .text	00000000 .hidden __mspabi_srll_9
00004004 g       .data	00000000 _edata
00004016 g     O .bss	00000200 crcTable
00008ab6 g       .text	00000000 __msp430_init_end
00008a24 g       .text	00000000 .hidden __mspabi_srll
00000000  w      *ABS*	00000000 __high_bssstart
00008910 g       .text	00000000 .hidden __mspabi_slli_8
000089c0 g       .text	00000000 .hidden __mspabi_srll_15
00008940 g       .text	00000000 .hidden __mspabi_slll_10
00008902 g       .text	00000000 .hidden __mspabi_slli_15
00008004 g       .rodata	00000000 __init_array_start
00008a2a g     F .text	00000014 strlen
0000897e g       .text	00000000 .hidden __mspabi_srli_13
00004000 g       .data	00000000 __datastart
00008964 g       .text	00000000 .hidden __mspabi_slll_1
000089ea g       .text	00000000 .hidden __mspabi_srll_8
00008a14 g       .text	00000000 .hidden __mspabi_srll_1
00008912 g       .text	00000000 .hidden __mspabi_slli_7
00008004 g       .rodata	00000000 __preinit_array_start
000081ec g     F .text	00000014 __crt0_movedata
000088fc g       .text	00000000 .hidden __mspabi_func_epilog_2
00000000  w      *UND*	00000000 __register_frame_info
00008218 g     F .text	00000000 _msp430_run_preinit_array
000088f2 g       .text	00000000 .hidden __mspabi_func_epilog_7
000088f8 g       .text	00000000 .hidden __mspabi_func_epilog_4
00008a0e g       .text	00000000 .hidden __mspabi_srll_2
00008ab6 g       .text	00000000 __msp430_fini
00008992 g       .text	00000000 .hidden __mspabi_srli_8



Disassembly of section __interrupt_vector_5:

0000ffe8 <__interrupt_vector_5>:
    ffe8:	92 85       	interrupt service routine at 0x8592

Disassembly of section __interrupt_vector_9:

0000fff0 <__interrupt_vector_9>:
    fff0:	b0 88       	interrupt service routine at 0x88b0

Disassembly of section .text:

00008010 <__crt0_start>:
    8010:	31 40 00 80 	mov	#32768,	r1	;#0x8000

00008014 <qwark_restore>:
	//    RESTORE HANDLING LOGIC																  				   //
	//	  W.C 30 CYCLES																							   //
	//-------------------------------------------------------------------------------------------------------------//
	
	/* Disable Qwark */
	asm ("mov #0x0000, &0x02A0");				// 4 cycles
    8014:	82 43 a0 02 	mov	#0,	&0x02a0	;r3 As==00

00008018 <.Loc.30.1>:

	asm ("cmp.b #0x02, &0x6074");				// 2 cycles
    8018:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

0000801c <.Loc.31.1>:
	asm ("jz __qwark_retry_1st_setup");		    // 2 cycles
    801c:	17 24       	jz	$+48     	;abs 0x804c

0000801e <.Loc.33.1>:

	asm ("cmp.b #0x03, &0x6075");				// 3 cycles
    801e:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    8022:	75 60 

00008024 <.Loc.34.1>:
	asm ("jz __qwark_restore_2nd_setup");		// 2 cycles
    8024:	0d 24       	jz	$+28     	;abs 0x8040

00008026 <.Loc.35.1>:
	asm ("cmp.b #0x03, &0x6074");				// 3 cycles
    8026:	f2 90 03 00 	cmp.b	#3,	&0x6074	;
    802a:	74 60 

0000802c <.Loc.36.1>:
	asm ("jnz __crt0_init_bss");				// 2 cycles
    802c:	d8 20       	jnz	$+434    	;abs 0x81de

0000802e <.Loc.38.1>:

	asm ("cmp.b #0x02, &0x6075");				// 2 cycles
    802e:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008032 <.Loc.39.1>:
	asm ("jz  __qwark_retry_2nd_setup");		// 2 cycles
    8032:	16 24       	jz	$+46     	;abs 0x8060

00008034 <__qwark_restore_1st_setup>:

	asm ("__qwark_restore_1st_setup:");

	asm ("mov &0X6012,   r12 ");				// 3 cycles
    8034:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008038 <.Loc.44.1>:
    asm ("mov #0x6FFE,   r13 ");				// 2 cycles
    8038:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

0000803c <.Loc.45.1>:
	asm ("br  #__system_restore");				// 2 cycles
    803c:	30 40 ee 80 	br	#0x80ee		;

00008040 <__qwark_restore_2nd_setup>:

	asm ("__qwark_restore_2nd_setup:");

	asm ("mov &0X6042, r12   ");				// 3 cycles
    8040:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008044 <.Loc.50.1>:
    asm ("mov #0x6BFE, r13   ");				// 2 cycles
    8044:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

00008048 <.Loc.51.1>:
	asm ("br  #__system_restore");				// 2 cycles
    8048:	30 40 ee 80 	br	#0x80ee		;

0000804c <__qwark_retry_1st_setup>:

	asm ("__qwark_retry_1st_setup:");

	asm ("mov  #0x6030,   r10 ");				// 2 cycles
    804c:	3a 40 30 60 	mov	#24624,	r10	;#0x6030

00008050 <.Loc.56.1>:
	asm ("mov  &0X6012,   r12 ");				// 3 cycles
    8050:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008054 <.Loc.57.1>:
    asm ("mov  #0x6FFE,   r13 ");				// 2 cycles
    8054:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

00008058 <.Loc.58.1>:
	asm ("mov  &0x602E,   r15 ");				// 3 cycles
    8058:	1f 42 2e 60 	mov	&0x602e,r15	;0x602e

0000805c <.Loc.59.1>:
	asm ("br  #__second_stage_retry");			// 2 cycles
    805c:	30 40 70 80 	br	#0x8070		;

00008060 <__qwark_retry_2nd_setup>:

	asm ("__qwark_retry_2nd_setup:");

	asm ("mov #0x6060,   r10 ");				// 2 cycles
    8060:	3a 40 60 60 	mov	#24672,	r10	;#0x6060

00008064 <.Loc.64.1>:
	asm ("mov &0X6042,   r12 ");				// 3 cycles
    8064:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008068 <.Loc.65.1>:
    asm ("mov #0x6BFE,   r13 ");				// 2 cycles
    8068:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

0000806c <.Loc.66.1>:
	asm ("mov &0x605E,   r15 ");				// 3 cycles
    806c:	1f 42 5e 60 	mov	&0x605e,r15	;0x605e

00008070 <__second_stage_retry>:
	//-------------------------------------------------------------------------------------------------------------//
	//    RETRY SECOND PHASE OF THE COMMIT PROCESS	: 148 cycles												   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("__second_stage_retry:");

	asm ("tst r15 ");     		            // 1 cycles
    8070:	0f 93       	cmp	#0,	r15	;r3 As==00

00008072 <.Loc.74.1>:
	asm ("jz  _stack_write_back_retry");	// 2 cycles
    8072:	1d 24       	jz	$+60     	;abs 0x80ae

00008074 <.Loc.76.1>:

	asm ("mov #0x6000,  r14");			    // 2 cycles
    8074:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008078 <_retry_second_phase_commit_strt>:

	asm ("_retry_second_phase_commit_strt:");  // Worst case

	asm ("mov @r10+2,  r9 ");   			// 2 cycles
    8078:	39 4a       	mov	@r10+,	r9	;

0000807a <.Loc.82.1>:

	asm ("mov r9,  r11 ");   			    // 1 cycle
    807a:	0b 49       	mov	r9,	r11	;

0000807c <.Loc.84.1>:

	asm ("and #0x8000,  r11 ");   			// 2 cycles
    807c:	3b f0 00 80 	and	#32768,	r11	;#0x8000

00008080 <.Loc.85.1>:
	asm ("cmp #0x8000,  r11 ");   			// 2 cycles
    8080:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

00008084 <.Loc.86.1>:
	asm ("jeq _retry_byte_copy ");   		// 2 cycles
    8084:	07 24       	jz	$+16     	;abs 0x8094

00008086 <.Loc.88.1>:

	asm ("mov @r14+2, @r9 ");    			// 5 cycles
    8086:	b9 4e 00 00 	mov	@r14+,	0(r9)	;

0000808a <.Loc.90.1>:

	asm ("dec r15");    					// 1 cycles
    808a:	1f 83       	dec	r15		;

0000808c <.Loc.91.1>:
	asm ("tst r15");    					// 1 cycles
    808c:	0f 93       	cmp	#0,	r15	;r3 As==00

0000808e <.Loc.93.1>:

	asm ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    808e:	f4 23       	jnz	$-22     	;abs 0x8078

00008090 <.Loc.94.1>:
	asm ("br #__retry_complete");		    // 2 cycle
    8090:	30 40 ae 80 	br	#0x80ae		;

00008094 <_retry_byte_copy>:

	asm ("_retry_byte_copy: ");
	asm ("and #0x7FFF,  r9  ");   			// mask the highest bit 2 cycles
    8094:	39 f0 ff 7f 	and	#32767,	r9	;#0x7fff

00008098 <.Loc.98.1>:
	asm ("mov r9,      r11  ");   			// 1 cycle
    8098:	0b 49       	mov	r9,	r11	;

0000809a <.Loc.99.1>:
	asm ("and #0x01,    r11 ");   			// detect if its a byte write - 2 cycles
    809a:	1b f3       	and	#1,	r11	;r3 As==01

0000809c <.Loc.100.1>:
	asm ("bis  r11,     r14 ");   			// detect if its a byte write - 2 cycles
    809c:	0e db       	bis	r11,	r14	;

0000809e <.Loc.102.1>:

	asm ("mov.b @r14, @r9  ");    			// 5 cycles
    809e:	e9 4e 00 00 	mov.b	@r14,	0(r9)	;

000080a2 <.Loc.103.1>:
	asm ("and #0xFFFE, r14 ");    			// 1 cycle
    80a2:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

000080a6 <.Loc.104.1>:
	asm ("incd r14 ");    					// 1 cycle
    80a6:	2e 53       	incd	r14		;

000080a8 <.Loc.106.1>:

	asm ("dec r15");    					// 1 cycles
    80a8:	1f 83       	dec	r15		;

000080aa <.Loc.107.1>:
	asm ("tst r15");    					// 1 cycles
    80aa:	0f 93       	cmp	#0,	r15	;r3 As==00

000080ac <.Loc.108.1>:
	asm ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80ac:	e5 23       	jnz	$-52     	;abs 0x8078

000080ae <__retry_complete>:
	//-------------------------------------------------------------------------------------------------------------//
	//   COPY BACK THE 2BLE BUFFER	RETRY				       				       	      						   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("_stack_write_back_retry:");

	asm ("cmp #0x0000,  &0x6BFE");	
    80ae:	82 93 fe 6b 	cmp	#0,	&0x6bfe	;r3 As==00

000080b2 <.Loc.118.1>:
	asm ("jeq _second_phase_retry_finished");
    80b2:	12 24       	jz	$+38     	;abs 0x80d8

000080b4 <.Loc.120.1>:

	asm ("mov &0x6BFE,  r13 ");		 // 2 cycles - get the upper limit		
    80b4:	1d 42 fe 6b 	mov	&0x6bfe,r13	;0x6bfe

000080b8 <.Loc.121.1>:
	asm ("mov &0x6BFC,  r12 ");		 // 2 cycles - get the down limit 
    80b8:	1c 42 fc 6b 	mov	&0x6bfc,r12	;0x6bfc

000080bc <.Loc.123.1>:

	asm ("mov r13,  r14 ");		 	 // 2 cycles - 
    80bc:	0e 4d       	mov	r13,	r14	;

000080be <.Loc.124.1>:
	asm ("sub #0x1000,  r14 ");		 // 2 cycles - get the down limit 
    80be:	3e 80 00 10 	sub	#4096,	r14	;#0x1000

000080c2 <.Loc.125.1>:
	asm ("mov #0x6BFA,  r10 ");
    80c2:	3a 40 fa 6b 	mov	#27642,	r10	;#0x6bfa

000080c6 <_second_phase_retry_stack_cpy>:

	asm ("_second_phase_retry_stack_cpy:");
	asm ("mov @r10,@r14");				 // 5 cycles
    80c6:	ae 4a 00 00 	mov	@r10,	0(r14)	;

000080ca <.Loc.130.1>:
	
	asm ("cmp r13, r12");	
    80ca:	0c 9d       	cmp	r13,	r12	;

000080cc <.Loc.131.1>:
   	asm ("jeq _second_phase_retry_finished");	 	 // 2 cycles
    80cc:	05 24       	jz	$+12     	;abs 0x80d8

000080ce <.Loc.132.1>:
	asm ("decd r10");
    80ce:	2a 83       	decd	r10		;

000080d0 <.Loc.133.1>:
	asm ("decd r13");	   	
    80d0:	2d 83       	decd	r13		;

000080d2 <.Loc.134.1>:
	asm ("decd r14");	   	
    80d2:	2e 83       	decd	r14		;

000080d4 <.Loc.135.1>:
	asm ("br # _second_phase_retry_stack_cpy");	 	// 2 cycles
    80d4:	30 40 c6 80 	br	#0x80c6		;

000080d8 <_second_phase_retry_finished>:
	//    END OF THE RETRY-SECOND PHASE	: Atomic Flag Set														   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("_second_phase_retry_finished:");

	asm ("cmp.b #0x02, &0x6074");		// 4 cycles
    80d8:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

000080dc <.Loc.144.1>:
	asm ("jz __set_flag_complete");	// 2 cycles
    80dc:	05 24       	jz	$+12     	;abs 0x80e8

000080de <.Loc.146.1>:

	asm ("mov #0x0301, &0x6074 ");		// 5 cycles
    80de:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    80e2:	74 60 

000080e4 <.Loc.147.1>:
	asm ("br #__system_restore:");		// 2 cycles
    80e4:	30 40 ee 80 	br	#0x80ee		;

000080e8 <__set_flag_complete>:

	asm ("__set_flag_complete:");
	asm ("mov #0x0103, &0x6074 ");		// 5 cycles
    80e8:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    80ec:	74 60 

000080ee <__system_restore>:
	//	 12 CYCLES																								   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("__system_restore:");

	/* Disable The Watchdog */
	asm ("mov #288, r8");		// 2 cycles
    80ee:	38 40 20 01 	mov	#288,	r8	;#0x0120

000080f2 <.Loc.160.1>:
	asm ("mov #23168, 0(r8)");	// 2 cycles
    80f2:	b8 40 80 5a 	mov	#23168,	0(r8)	;#0x5a80
    80f6:	00 00 

000080f8 <.Loc.163.1>:

	/* Enable and Configure the UART */
	asm ("mov.b #130, r8");	// 2 cycles
    80f8:	78 40 82 00 	mov.b	#130,	r8	;#0x0082

000080fc <.Loc.164.1>:
	asm ("mov   #8, 0(r8)");	// 2 cycles
    80fc:	b8 42 00 00 	mov	#8,	0(r8)	;r2 As==11

00008100 <.Loc.166.1>:

	asm ("mov.b #128, r8");	// 2 cycles
    8100:	78 40 80 00 	mov.b	#128,	r8	;#0x0080

00008104 <.Loc.167.1>:
	asm ("mov.b   #1, 0(r8)"); // 2 cycles
    8104:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01

00008108 <.Loc.173.1>:

	/* Configure the timer */


#ifdef TIMER_TEST
	asm ("mov  #370, r8");		    // 2 cycles
    8108:	38 40 72 01 	mov	#370,	r8	;#0x0172

0000810c <.Loc.174.1>:
	asm ("mov  #9980, 0(r8)");	// 2 cycles
    810c:	b8 40 fc 26 	mov	#9980,	0(r8)	;#0x26fc
    8110:	00 00 

00008112 <.Loc.176.1>:

	asm ("mov  #352, r8");		    // 2 cycles
    8112:	38 40 60 01 	mov	#352,	r8	;#0x0160

00008116 <.Loc.177.1>:
	asm ("mov  #534, 0(r8)");	    // 2 cycles
    8116:	b8 40 16 02 	mov	#534,	0(r8)	;#0x0216
    811a:	00 00 

0000811c <.Loc.185.1>:
	//-------------------------------------------------------------------------------------------------------------//
	//   TESTING ONLY: Wipe out the stack to simulate a real power outage										   //
	//	 N.A.																								       //
	//-------------------------------------------------------------------------------------------------------------//

	asm ("mov #0x7FFE, r14");
    811c:	3e 40 fe 7f 	mov	#32766,	r14	;#0x7ffe

00008120 <__erase_stack>:

	asm ("__erase_stack:");

	asm ("cmp #0x7C00,r14");
    8120:	3e 90 00 7c 	cmp	#31744,	r14	;#0x7c00

00008124 <.Loc.190.1>:
	asm ("jz __deletion_stack_complete");
    8124:	05 24       	jz	$+12     	;abs 0x8130

00008126 <.Loc.192.1>:

	asm ("mov #0x0000,@r14");
    8126:	8e 43 00 00 	mov	#0,	0(r14)	;r3 As==00

0000812a <.Loc.193.1>:
	asm ("decd r14");
    812a:	2e 83       	decd	r14		;

0000812c <.Loc.194.1>:
	asm ("br #__erase_stack");
    812c:	30 40 20 81 	br	#0x8120		;

00008130 <__deletion_stack_complete>:
	//-------------------------------------------------------------------------------------------------------------//
	//   REGISTERS RESTORE: VERIFY WHICH REGISTERS SHOULD BE RESTORED					   						   //
	//	 																										   //
	//-------------------------------------------------------------------------------------------------------------//

	asm ("cmp.b #0x03,&0x6075");				// 5 cycles
    8130:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    8134:	75 60 

00008136 <.Loc.205.1>:
	asm ("jeq __Second_buffer_restore_stack"); // 2 cycles
    8136:	29 24       	jz	$+84     	;abs 0x818a

00008138 <__First_buffer_restore_stack>:
	/* EDE -> Rm  : 3 cycles each 											  				  			  */
	/* EDE -> PC  : 4 cycles (1 extra cycle penalty) for openMSP430 		  				  			  */
	/* Register time: 14x3 = 42 cycles + 4 cycles (PC) = 49 Cycles + 4(Qwark enable) = 53 cycles 		  */
	asm ("__First_buffer_restore_stack:");

	asm ("mov &0x6016,r4"); 		//R4
    8138:	14 42 16 60 	mov	&0x6016,r4	;0x6016

0000813c <.Loc.215.1>:
	asm ("mov &0x6018,r5"); 		//R5
    813c:	15 42 18 60 	mov	&0x6018,r5	;0x6018

00008140 <.Loc.216.1>:
	asm ("mov &0x601A,r6"); 		//R6
    8140:	16 42 1a 60 	mov	&0x601a,r6	;0x601a

00008144 <.Loc.217.1>:
	asm ("mov &0x601C,r7"); 		//R7
    8144:	17 42 1c 60 	mov	&0x601c,r7	;0x601c

00008148 <.Loc.218.1>:
	asm ("mov &0x601E,r8"); 		//R8
    8148:	18 42 1e 60 	mov	&0x601e,r8	;0x601e

0000814c <.Loc.219.1>:
	asm ("mov &0x6020,r9"); 		//R9
    814c:	19 42 20 60 	mov	&0x6020,r9	;0x6020

00008150 <.Loc.220.1>:
	asm ("mov &0x6022,r10"); 		//R10
    8150:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

00008154 <.Loc.221.1>:
	asm ("mov &0x6024,r11"); 		//R11
    8154:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

00008158 <.Loc.222.1>:
	asm ("mov &0x6026,r12"); 		//R12
    8158:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

0000815c <.Loc.223.1>:
	asm ("mov &0x6028,r13"); 	    //R13
    815c:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00008160 <.Loc.224.1>:
	asm ("mov &0x602A,r14"); 		//R14
    8160:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

00008164 <.Loc.225.1>:
	asm ("mov &0x602C,r15"); 		//R15
    8164:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

00008168 <.Loc.226.1>:
	asm ("mov &0x6012,r1");   		//SP/R1
    8168:	11 42 12 60 	mov	&0x6012,r1	;0x6012

0000816c <.Loc.227.1>:
	asm ("mov &0x6014,r2"); 	    //SR/R2
    816c:	12 42 14 60 	mov	&0x6014,r2	;0x6014

00008170 <.Loc.228.1>:
	asm ("mov &0x6076,&0x02B2"); 	    //3 cycles
    8170:	92 42 76 60 	mov	&0x6076,&0x02b2	;0x6076
    8174:	b2 02 

00008176 <.Loc.229.1>:
	asm ("mov &0x6076,&0x02B4"); 	    //3 cycles
    8176:	92 42 76 60 	mov	&0x6076,&0x02b4	;0x6076
    817a:	b4 02 

0000817c <.Loc.230.1>:
	asm ("mov &0x6076,&0x02B6"); 	    //3 cycles
    817c:	92 42 76 60 	mov	&0x6076,&0x02b6	;0x6076
    8180:	b6 02 

00008182 <.Loc.234.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */

	asm ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    8182:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008186 <.Loc.237.1>:

	/*Restore program Counter */
	asm ("mov &0x6010, pc"); 	    //PC/R0
    8186:	10 42 10 60 	br	&0x6010		;

0000818a <__Second_buffer_restore_stack>:

	asm ("__Second_buffer_restore_stack:");

	asm ("mov &0x6046,r4"); 		//R4
    818a:	14 42 46 60 	mov	&0x6046,r4	;0x6046

0000818e <.Loc.242.1>:
	asm ("mov &0x6048,r5"); 		//R5
    818e:	15 42 48 60 	mov	&0x6048,r5	;0x6048

00008192 <.Loc.243.1>:
	asm ("mov &0x604A,r6"); 		//R6
    8192:	16 42 4a 60 	mov	&0x604a,r6	;0x604a

00008196 <.Loc.244.1>:
	asm ("mov &0x604C,r7"); 		//R7
    8196:	17 42 4c 60 	mov	&0x604c,r7	;0x604c

0000819a <.Loc.245.1>:
	asm ("mov &0x604E,r8"); 		//R8
    819a:	18 42 4e 60 	mov	&0x604e,r8	;0x604e

0000819e <.Loc.246.1>:
	asm ("mov &0x6050,r9"); 		//R9
    819e:	19 42 50 60 	mov	&0x6050,r9	;0x6050

000081a2 <.Loc.247.1>:
	asm ("mov &0x6052,r10"); 		//R10
    81a2:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

000081a6 <.Loc.248.1>:
	asm ("mov &0x6054,r11"); 		//R11
    81a6:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

000081aa <.Loc.249.1>:
	asm ("mov &0x6056,r12"); 		//R12
    81aa:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

000081ae <.Loc.250.1>:
	asm ("mov &0x6058,r13"); 	    //R13
    81ae:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

000081b2 <.Loc.251.1>:
	asm ("mov &0x605A,r14"); 		//R14
    81b2:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

000081b6 <.Loc.252.1>:
	asm ("mov &0x605C,r15"); 		//R15
    81b6:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

000081ba <.Loc.253.1>:
	asm ("mov &0x6042,r1");   		//SP/R1
    81ba:	11 42 42 60 	mov	&0x6042,r1	;0x6042

000081be <.Loc.254.1>:
	asm ("mov &0x6044,r2"); 	    //SR/R2
    81be:	12 42 44 60 	mov	&0x6044,r2	;0x6044

000081c2 <.Loc.257.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	asm ("mov &0x6078,&0x02B2"); 	    //3 cycles
    81c2:	92 42 78 60 	mov	&0x6078,&0x02b2	;0x6078
    81c6:	b2 02 

000081c8 <.Loc.258.1>:
	asm ("mov &0x6078,&0x02B4"); 	    //3 cycles
    81c8:	92 42 78 60 	mov	&0x6078,&0x02b4	;0x6078
    81cc:	b4 02 

000081ce <.Loc.259.1>:
	asm ("mov &0x6078,&0x02B6"); 	    //3 cycles
    81ce:	92 42 78 60 	mov	&0x6078,&0x02b6	;0x6078
    81d2:	b6 02 

000081d4 <.Loc.260.1>:
	asm ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    81d4:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

000081d8 <.Loc.263.1>:

	/*Restore program Counter */
	asm ("mov &0x6040, pc"); 	    //PC/R0
    81d8:	10 42 40 60 	br	&0x6040		;

000081dc <.Loc.265.1>:

}
    81dc:	03 43       	nop			

000081de <__crt0_init_bss>:
    81de:	3c 40 04 40 	mov	#16388,	r12	;#0x4004

000081e2 <.Loc.74.1>:
    81e2:	0d 43       	clr	r13		;

000081e4 <.Loc.75.1>:
    81e4:	3e 40 14 02 	mov	#532,	r14	;#0x0214

000081e8 <.Loc.79.1>:
    81e8:	b0 12 76 8a 	call	#35446		;#0x8a76

000081ec <__crt0_movedata>:
    81ec:	3c 40 00 40 	mov	#16384,	r12	;#0x4000

000081f0 <.Loc.116.1>:
    81f0:	3d 40 c0 8a 	mov	#35520,	r13	;#0x8ac0

000081f4 <.Loc.119.1>:
    81f4:	0d 9c       	cmp	r12,	r13	;

000081f6 <.Loc.120.1>:
    81f6:	04 24       	jz	$+10     	;abs 0x8200

000081f8 <.Loc.122.1>:
    81f8:	3e 40 04 00 	mov	#4,	r14	;

000081fc <.Loc.124.1>:
    81fc:	b0 12 3e 8a 	call	#35390		;#0x8a3e

00008200 <__crt0_call_init_then_main>:
    8200:	b0 12 a4 8a 	call	#35492		;#0x8aa4

00008204 <.Loc.196.1>:
    8204:	0c 43       	clr	r12		;

00008206 <.Loc.197.1>:
    8206:	b0 12 1c 85 	call	#34076		;#0x851c

0000820a <_msp430_run_init_array>:
    820a:	34 40 04 80 	mov	#32772,	r4	;#0x8004

0000820e <.Loc.224.1>:
    820e:	35 40 04 80 	mov	#32772,	r5	;#0x8004

00008212 <.Loc.225.1>:
    8212:	26 43       	mov	#2,	r6	;r3 As==10

00008214 <.Loc.226.1>:
    8214:	30 40 36 82 	br	#0x8236		;

00008218 <_msp430_run_preinit_array>:
    8218:	34 40 04 80 	mov	#32772,	r4	;#0x8004

0000821c <.Loc.232.1>:
    821c:	35 40 04 80 	mov	#32772,	r5	;#0x8004

00008220 <.Loc.233.1>:
    8220:	26 43       	mov	#2,	r6	;r3 As==10

00008222 <.Loc.234.1>:
    8222:	30 40 36 82 	br	#0x8236		;

00008226 <_msp430_run_fini_array>:
    8226:	34 40 04 80 	mov	#32772,	r4	;#0x8004

0000822a <.Loc.240.1>:
    822a:	35 40 04 80 	mov	#32772,	r5	;#0x8004

0000822e <.Loc.241.1>:
    822e:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe

00008232 <.Loc.242.1>:
    8232:	30 40 36 82 	br	#0x8236		;

00008236 <_msp430_run_array>:
    8236:	05 94       	cmp	r4,	r5	;

00008238 <.Loc.246.1>:
    8238:	05 24       	jz	$+12     	;abs 0x8244

0000823a <.Loc.247.1>:
    823a:	27 44       	mov	@r4,	r7	;

0000823c <.Loc.248.1>:
    823c:	04 56       	add	r6,	r4	;

0000823e <.Loc.249.1>:
    823e:	a7 12       	call	@r7		;

00008240 <.Loc.250.1>:
    8240:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x8236

00008244 <_msp430_run_done>:
    8244:	30 41       	ret			

00008246 <deregister_tm_clones>:
    8246:	3c 40 c0 8a 	mov	#35520,	r12	;#0x8ac0
    824a:	3c 90 c0 8a 	cmp	#35520,	r12	;#0x8ac0
    824e:	07 24       	jz	$+16     	;abs 0x825e
    8250:	3d 40 00 00 	mov	#0,	r13	;
    8254:	0d 93       	cmp	#0,	r13	;r3 As==00
    8256:	03 24       	jz	$+8      	;abs 0x825e
    8258:	3c 40 c0 8a 	mov	#35520,	r12	;#0x8ac0
    825c:	8d 12       	call	r13		;

0000825e <.L1>:
    825e:	30 41       	ret			

00008260 <register_tm_clones>:
    8260:	0a 12       	push	r10		;
    8262:	3a 40 c0 8a 	mov	#35520,	r10	;#0x8ac0
    8266:	3a 80 c0 8a 	sub	#35520,	r10	;#0x8ac0
    826a:	0a 11       	rra	r10		;
    826c:	0c 4a       	mov	r10,	r12	;
    826e:	b0 12 76 89 	call	#35190		;#0x8976
    8272:	0c 5a       	add	r10,	r12	;
    8274:	0d 4c       	mov	r12,	r13	;
    8276:	0d 11       	rra	r13		;
    8278:	0d 93       	cmp	#0,	r13	;r3 As==00
    827a:	07 24       	jz	$+16     	;abs 0x828a
    827c:	3e 40 00 00 	mov	#0,	r14	;
    8280:	0e 93       	cmp	#0,	r14	;r3 As==00
    8282:	03 24       	jz	$+8      	;abs 0x828a
    8284:	3c 40 c0 8a 	mov	#35520,	r12	;#0x8ac0
    8288:	8e 12       	call	r14		;

0000828a <.L9>:
    828a:	3a 41       	pop	r10		;
    828c:	30 41       	ret			

0000828e <__do_global_dtors_aux>:
    828e:	0a 12       	push	r10		;
    8290:	09 12       	push	r9		;
    8292:	c2 93 04 40 	cmp.b	#0,	&0x4004	;r3 As==00
    8296:	17 20       	jnz	$+48     	;abs 0x82c6
    8298:	3a 40 0e 80 	mov	#32782,	r10	;#0x800e
    829c:	3a 80 0c 80 	sub	#32780,	r10	;#0x800c
    82a0:	0a 11       	rra	r10		;
    82a2:	3a 53       	add	#-1,	r10	;r3 As==11
    82a4:	39 40 0c 80 	mov	#32780,	r9	;#0x800c

000082a8 <.L19>:
    82a8:	1c 42 06 40 	mov	&0x4006,r12	;0x4006
    82ac:	0c 9a       	cmp	r10,	r12	;
    82ae:	0d 28       	jnc	$+28     	;abs 0x82ca
    82b0:	b0 12 46 82 	call	#33350		;#0x8246
    82b4:	3d 40 00 00 	mov	#0,	r13	;
    82b8:	0d 93       	cmp	#0,	r13	;r3 As==00
    82ba:	03 24       	jz	$+8      	;abs 0x82c2
    82bc:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    82c0:	8d 12       	call	r13		;

000082c2 <.L21>:
    82c2:	d2 43 04 40 	mov.b	#1,	&0x4004	;r3 As==01

000082c6 <.L17>:
    82c6:	30 40 fc 88 	br	#0x88fc		;

000082ca <.L20>:
    82ca:	1c 53       	inc	r12		;
    82cc:	82 4c 06 40 	mov	r12,	&0x4006	;
    82d0:	0c 5c       	rla	r12		;
    82d2:	0c 59       	add	r9,	r12	;
    82d4:	2c 4c       	mov	@r12,	r12	;
    82d6:	8c 12       	call	r12		;
    82d8:	30 40 a8 82 	br	#0x82a8		;

000082dc <frame_dummy>:
    82dc:	3e 40 00 00 	mov	#0,	r14	;
    82e0:	0e 93       	cmp	#0,	r14	;r3 As==00
    82e2:	05 24       	jz	$+12     	;abs 0x82ee
    82e4:	3d 40 08 40 	mov	#16392,	r13	;#0x4008
    82e8:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    82ec:	8e 12       	call	r14		;

000082ee <.L27>:
    82ee:	b0 12 60 82 	call	#33376		;#0x8260
    82f2:	30 41       	ret			

000082f4 <reflect>:
 *
 * Returns:     The reflection of the original data.
 *
 *********************************************************************/
static unsigned long reflect(unsigned long data, unsigned char nBits)
{
    82f4:	0a 12       	push	r10		;

000082f6 <.LCFI0>:
    82f6:	09 12       	push	r9		;

000082f8 <.LCFI1>:
    82f8:	31 80 0c 00 	sub	#12,	r1	;#0x000c

000082fc <.LCFI2>:
    82fc:	81 4c 02 00 	mov	r12,	2(r1)	;
    8300:	81 4d 04 00 	mov	r13,	4(r1)	;
    8304:	c1 4e 01 00 	mov.b	r14,	1(r1)	;

00008308 <.Loc.68.1>:
    unsigned long  reflection = 0x00000000;
    8308:	81 43 08 00 	mov	#0,	8(r1)	;r3 As==00
    830c:	81 43 0a 00 	mov	#0,	10(r1)	;r3 As==00, 0x000a

00008310 <.Loc.74.1>:
    unsigned char  bit;

    /*
     * Reflect the data about the center bit.
     */
    for (bit = 0; bit < nBits; ++bit)
    8310:	c1 43 07 00 	mov.b	#0,	7(r1)	;r3 As==00
    8314:	30 40 5e 83 	br	#0x835e		;

00008318 <.L5>:
    {
        /*
         * If the LSB bit is set, set the reflection of it.
         */
        if (data & 0x01)
    8318:	19 41 02 00 	mov	2(r1),	r9	;
    831c:	59 f3       	and.b	#1,	r9	;r3 As==01
    831e:	1a 41 04 00 	mov	4(r1),	r10	;
    8322:	3a c3       	bic	#-1,	r10	;r3 As==11
    8324:	0c 49       	mov	r9,	r12	;
    8326:	0c da       	bis	r10,	r12	;
    8328:	0c 93       	cmp	#0,	r12	;r3 As==00
    832a:	12 24       	jz	$+38     	;abs 0x8350

0000832c <.Loc.81.1>:
        {
            reflection |= (1 << ((nBits - 1) - bit));
    832c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8330:	0d 4c       	mov	r12,	r13	;
    8332:	3d 53       	add	#-1,	r13	;r3 As==11
    8334:	5c 41 07 00 	mov.b	7(r1),	r12	;
    8338:	0d 8c       	sub	r12,	r13	;
    833a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    833c:	b0 12 26 89 	call	#35110		;#0x8926
    8340:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    8344:	0d 7d       	subc	r13,	r13	;
    8346:	3d e3       	inv	r13		;
    8348:	81 dc 08 00 	bis	r12,	8(r1)	;
    834c:	81 dd 0a 00 	bis	r13,	10(r1)	; 0x000a

00008350 <.L3>:
        }

        data = (data >> 1);
    8350:	12 c3       	clrc			
    8352:	11 10 04 00 	rrc	4(r1)		;
    8356:	11 10 02 00 	rrc	2(r1)		;

0000835a <.Loc.74.1>:
    unsigned char  bit;

    /*
     * Reflect the data about the center bit.
     */
    for (bit = 0; bit < nBits; ++bit)
    835a:	d1 53 07 00 	inc.b	7(r1)		;

0000835e <.L2>:
    835e:	d1 91 01 00 	cmp.b	1(r1),	7(r1)	;
    8362:	07 00 
    8364:	d9 2b       	jnc	$-76     	;abs 0x8318

00008366 <.Loc.87.1>:
        }

        data = (data >> 1);
    }

    return (reflection);
    8366:	1c 41 08 00 	mov	8(r1),	r12	;
    836a:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a

0000836e <.Loc.89.1>:

}   /* reflect() */
    836e:	31 50 0c 00 	add	#12,	r1	;#0x000c
    8372:	30 40 fc 88 	br	#0x88fc		;

00008376 <crcSlow>:
 *
 * Returns:     The CRC of the message.
 *
 *********************************************************************/
crc crcSlow(unsigned char const message[], int nBytes)
{
    8376:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000837a <.LCFI3>:
    837a:	81 4c 02 00 	mov	r12,	2(r1)	;
    837e:	81 4d 00 00 	mov	r13,	0(r1)	;

00008382 <.Loc.105.1>:
    crc            remainder = INITIAL_REMAINDER;
    8382:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

00008386 <.Loc.113.1>:


    /*
     * Perform modulo-2 division, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
    8386:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    838a:	30 40 e8 83 	br	#0x83e8		;

0000838e <.L13>:
    {
        /*
         * Bring the next byte into the remainder.
         */
        remainder ^= (REFLECT_DATA(message[byte]) << (WIDTH - 8));
    838e:	1c 41 06 00 	mov	6(r1),	r12	;
    8392:	1c 51 02 00 	add	2(r1),	r12	;
    8396:	6c 4c       	mov.b	@r12,	r12	;
    8398:	0c 5c       	rla	r12		;
    839a:	0c 5c       	rla	r12		;
    839c:	0c 5c       	rla	r12		;
    839e:	0c 5c       	rla	r12		;
    83a0:	0c 5c       	rla	r12		;
    83a2:	0c 5c       	rla	r12		;
    83a4:	0c 5c       	rla	r12		;
    83a6:	0c 5c       	rla	r12		;
    83a8:	81 ec 08 00 	xor	r12,	8(r1)	;

000083ac <.Loc.123.1>:

        /*
         * Perform modulo-2 division, a bit at a time.
         */
        for (bit = 8; bit > 0; --bit)
    83ac:	f1 42 05 00 	mov.b	#8,	5(r1)	;r2 As==11
    83b0:	30 40 de 83 	br	#0x83de		;

000083b4 <.L12>:
        {
            /*
             * Try to divide the current data bit.
             */
            if (remainder & TOPBIT)
    83b4:	1c 41 08 00 	mov	8(r1),	r12	;
    83b8:	0c 93       	cmp	#0,	r12	;r3 As==00
    83ba:	0a 34       	jge	$+22     	;abs 0x83d0

000083bc <.Loc.130.1>:
            {
                remainder = (remainder << 1) ^ POLYNOMIAL;
    83bc:	1c 41 08 00 	mov	8(r1),	r12	;
    83c0:	0c 5c       	rla	r12		;
    83c2:	0d 4c       	mov	r12,	r13	;
    83c4:	3d e0 21 10 	xor	#4129,	r13	;#0x1021
    83c8:	81 4d 08 00 	mov	r13,	8(r1)	;
    83cc:	30 40 da 83 	br	#0x83da		;

000083d0 <.L10>:
            }
            else
            {
                remainder = (remainder << 1);
    83d0:	1c 41 08 00 	mov	8(r1),	r12	;
    83d4:	0c 5c       	rla	r12		;
    83d6:	81 4c 08 00 	mov	r12,	8(r1)	;

000083da <.L11>:
        remainder ^= (REFLECT_DATA(message[byte]) << (WIDTH - 8));

        /*
         * Perform modulo-2 division, a bit at a time.
         */
        for (bit = 8; bit > 0; --bit)
    83da:	f1 53 05 00 	add.b	#-1,	5(r1)	;r3 As==11

000083de <.L9>:
    83de:	c1 93 05 00 	cmp.b	#0,	5(r1)	;r3 As==00
    83e2:	e8 23       	jnz	$-46     	;abs 0x83b4

000083e4 <.Loc.113.1>:


    /*
     * Perform modulo-2 division, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
    83e4:	91 53 06 00 	inc	6(r1)		;

000083e8 <.L8>:
    83e8:	a1 91 06 00 	cmp	@r1,	6(r1)	;
    83ec:	d0 3b       	jl	$-94     	;abs 0x838e

000083ee <.Loc.142.1>:
    }

    /*
     * The final remainder is the CRC result.
     */
    return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
    83ee:	1c 41 08 00 	mov	8(r1),	r12	;

000083f2 <.Loc.144.1>:

}   /* crcSlow() */
    83f2:	31 50 0a 00 	add	#10,	r1	;#0x000a
    83f6:	30 41       	ret			

000083f8 <crcInit>:
 * Returns:     None defined.
 *
 *********************************************************************/
void
crcInit(void)
{
    83f8:	31 80 06 00 	sub	#6,	r1	;

000083fc <.LCFI4>:


    /*
     * Compute the remainder of each possible dividend.
     */
    for (dividend = 0; dividend < 256; ++dividend)
    83fc:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8400:	30 40 68 84 	br	#0x8468		;

00008404 <.L21>:
    {
        /*
         * Start with the dividend followed by zeros.
         */
        remainder = dividend << (WIDTH - 8);
    8404:	1c 41 02 00 	mov	2(r1),	r12	;
    8408:	0c 5c       	rla	r12		;
    840a:	0c 5c       	rla	r12		;
    840c:	0c 5c       	rla	r12		;
    840e:	0c 5c       	rla	r12		;
    8410:	0c 5c       	rla	r12		;
    8412:	0c 5c       	rla	r12		;
    8414:	0c 5c       	rla	r12		;
    8416:	0c 5c       	rla	r12		;
    8418:	81 4c 04 00 	mov	r12,	4(r1)	;

0000841c <.Loc.183.1>:

        /*
         * Perform modulo-2 division, a bit at a time.
         */
        for (bit = 8; bit > 0; --bit)
    841c:	f1 42 01 00 	mov.b	#8,	1(r1)	;r2 As==11
    8420:	30 40 4e 84 	br	#0x844e		;

00008424 <.L20>:
        {
            /*
             * Try to divide the current data bit.
             */         
            if (remainder & TOPBIT)
    8424:	1c 41 04 00 	mov	4(r1),	r12	;
    8428:	0c 93       	cmp	#0,	r12	;r3 As==00
    842a:	0a 34       	jge	$+22     	;abs 0x8440

0000842c <.Loc.190.1>:
            {
                remainder = (remainder << 1) ^ POLYNOMIAL;
    842c:	1c 41 04 00 	mov	4(r1),	r12	;
    8430:	0c 5c       	rla	r12		;
    8432:	0d 4c       	mov	r12,	r13	;
    8434:	3d e0 21 10 	xor	#4129,	r13	;#0x1021
    8438:	81 4d 04 00 	mov	r13,	4(r1)	;
    843c:	30 40 4a 84 	br	#0x844a		;

00008440 <.L18>:
            }
            else
            {
                remainder = (remainder << 1);
    8440:	1c 41 04 00 	mov	4(r1),	r12	;
    8444:	0c 5c       	rla	r12		;
    8446:	81 4c 04 00 	mov	r12,	4(r1)	;

0000844a <.L19>:
        remainder = dividend << (WIDTH - 8);

        /*
         * Perform modulo-2 division, a bit at a time.
         */
        for (bit = 8; bit > 0; --bit)
    844a:	f1 53 01 00 	add.b	#-1,	1(r1)	;r3 As==11

0000844e <.L17>:
    844e:	c1 93 01 00 	cmp.b	#0,	1(r1)	;r3 As==00
    8452:	e8 23       	jnz	$-46     	;abs 0x8424

00008454 <.Loc.201.1>:
        }

        /*
         * Store the result into the table.
         */
        crcTable[dividend] = remainder;
    8454:	1c 41 02 00 	mov	2(r1),	r12	;
    8458:	0c 5c       	rla	r12		;
    845a:	3c 50 16 40 	add	#16406,	r12	;#0x4016
    845e:	9c 41 04 00 	mov	4(r1),	0(r12)	;
    8462:	00 00 

00008464 <.Loc.173.1>:


    /*
     * Compute the remainder of each possible dividend.
     */
    for (dividend = 0; dividend < 256; ++dividend)
    8464:	91 53 02 00 	inc	2(r1)		;

00008468 <.L16>:
    8468:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    846c:	1c 91 02 00 	cmp	2(r1),	r12	;
    8470:	c9 37       	jge	$-108    	;abs 0x8404

00008472 <.Loc.204.1>:
         * Store the result into the table.
         */
        crcTable[dividend] = remainder;
    }

}   /* crcInit() */
    8472:	03 43       	nop			
    8474:	31 50 06 00 	add	#6,	r1	;
    8478:	30 41       	ret			

0000847a <crcFast>:
 *
 * Returns:     The CRC of the message.
 *
 *********************************************************************/
crc crcFast(unsigned char const message[], int nBytes)
{
    847a:	0a 12       	push	r10		;

0000847c <.LCFI5>:
    847c:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00008480 <.LCFI6>:
    8480:	81 4c 02 00 	mov	r12,	2(r1)	;
    8484:	81 4d 00 00 	mov	r13,	0(r1)	;

00008488 <.Loc.220.1>:
    crc            remainder = INITIAL_REMAINDER;
    8488:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

0000848c <.Loc.228.1>:


    /*
     * Divide the message by the polynomial, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
    848c:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    8490:	30 40 de 84 	br	#0x84de		;

00008494 <.L24>:
    {
        data = REFLECT_DATA(message[byte]) ^ (remainder >> (WIDTH - 8));
    8494:	1c 41 06 00 	mov	6(r1),	r12	;
    8498:	1c 51 02 00 	add	2(r1),	r12	;
    849c:	6a 4c       	mov.b	@r12,	r10	;
    849e:	1c 41 08 00 	mov	8(r1),	r12	;
    84a2:	b0 12 92 89 	call	#35218		;#0x8992
    84a6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    84aa:	4d 4a       	mov.b	r10,	r13	;
    84ac:	4d ec       	xor.b	r12,	r13	;
    84ae:	c1 4d 05 00 	mov.b	r13,	5(r1)	;

000084b2 <.Loc.231.1>:
        remainder = crcTable[data] ^ (remainder << 8);
    84b2:	5c 41 05 00 	mov.b	5(r1),	r12	;
    84b6:	0c 5c       	rla	r12		;
    84b8:	3c 50 16 40 	add	#16406,	r12	;#0x4016
    84bc:	2d 4c       	mov	@r12,	r13	;
    84be:	1c 41 08 00 	mov	8(r1),	r12	;
    84c2:	0c 5c       	rla	r12		;
    84c4:	0c 5c       	rla	r12		;
    84c6:	0c 5c       	rla	r12		;
    84c8:	0c 5c       	rla	r12		;
    84ca:	0c 5c       	rla	r12		;
    84cc:	0c 5c       	rla	r12		;
    84ce:	0c 5c       	rla	r12		;
    84d0:	0c 5c       	rla	r12		;
    84d2:	0e 4d       	mov	r13,	r14	;
    84d4:	0e ec       	xor	r12,	r14	;
    84d6:	81 4e 08 00 	mov	r14,	8(r1)	;

000084da <.Loc.228.1>:


    /*
     * Divide the message by the polynomial, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
    84da:	91 53 06 00 	inc	6(r1)		;

000084de <.L23>:
    84de:	a1 91 06 00 	cmp	@r1,	6(r1)	;
    84e2:	d8 3b       	jl	$-78     	;abs 0x8494

000084e4 <.Loc.237.1>:
    }

    /*
     * The final remainder is the CRC.
     */
    return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
    84e4:	1c 41 08 00 	mov	8(r1),	r12	;

000084e8 <.Loc.239.1>:

}   /* crcFast() */
    84e8:	31 50 0a 00 	add	#10,	r1	;#0x000a
    84ec:	3a 41       	pop	r10		;
    84ee:	30 41       	ret			

000084f0 <init>:

void init()
{
     WDTCTL = WDTPW | WDTHOLD; // Stop WDT
    84f0:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    84f4:	bc 40 80 5a 	mov	#23168,	0(r12)	;#0x5a80
    84f8:	00 00 

000084fa <.Loc.244.1>:
     __asm__ __volatile__ ("nop");
    84fa:	03 43       	nop			

000084fc <.Loc.245.1>:
     eint();
    84fc:	32 d2       	eint			
    84fe:	03 43       	nop			

00008500 <.Loc.246.1>:
     UART_BAUD = BAUD;                   // Init UART
    8500:	7c 40 82 00 	mov.b	#130,	r12	;#0x0082
    8504:	bc 42 00 00 	mov	#8,	0(r12)	;r2 As==11

00008508 <.Loc.247.1>:
     UART_CTL  = UART_EN;
    8508:	7c 40 80 00 	mov.b	#128,	r12	;#0x0080
    850c:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00008510 <.Loc.249.1>:
     //Enable QWARK
     QWARK_CTL = QWARK_EN;
    8510:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    8514:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00008518 <.Loc.250.1>:
}
    8518:	03 43       	nop			
    851a:	30 41       	ret			

0000851c <main>:

crc crc_slow_output=0;
crc crc_fast_output=0;

int main(void)
{
    851c:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00008520 <.LCFI7>:
    init();
    8520:	b0 12 f0 84 	call	#34032		;#0x84f0

00008524 <.Loc.260.1>:
    //ta_wait(4980); //10ms

    unsigned char  test[] = "123456789";
    8524:	b1 40 31 32 	mov	#12849,	0(r1)	;#0x3231
    8528:	00 00 
    852a:	b1 40 33 34 	mov	#13363,	2(r1)	;#0x3433
    852e:	02 00 
    8530:	b1 40 35 36 	mov	#13877,	4(r1)	;#0x3635
    8534:	04 00 
    8536:	b1 40 37 38 	mov	#14391,	6(r1)	;#0x3837
    853a:	06 00 
    853c:	b1 40 39 00 	mov	#57,	8(r1)	;#0x0039
    8540:	08 00 

00008542 <.Loc.262.1>:

    LED_CTRL = 0xFF;
    8542:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8546:	fc 43 00 00 	mov.b	#-1,	0(r12)	;r3 As==11

0000854a <.Loc.283.1>:
     */
    #ifdef UART_DBG
    UART_WriteString(" - The crcSlow() of \"123456789\" is 0x");
    #endif

    crc_slow_output = crcSlow(test, strlen(test));
    854a:	0c 41       	mov	r1,	r12	;
    854c:	b0 12 2a 8a 	call	#35370		;#0x8a2a
    8550:	0d 4c       	mov	r12,	r13	;
    8552:	0c 41       	mov	r1,	r12	;
    8554:	b0 12 76 83 	call	#33654		;#0x8376
    8558:	82 4c 00 40 	mov	r12,	&0x4000	;

0000855c <.Loc.290.1>:
    #ifdef UART_DBG
    UART_16_WriteHex(crc_slow_output);
    #endif

    //printf("The crcSlow() of \"123456789\" is 0x%X\n", crcSlow(test, strlen(test)));
    crcSlow(test,9);
    855c:	0c 41       	mov	r1,	r12	;
    855e:	7d 40 09 00 	mov.b	#9,	r13	;
    8562:	b0 12 76 83 	call	#33654		;#0x8376

00008566 <.Loc.295.1>:
    
    /*
     * Compute the CRC of the test message, more efficiently.
     */
    crcInit();
    8566:	b0 12 f8 83 	call	#33784		;#0x83f8

0000856a <.Loc.301.1>:

    #ifdef UART_DBG
    UART_WriteString(" - The crcFast() of \"123456789\" is 0x");
    #endif

    crc_fast_output = crcFast(test, strlen(test));
    856a:	0c 41       	mov	r1,	r12	;
    856c:	b0 12 2a 8a 	call	#35370		;#0x8a2a
    8570:	0d 4c       	mov	r12,	r13	;
    8572:	0c 41       	mov	r1,	r12	;
    8574:	b0 12 7a 84 	call	#33914		;#0x847a
    8578:	82 4c 02 40 	mov	r12,	&0x4002	;

0000857c <.Loc.307.1>:
   
    #ifdef UART_DBG
    UART_16_WriteHex(crc_fast_output);
    #endif
    //printf("The crcFast() of \"123456789\" is 0x%X\n", crcFast(test, strlen(test)));
    crcFast(test,9);
    857c:	0c 41       	mov	r1,	r12	;
    857e:	7d 40 09 00 	mov.b	#9,	r13	;
    8582:	b0 12 7a 84 	call	#33914		;#0x847a

00008586 <.Loc.309.1>:

    LED_CTRL = 0x00;
    8586:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    858a:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

0000858e <.L28>:

    while(1);
    858e:	30 40 8e 85 	br	#0x858e		;

00008592 <INT_Qwark>:

interrupt (QWARK_VECTOR) INT_Qwark(void) {
	
	/* No local Variables are allowed in this context*/
	/* Idempotency Tracking is disabled by default upon entering this context */
	asm ("mov #0xAA, &0x0090 ");	
    8592:	b2 40 aa 00 	mov	#170,	&0x0090	;#0x00aa
    8596:	90 00 

00008598 <.Loc.283.1>:
	//---------------------------------------------------------------------------------------------------------------------------------//
	//    CHECKPOINT SETUP: Identify which of the 2 checkpoint buffers should be written, one should always be consistent		       //
	//	  W.C. 18 CYCLES  													   														   //	 
	//	  B.C. 10 CYCLES 													   														   //
	//---------------------------------------------------------------------------------------------------------------------------------//
		asm ("mov r13, &0x6070"); 		//temporal r13: 4 cycles
    8598:	82 4d 70 60 	mov	r13,	&0x6070	;

0000859c <.Loc.284.1>:
		asm ("mov r12, &0x6072"); 		//temporal r12: 4 cycles
    859c:	82 4c 72 60 	mov	r12,	&0x6072	;

000085a0 <.Loc.286.1>:

		asm ("cmp.b #0x01,&0x6075"); 		//4 cycles
    85a0:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

000085a4 <.Loc.287.1>:
		asm ("jz __second_buffer_init");	//2 cycles
    85a4:	06 24       	jz	$+14     	;abs 0x85b2

000085a6 <.Loc.289.1>:

		asm ("mov #0x6010, r12"); 		//Load the base pointer of the first checkpoint buffer: 2 cycles
    85a6:	3c 40 10 60 	mov	#24592,	r12	;#0x6010

000085aa <.Loc.290.1>:
		asm ("mov.b #0x01,&0x6074");		//4 cycles
    85aa:	d2 43 74 60 	mov.b	#1,	&0x6074	;r3 As==01

000085ae <.Loc.291.1>:
		asm ("br #__first_phase_commit");	//2 cycles
    85ae:	30 40 b6 85 	br	#0x85b6		;

000085b2 <__second_buffer_init>:

		asm ("__second_buffer_init:");

		asm ("mov #0x6040, r12"); 		//Load the base pointer of the second checkpoint buffer: 2 cycles
    85b2:	3c 40 40 60 	mov	#24640,	r12	;#0x6040

000085b6 <__first_phase_commit>:
		//-------------------------------------------------------------------------------------------------------------//
		

		asm ("__first_phase_commit:");
		//Verify readjustments on the PC
		asm ("mov 2(r1),@r12"); 					//PC/R0   6 cycles
    85b6:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    85ba:	00 00 

000085bc <.Loc.311.1>:

		asm ("cmp #0x0000,&0x02B8"); 				//        5 cycles
    85bc:	82 93 b8 02 	cmp	#0,	&0x02b8	;r3 As==00

000085c0 <.Loc.312.1>:
		asm ("jeq __continue_first_phase_commit"); 	//PC/R0   2 cycles
    85c0:	03 24       	jz	$+8      	;abs 0x85c8

000085c2 <.Loc.313.1>:
		asm ("sub &0x02B8,@r12");					//		  6 cycles
    85c2:	9c 82 b8 02 	sub	&0x02b8,0(r12)	;0x02b8
    85c6:	00 00 

000085c8 <__continue_first_phase_commit>:

		asm ("__continue_first_phase_commit:");

		asm ("incd r12");							//	  	  1 cycle
    85c8:	2c 53       	incd	r12		;

000085ca <.Loc.319.1>:

		asm ("mov r1,@r12");   						//SP/R1   4 cycles
    85ca:	8c 41 00 00 	mov	r1,	0(r12)	;

000085ce <.Loc.320.1>:
		asm ("add #0x04,@r12");						//	  	  5 cycles
    85ce:	ac 52 00 00 	add	#4,	0(r12)	;r2 As==10

000085d2 <.Loc.321.1>:
		asm ("incd r12");							// 	  	  1 cycle
    85d2:	2c 53       	incd	r12		;

000085d4 <.Loc.323.1>:

		asm ("mov 0(r1),@r12"); 					//SR/R2   6 cycles
    85d4:	ac 41 00 00 	mov	@r1,	0(r12)	;

000085d8 <.Loc.324.1>:
		asm ("incd r12");							// 	 	  1 cycle
    85d8:	2c 53       	incd	r12		;

000085da <.Loc.326.1>:

		asm ("mov &0x02A0,r13"); 					// Disable Qwark and signal a buffer reset without modifying the data - 3 cycles
    85da:	1d 42 a0 02 	mov	&0x02a0,r13	;0x02a0

000085de <.Loc.327.1>:
		asm ("and #0x3E,r13"); 						//		  2 cycles
    85de:	3d f0 3e 00 	and	#62,	r13	;#0x003e

000085e2 <.Loc.328.1>:
		asm ("bis #0x40,r13"); 						//		  2 cycles
    85e2:	3d d0 40 00 	bis	#64,	r13	;#0x0040

000085e6 <.Loc.329.1>:
		asm ("mov r13,&0x02A0");					//		  4 cycles		
    85e6:	82 4d a0 02 	mov	r13,	&0x02a0	;

000085ea <.Loc.330.1>:
		asm ("and #0xBF,r13"); 						//		  2 cycles
    85ea:	3d f0 bf 00 	and	#191,	r13	;#0x00bf

000085ee <.Loc.331.1>:
		asm ("mov r13,&0x02A0");					//	 	  4 cycles		
    85ee:	82 4d a0 02 	mov	r13,	&0x02a0	;

000085f2 <.Loc.333.1>:

		asm ("mov r4,@r12"); 					    //R4	  4 cycles
    85f2:	8c 44 00 00 	mov	r4,	0(r12)	;

000085f6 <.Loc.334.1>:
		asm ("incd r12");							// 	 	  1 cycle
    85f6:	2c 53       	incd	r12		;

000085f8 <.Loc.336.1>:

		asm ("mov r5,@r12"); 						//R5	  4 cycles
    85f8:	8c 45 00 00 	mov	r5,	0(r12)	;

000085fc <.Loc.337.1>:
		asm ("incd r12");							// 		  1 cycle
    85fc:	2c 53       	incd	r12		;

000085fe <.Loc.339.1>:

		asm ("mov r6,@r12"); 						//R6	  4 cycles
    85fe:	8c 46 00 00 	mov	r6,	0(r12)	;

00008602 <.Loc.340.1>:
		asm ("incd r12");							// 		  1 cycle
    8602:	2c 53       	incd	r12		;

00008604 <.Loc.342.1>:

		asm ("mov r7,@r12"); 					    //R7	  4 cycles
    8604:	8c 47 00 00 	mov	r7,	0(r12)	;

00008608 <.Loc.343.1>:
		asm ("incd r12");							// 		  1 cycle
    8608:	2c 53       	incd	r12		;

0000860a <.Loc.345.1>:

		asm ("mov r8,@r12"); 						//R8	  4 cycles
    860a:	8c 48 00 00 	mov	r8,	0(r12)	;

0000860e <.Loc.346.1>:
		asm ("incd r12");							// 		  1 cycle
    860e:	2c 53       	incd	r12		;

00008610 <.Loc.348.1>:

		asm ("mov r9,@r12"); 						//R9	  4 cycles
    8610:	8c 49 00 00 	mov	r9,	0(r12)	;

00008614 <.Loc.349.1>:
		asm ("incd r12");							// 		  1 cycle
    8614:	2c 53       	incd	r12		;

00008616 <.Loc.351.1>:

		asm ("mov r10,@r12"); 						//R10	  4 cycles
    8616:	8c 4a 00 00 	mov	r10,	0(r12)	;

0000861a <.Loc.352.1>:
		asm ("incd r12");							// 		  1 cycle
    861a:	2c 53       	incd	r12		;

0000861c <.Loc.354.1>:

		asm ("mov r11,@r12"); 						//R11	  4 cycles
    861c:	8c 4b 00 00 	mov	r11,	0(r12)	;

00008620 <.Loc.355.1>:
		asm ("incd r12");							// 		  1 cycle
    8620:	2c 53       	incd	r12		;

00008622 <.Loc.357.1>:

		asm ("mov &0x6072,@r12"); 					//R12	  6 cycles
    8622:	9c 42 72 60 	mov	&0x6072,0(r12)	;0x6072
    8626:	00 00 

00008628 <.Loc.358.1>:
		asm ("incd r12");							// 		  1 cycle
    8628:	2c 53       	incd	r12		;

0000862a <.Loc.360.1>:

		asm ("mov &0x6070,@r12"); 					//R13	  4 cycles
    862a:	9c 42 70 60 	mov	&0x6070,0(r12)	;0x6070
    862e:	00 00 

00008630 <.Loc.361.1>:
		asm ("incd r12");							// 		  1 cycle
    8630:	2c 53       	incd	r12		;

00008632 <.Loc.363.1>:

		asm ("mov r14,@r12"); 						//R14	  4 cycles
    8632:	8c 4e 00 00 	mov	r14,	0(r12)	;

00008636 <.Loc.364.1>:
		asm ("incd r12");							// 		  1 cycle
    8636:	2c 53       	incd	r12		;

00008638 <.Loc.366.1>:

		asm ("mov r15,@r12"); 						//R15	  4 cycles
    8638:	8c 4f 00 00 	mov	r15,	0(r12)	;

0000863c <.Loc.367.1>:
		asm ("incd r12");							// 		  1 cycle
    863c:	2c 53       	incd	r12		;

0000863e <.Loc.375.1>:
	//    WAR VIOLATION INDEX CHECKPOINT: Get the index indicating the amount of violations stored 		           //
	//	  10 CYCLES											       												   //
	//													       													   //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("mov &0x02A0, r14");	// 		  3 cycles
    863e:	1e 42 a0 02 	mov	&0x02a0,r14	;0x02a0

00008642 <.Loc.376.1>:
		asm ("RRA r14");			// 		  1 cycle
    8642:	0e 11       	rra	r14		;

00008644 <.Loc.377.1>:
		asm ("mov.b r14, @r12");	// 		  4 cycles
    8644:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00008648 <.Loc.378.1>:
		asm ("mov r14, r15 ");		// 		  1 cycle (save the index for later)
    8648:	0f 4e       	mov	r14,	r15	;

0000864a <.Loc.379.1>:
		asm ("incd r12");			// 		  1 Cycle
    864a:	2c 53       	incd	r12		;

0000864c <.Loc.389.1>:
	//	  B.C.	 5 CYCLES FOR EMPTY TLB									       									   //
	//-------------------------------------------------------------------------------------------------------------//

		/* Setup registers for copy*/

		asm ("tst r14 ");     	    	// 		  1 cycle
    864c:	0e 93       	cmp	#0,	r14	;r3 As==00

0000864e <.Loc.390.1>:
		asm ("jz  __seg_logic");		// 		  2 cycles
    864e:	08 24       	jz	$+18     	;abs 0x8660

00008650 <.Loc.392.1>:

		asm ("mov #0x02A2, r13");		// 		  2 cycles
    8650:	3d 40 a2 02 	mov	#674,	r13	;#0x02a2

00008654 <_scratchpad_addr_cpy>:

		asm ("_scratchpad_addr_cpy:");  // Each iteration takes 10 cycles - Worst case 80 cycles

		asm ("mov @r13+2, @r12");  		// 		  5 cycles
    8654:	bc 4d 00 00 	mov	@r13+,	0(r12)	;

00008658 <.Loc.397.1>:
		asm ("incd r12");  				// 		  1 cycle
    8658:	2c 53       	incd	r12		;

0000865a <.Loc.398.1>:
		asm ("dec r14 ");      			// 		  1 cycle
    865a:	1e 83       	dec	r14		;

0000865c <.Loc.399.1>:
		asm ("tst r14 ");     			// 		  1 cycle
    865c:	0e 93       	cmp	#0,	r14	;r3 As==00

0000865e <.Loc.400.1>:
		asm ("jnz  _scratchpad_addr_cpy");// 	  2 cycles
    865e:	fa 23       	jnz	$-10     	;abs 0x8654

00008660 <__seg_logic>:
		
		asm ("__seg_logic:");  

		// identify what kind of interruption happened (segmentation or buffer overflow)

		asm ("mov &0x02B2, r12 ");			 // 4 cycles 
    8660:	1c 42 b2 02 	mov	&0x02b2,r12	;0x02b2

00008664 <.Loc.413.1>:
		asm ("and #0x8000, r12 ");			 // 4 cycles 
    8664:	3c f0 00 80 	and	#32768,	r12	;#0x8000

00008668 <.Loc.414.1>:
		asm ("cmp #0x8000, r12 ");			 // 4 cycles 
    8668:	3c 90 00 80 	cmp	#32768,	r12	;#0x8000

0000866c <.Loc.417.1>:
		
		//if the comparison is equal, it means that the isr was triggered by a segmentation request
		asm ("jeq __segmentation_isr");		 // 4 cycles - copy segment address to NV location for restore
    866c:	0a 24       	jz	$+22     	;abs 0x8682

0000866e <.Loc.420.1>:

		//This sequence is for a segmentation based on buffer overflow
		asm ("mov &0X6042, r12"); 			 // Ok, it wasnt a segmentation. Then we should segment based on the current  - 3 cycles
    866e:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008672 <.Loc.422.1>:

		asm ("cmp.b #0x01,&0x6075");		 // 4 cycles
    8672:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

00008676 <.Loc.423.1>:
		asm ("jz __commit_th");		 	     // 2 cycles
    8676:	09 24       	jz	$+20     	;abs 0x868a

00008678 <.Loc.426.1>:

		// We know it is not the first time...but which stack shall we use ?
		asm ("mov &0X6012, r12"); 			 // Get the SP from the right buffer - 3 cycles
    8678:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

0000867c <.Loc.427.1>:
		asm ("cmp.b #0x01,&0x6074");   	 	 // Verify if we are being indicated that we should work with the first - 4 cycles
    867c:	d2 93 74 60 	cmp.b	#1,	&0x6074	;r3 As==01

00008680 <.Loc.428.1>:
		asm ("jz __commit_th");		 	 	 // 2 cycles
    8680:	04 24       	jz	$+10     	;abs 0x868a

00008682 <__segmentation_isr>:

		asm ("__segmentation_isr:");
		asm ("mov &0x02B2, r12 ");			 // 3 cycles - copy segment address to NV location for restore
    8682:	1c 42 b2 02 	mov	&0x02b2,r12	;0x02b2

00008686 <.Loc.432.1>:
		asm ("and #0x7FFF, r12 ");			 // 2 cycles - copy segment address to NV location for restore
    8686:	3c f0 ff 7f 	and	#32767,	r12	;#0x7fff

0000868a <__commit_th>:
	//   DOUBLE BUFFER THE NEW SEGMENT LIMIT								       								   //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("__commit_th:");

		asm ("cmp #0x8000,r12");		 // 4 cycles
    868a:	3c 90 00 80 	cmp	#32768,	r12	;#0x8000

0000868e <.Loc.441.1>:
		asm ("jne __commit_th_cmp");	 // 4 cycles
    868e:	01 20       	jnz	$+4      	;abs 0x8692

00008690 <.Loc.442.1>:
		asm ("decd  r12");		 		 // 4 cycles
    8690:	2c 83       	decd	r12		;

00008692 <__commit_th_cmp>:

		asm ("__commit_th_cmp:");

		asm ("cmp.b #0x01,&0x6075");		 // 4 cycles
    8692:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

00008696 <.Loc.447.1>:
		asm ("jz  __commit_on_2nd ");		 // 2 cycles
    8696:	04 24       	jz	$+10     	;abs 0x86a0

00008698 <.Loc.448.1>:
		asm ("mov r12, &0x6076"); 		     // 4 cycles	- save the SP in the NV memory for restore
    8698:	82 4c 76 60 	mov	r12,	&0x6076	;

0000869c <.Loc.450.1>:
		
		asm ("br #_chkpt_stack");		     // 2 cycles
    869c:	30 40 a4 86 	br	#0x86a4		;

000086a0 <__commit_on_2nd>:

		asm ("__commit_on_2nd: ");
		asm ("mov r12, &0x6078 "); 	 	 	 // 4 cycles		
    86a0:	82 4c 78 60 	mov	r12,	&0x6078	;

000086a4 <_chkpt_stack>:
	//   STACK PROMOTION  							       		       							   			   	   //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("_chkpt_stack:");
			
		asm ("mov #0x0000, &0x6BFE");			 // 4 cycles
    86a4:	82 43 fe 6b 	mov	#0,	&0x6bfe	;r3 As==00

000086a8 <.Loc.462.1>:
		asm ("mov #0x0000, &0x6BFC");			 // 4 cycles 
    86a8:	82 43 fc 6b 	mov	#0,	&0x6bfc	;r3 As==00

000086ac <__first_stack_chkpt_setup>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - FIRST CHECKPOINT: 				       				      							   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__first_stack_chkpt_setup:");	
		asm ("cmp.b #0x00, &0x6075 ");			 // 4 cycles - This is 0 only the first time the code executes, the first time all the stack has to be checkpointed
    86ac:	c2 93 75 60 	cmp.b	#0,	&0x6075	;r3 As==00

000086b0 <.Loc.468.1>:
		asm ("jne __segmentation_logic");	 	 // 2 cycles		
    86b0:	06 20       	jnz	$+14     	;abs 0x86be

000086b2 <.Loc.471.1>:


		asm ("mov #0x6FFE, r13");			 	 // 2 cycles - this executes only once
    86b2:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

000086b6 <.Loc.472.1>:
		asm ("mov #0x7FFE, r14");			 	 // 2 cycles - this executes only once
    86b6:	3e 40 fe 7f 	mov	#32766,	r14	;#0x7ffe

000086ba <.Loc.473.1>:
		asm ("br #__copy_stack");		  	 	 // 2 cycle  - the first execution is all set, start copy	
    86ba:	30 40 16 87 	br	#0x8716		;

000086be <__segmentation_logic>:
		//   STACK CHECKPOINT - LOGIC TO DETERMINE BOUNDARIES OF SEGMENTATION				      	       			   //
		//-------------------------------------------------------------------------------------------------------------//

		asm ("__segmentation_logic:");			

		asm ("mov &0x02B4, r14");			 	 // 3 cycles - Get the Max val address -> R14 - 3 cycles
    86be:	1e 42 b4 02 	mov	&0x02b4,r14	;0x02b4

000086c2 <.Loc.482.1>:
		asm ("mov &0x6076, r10");			 	 // Get the previous segment limit     -> R10 - 3 cycles
    86c2:	1a 42 76 60 	mov	&0x6076,r10	;0x6076

000086c6 <.Loc.483.1>:
		asm ("cmp.b #0x01, &0x6075 ");			 // 4 cycles 
    86c6:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

000086ca <.Loc.484.1>:
		asm ("jeq __sp_seg_define ");		 	 // 2 cycles 
    86ca:	02 24       	jz	$+6      	;abs 0x86d0

000086cc <.Loc.485.1>:
		asm ("mov &0x6078, r10");				 // 3 cycles (29 up to this point)
    86cc:	1a 42 78 60 	mov	&0x6078,r10	;0x6078

000086d0 <__sp_seg_define>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - VERIFY IF THE SEGMENT DIDNT CHANGE OR INCREMENTAL CHECKPOINT			       		   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__sp_seg_define:");

		asm ("cmp r10, r14");			 	 	 // 1 cycle - compare the old segment and the max value 
    86d0:	0e 9a       	cmp	r10,	r14	;

000086d2 <.Loc.493.1>:
		asm ("jne __sp_overlap");	 		 	 // 2 cycles 
    86d2:	04 20       	jnz	$+10     	;abs 0x86dc

000086d4 <.Loc.496.1>:


		asm ("cmp r10, r12");			 	 	 // 1 cycle - compare the new segment and the old segment value 
    86d4:	0c 9a       	cmp	r10,	r12	;

000086d6 <.Loc.497.1>:
		asm ("jeq __stack_chkpt_end");	 		 // 2 cycles 
    86d6:	27 24       	jz	$+80     	;abs 0x8726

000086d8 <.Loc.498.1>:
		asm ("br #__sp_pre_copy");		  	 	 // 2 cycles
    86d8:	30 40 0e 87 	br	#0x870e		;

000086dc <__sp_overlap>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - OVERLAP CHECKPOINT									       							   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__sp_overlap:"); //32 up to this point

		asm ("cmp r14, r12");			 	 	 // 1 cycle - compare the new segment and the max value 
    86dc:	0c 9e       	cmp	r14,	r12	;

000086de <.Loc.506.1>:
		asm ("jeq __stack_chkpt_end");	 	 	 // 2 cycles
    86de:	23 24       	jz	$+72     	;abs 0x8726

000086e0 <.Loc.508.1>:

		asm ("decd r14 ");				 		 // 1 cycle
    86e0:	2e 83       	decd	r14		;

000086e2 <.Loc.510.1>:

		asm ("mov #0x6BFE, r13");				 // 2 cycles
    86e2:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

000086e6 <.Loc.511.1>:
		asm ("mov r14, @r13 ");					 //start address at 0x6BFE - 4 cycles
    86e6:	8d 4e 00 00 	mov	r14,	0(r13)	;

000086ea <.Loc.512.1>:
		asm ("decd r13 ");						 // 1 cycle
    86ea:	2d 83       	decd	r13		;

000086ec <.Loc.513.1>:
		asm ("mov r10, @r13");					 //end address at  0x6BFC - 4 cycles
    86ec:	8d 4a 00 00 	mov	r10,	0(r13)	;

000086f0 <.Loc.514.1>:
		asm ("decd r13 ");						 // 1 cycle
    86f0:	2d 83       	decd	r13		;

000086f2 <.Loc.516.1>:
		
		asm ("mov r12, r11 ");					 // 1 cycle
    86f2:	0b 4c       	mov	r12,	r11	;

000086f4 <.Loc.517.1>:
		asm ("cmp r10, r12");	   			 	 //  (new >= old) if true use r12 as the limit 	- 1 cycle	
    86f4:	0c 9a       	cmp	r10,	r12	;

000086f6 <.Loc.518.1>:
		asm ("jge __overlap_copy");				 // 2 cycles
    86f6:	01 34       	jge	$+4      	;abs 0x86fa

000086f8 <.Loc.519.1>:
		asm ("mov r10, r11 ");					 // 1 cycle
    86f8:	0b 4a       	mov	r10,	r11	;

000086fa <__overlap_copy>:

		asm ("__overlap_copy:");

		asm ("mov @r14, @r13 ");				// 5 cycles (53 up to this point)
    86fa:	ad 4e 00 00 	mov	@r14,	0(r13)	;

000086fe <.Loc.524.1>:
		asm ("cmp r14,r11");	   		  	 	// compare and verify if the LIMIT has been reached - 1 cycle
    86fe:	0b 9e       	cmp	r14,	r11	;

00008700 <.Loc.526.1>:

		asm ("jeq __sp_ovl_copy");	 	 	 	// 2 cycles
    8700:	04 24       	jz	$+10     	;abs 0x870a

00008702 <.Loc.527.1>:
		asm ("decd r13");						// 1 cycle
    8702:	2d 83       	decd	r13		;

00008704 <.Loc.528.1>:
		asm ("decd r14");				 		// 1 cycle
    8704:	2e 83       	decd	r14		;

00008706 <.Loc.529.1>:
		asm ("br #__overlap_copy");				// 2 cycles
    8706:	30 40 fa 86 	br	#0x86fa		;

0000870a <__sp_ovl_copy>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - VERIFY IF A COPY IS NECESSARY AFTER THE OVERLAP	       				       			   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__sp_ovl_copy:");
	
		asm ("cmp r10,r12");	   			 // r12 >= r10 ?  new seg >= old ? 		  	 
    870a:	0c 9a       	cmp	r10,	r12	;

0000870c <.Loc.537.1>:
		asm ("jge __stack_chkpt_end");
    870c:	0c 34       	jge	$+26     	;abs 0x8726

0000870e <__sp_pre_copy>:

		asm ("__sp_pre_copy:");

		asm ("decd r14 ");				 	 // 1 cycle
    870e:	2e 83       	decd	r14		;

00008710 <.Loc.542.1>:
		asm ("mov r14, r13");			 	 // 2 cycles
    8710:	0d 4e       	mov	r14,	r13	;

00008712 <.Loc.543.1>:
		asm ("sub #0x1000, r13");			 // 2 cycles - Make the equal stack max offset (e.g., 0x6FCE -> 0x7FCE)
    8712:	3d 80 00 10 	sub	#4096,	r13	;#0x1000

00008716 <__copy_stack>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - COPY ROUTINE: 				       				       	       						   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__copy_stack:");

		asm ("mov @r14,@r13");			 	 // 5 cycles
    8716:	ad 4e 00 00 	mov	@r14,	0(r13)	;

0000871a <.Loc.552.1>:

		asm ("cmp r14,r12");	   		  	 // compare and verify if the base has been reached - 1 cycle
    871a:	0c 9e       	cmp	r14,	r12	;

0000871c <.Loc.553.1>:
		asm ("jz __stack_chkpt_end");	 	 // 2 cycles
    871c:	04 24       	jz	$+10     	;abs 0x8726

0000871e <.Loc.555.1>:

		asm ("decd r13");				 	 // 1 cycle
    871e:	2d 83       	decd	r13		;

00008720 <.Loc.556.1>:
		asm ("decd r14");					 // 1 cycle
    8720:	2e 83       	decd	r14		;

00008722 <.Loc.557.1>:
		asm ("br #__copy_stack");		  	 // 2 cycle
    8722:	30 40 16 87 	br	#0x8716		;

00008726 <__stack_chkpt_end>:
	//-------------------------------------------------------------------------------------------------------------//
	//    END OF THE FIRST PHASE: Atomic Flag Handling for halfway through checkpoint			       			   //
	//	  W.C 18 Cycles											       											   //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("cmp.b #0x01,&0x6075");		 // 4 cycles
    8726:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

0000872a <.Loc.567.1>:
		asm ("jz  __set_flag_2nd ");		 // 2 cycles
    872a:	04 24       	jz	$+10     	;abs 0x8734

0000872c <.Loc.569.1>:

		asm ("add.b #0x01, &0x6074 "); 	 	 // 4 cycles
    872c:	d2 53 74 60 	inc.b	&0x6074		;

00008730 <.Loc.570.1>:
		asm ("br  #_WAR_commit "); 	    	 // 4 cycles
    8730:	30 40 38 87 	br	#0x8738		;

00008734 <__set_flag_2nd>:

		asm ("__set_flag_2nd:");
		asm ("add.b #0x01, &0x6075 "); 		 // 4 cycles		/* THE RESTORE ROUTINE CAN FINALIZE THIS HALFWAY CHECKPOINT  */
    8734:	d2 53 75 60 	inc.b	&0x6075		;

00008738 <_WAR_commit>:
		//   CONTINUE WITH THE COMMIT OF THE WARs				       				       							   //
		//-------------------------------------------------------------------------------------------------------------//
		
		asm ("_WAR_commit:");

		asm ("tst r15 ");     		         	// 1 cycle
    8738:	0f 93       	cmp	#0,	r15	;r3 As==00

0000873a <.Loc.589.1>:
		asm ("jz  _stack_write_back");		 	// 2 cycles
    873a:	25 24       	jz	$+76     	;abs 0x8786

0000873c <.Loc.591.1>:

		asm ("mov #0x6000,  r14 ");		 	 	// 2 cycles
    873c:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008740 <.Loc.593.1>:

		asm ("mov #0x6060,  r12 ");		 	 	// 2 cycles
    8740:	3c 40 60 60 	mov	#24672,	r12	;#0x6060

00008744 <.Loc.594.1>:
		asm ("cmp.b #0x02,&0x6075");		 	// 4 cycles
    8744:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008748 <.Loc.595.1>:
		asm ("jz _second_phase_commit_strt");   // 2 cycles
    8748:	02 24       	jz	$+6      	;abs 0x874e

0000874a <.Loc.597.1>:

		asm ("mov #0x6030,  r12 ");		 		// 2 cycles
    874a:	3c 40 30 60 	mov	#24624,	r12	;#0x6030

0000874e <_second_phase_commit_strt>:

		asm ("_second_phase_commit_strt:"); 	// Worst case

		asm ("mov @r12+2,  r13 ");   		 	// 3 cycles
    874e:	3d 4c       	mov	@r12+,	r13	;

00008750 <.Loc.603.1>:

		asm ("mov r13,  r11 ");   		 		// 1 cycle
    8750:	0b 4d       	mov	r13,	r11	;

00008752 <.Loc.605.1>:

		asm ("and #0x8000,  r11 ");   		 	// 2 cycles
    8752:	3b f0 00 80 	and	#32768,	r11	;#0x8000

00008756 <.Loc.606.1>:
		asm ("cmp #0x8000,  r11 ");   		 	// 2 cycles
    8756:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

0000875a <.Loc.607.1>:
		asm ("jeq _byte_copy ");   				// 2 cycles
    875a:	08 24       	jz	$+18     	;abs 0x876c

0000875c <.Loc.609.1>:

		asm ("mov @r14, @r13 ");    		 	// 5 cycles
    875c:	ad 4e 00 00 	mov	@r14,	0(r13)	;

00008760 <_pre_end_copy>:

		asm ("_pre_end_copy:");
		asm ("incd r14");    			 		// 1 cycle
    8760:	2e 53       	incd	r14		;

00008762 <.Loc.613.1>:
		asm ("dec r15");    			 		// 1 cycle
    8762:	1f 83       	dec	r15		;

00008764 <.Loc.614.1>:
		asm ("tst r15");    			 		// 1 cycle
    8764:	0f 93       	cmp	#0,	r15	;r3 As==00

00008766 <.Loc.616.1>:

		asm ("jnz  _second_phase_commit_strt"); // 2 cycles
    8766:	f3 23       	jnz	$-24     	;abs 0x874e

00008768 <.Loc.617.1>:
		asm ("br #_stack_write_back");		 	// 2 cycles
    8768:	30 40 86 87 	br	#0x8786		;

0000876c <_byte_copy>:

		asm ("_byte_copy:");
		asm ("and #0x7FFF,  r13 ");   			// mask the highest bit - 2 cycles
    876c:	3d f0 ff 7f 	and	#32767,	r13	;#0x7fff

00008770 <.Loc.621.1>:
		asm ("mov r13,      r11 ");   			// 1 cycle
    8770:	0b 4d       	mov	r13,	r11	;

00008772 <.Loc.622.1>:
		asm ("and #0x01,    r11 ");   			// detect if its a byte write - 1 cycle
    8772:	1b f3       	and	#1,	r11	;r3 As==01

00008774 <.Loc.623.1>:
		asm ("bis  r11,     r14 ");   			// detect if its a byte write - 1 cycle
    8774:	0e db       	bis	r11,	r14	;

00008776 <.Loc.626.1>:


		asm ("mov.b @r14, @r13 ");    			// 5 cycles
    8776:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

0000877a <.Loc.628.1>:

		asm ("and #0xFFFE, r14");    			// 2 cycles
    877a:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

0000877e <.Loc.629.1>:
		asm ("incd r14");    					// 1 cycle
    877e:	2e 53       	incd	r14		;

00008780 <.Loc.630.1>:
		asm ("dec r15");    					// 1 cycles
    8780:	1f 83       	dec	r15		;

00008782 <.Loc.631.1>:
		asm ("tst r15");    					// 1 cycles
    8782:	0f 93       	cmp	#0,	r15	;r3 As==00

00008784 <.Loc.632.1>:
		asm ("jnz  _second_phase_commit_strt");	// 2 cycles
    8784:	e4 23       	jnz	$-54     	;abs 0x874e

00008786 <_stack_write_back>:
		//   COPY BACK THE 2BLE BUFFER					       				       	       							   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("_stack_write_back:");


		asm ("cmp #0x0000,  &0x6BFE");				 // 4 cycles
    8786:	82 93 fe 6b 	cmp	#0,	&0x6bfe	;r3 As==00

0000878a <.Loc.641.1>:
		asm ("jeq _chkpt_finished");				 // 2 cycles
    878a:	12 24       	jz	$+38     	;abs 0x87b0

0000878c <.Loc.643.1>:

		asm ("mov &0x6BFE,  r13 ");		 			 // 2 cycles - get the upper limit		
    878c:	1d 42 fe 6b 	mov	&0x6bfe,r13	;0x6bfe

00008790 <.Loc.644.1>:
		asm ("mov &0x6BFC,  r12 ");					 // 2 cycles - get the down limit 
    8790:	1c 42 fc 6b 	mov	&0x6bfc,r12	;0x6bfc

00008794 <.Loc.646.1>:

		asm ("mov r13,  r14 ");		     			 // 1 cycle 
    8794:	0e 4d       	mov	r13,	r14	;

00008796 <.Loc.647.1>:
		asm ("sub #0x1000,  r14 ");		 			 // 2 cycles - get the down limit 
    8796:	3e 80 00 10 	sub	#4096,	r14	;#0x1000

0000879a <.Loc.648.1>:
		asm ("mov #0x6BFA,  r10 ");		 			 // 2 cycles
    879a:	3a 40 fa 6b 	mov	#27642,	r10	;#0x6bfa

0000879e <_second_phase_stack_cpy>:

		asm ("_second_phase_stack_cpy:");
		asm ("mov @r10,@r14");			     		 // 5 cycles
    879e:	ae 4a 00 00 	mov	@r10,	0(r14)	;

000087a2 <.Loc.653.1>:
	
		asm ("cmp r13, r12");						 // 1 cycle
    87a2:	0c 9d       	cmp	r13,	r12	;

000087a4 <.Loc.654.1>:
   		asm ("jeq _chkpt_finished");	 	 		 // 2 cycles
    87a4:	05 24       	jz	$+12     	;abs 0x87b0

000087a6 <.Loc.655.1>:
		asm ("decd r10");							 // 1 cycle
    87a6:	2a 83       	decd	r10		;

000087a8 <.Loc.656.1>:
		asm ("decd r13");	   				 		 // 1 cycle
    87a8:	2d 83       	decd	r13		;

000087aa <.Loc.657.1>:
	  	asm ("decd r14");	   						 // 1 cycle
    87aa:	2e 83       	decd	r14		;

000087ac <.Loc.658.1>:
		asm ("br # _second_phase_stack_cpy");	 	 // 2 cycles
    87ac:	30 40 9e 87 	br	#0x879e		;

000087b0 <_chkpt_finished>:
	//	  25 CYCLES											       												   //
	//-------------------------------------------------------------------------------------------------------------//
		asm ("_chkpt_finished:");

	    /* Set second phase complete Bit - Atomic Flag*/
		asm ("cmp.b #0x02,&0x6075");			//4 cycles
    87b0:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

000087b4 <.Loc.668.1>:
		asm ("jeq  __pre_finish_2nd_buffer "); 	//2 cycles
    87b4:	1a 24       	jz	$+54     	;abs 0x87ea

000087b6 <.Loc.670.1>:

		asm ("mov #0x0103, &0x6074 "); 			//5 cycles	/* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 1ST CHECKPOINT COMPLETELY  */
    87b6:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    87ba:	74 60 

000087bc <.Loc.676.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 		           //
	//													       													   //
	//-------------------------------------------------------------------------------------------------------------//
		asm ("mov &0x6022,r10"); 		//3 cycles
    87bc:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

000087c0 <.Loc.677.1>:
		asm ("mov &0x6024,r11"); 		//3 cycles
    87c0:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

000087c4 <.Loc.678.1>:
		asm ("mov &0x6026,r12"); 		//3 cycles
    87c4:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

000087c8 <.Loc.679.1>:
		asm ("mov &0x6028,r13"); 	    //3 cycles
    87c8:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

000087cc <.Loc.680.1>:
		asm ("mov &0x602A,r14"); 	    //3 cycles
    87cc:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

000087d0 <.Loc.681.1>:
		asm ("mov &0x602C,r15"); 	    //3 cycles
    87d0:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

000087d4 <.Loc.682.1>:
		asm ("mov &0x6076,&0x02B2"); 	//3 cycles
    87d4:	92 42 76 60 	mov	&0x6076,&0x02b2	;0x6076
    87d8:	b2 02 

000087da <.Loc.683.1>:
		asm ("mov &0x6076,&0x02B4"); 	//3 cycles
    87da:	92 42 76 60 	mov	&0x6076,&0x02b4	;0x6076
    87de:	b4 02 

000087e0 <.Loc.684.1>:
		asm ("mov &0x6076,&0x02B6"); 	//3 cycles
    87e0:	92 42 76 60 	mov	&0x6076,&0x02b6	;0x6076
    87e4:	b6 02 

000087e6 <.Loc.685.1>:
		asm ("br #_finish"); 	   		//3 cycles
    87e6:	30 40 1a 88 	br	#0x881a		;

000087ea <__pre_finish_2nd_buffer>:
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 		           //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("__pre_finish_2nd_buffer:");

		asm ("mov #0x0301, &0x6074 "); 	//4 cycles /* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 2ND CHECKPOINT COMPLETELY  */
    87ea:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    87ee:	74 60 

000087f0 <.Loc.694.1>:

		asm ("mov &0x6052,r10"); 	    //3 cycles		
    87f0:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

000087f4 <.Loc.695.1>:
		asm ("mov &0x6054,r11"); 	    //3 cycles
    87f4:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

000087f8 <.Loc.696.1>:
		asm ("mov &0x6056,r12"); 	    //3 cycles
    87f8:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

000087fc <.Loc.697.1>:
		asm ("mov &0x6058,r13"); 	    //3 cycles
    87fc:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

00008800 <.Loc.698.1>:
		asm ("mov &0x605A,r14"); 	    //3 cycles
    8800:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

00008804 <.Loc.699.1>:
		asm ("mov &0x605C,r15"); 	    //3 cycles
    8804:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

00008808 <.Loc.700.1>:
		asm ("mov &0x6078,&0x02B2"); 	//3 cycles
    8808:	92 42 78 60 	mov	&0x6078,&0x02b2	;0x6078
    880c:	b2 02 

0000880e <.Loc.701.1>:
		asm ("mov &0x6078,&0x02B4"); 	//3 cycles
    880e:	92 42 78 60 	mov	&0x6078,&0x02b4	;0x6078
    8812:	b4 02 

00008814 <.Loc.702.1>:
		asm ("mov &0x6078,&0x02B6"); 	//3 cycles
    8814:	92 42 78 60 	mov	&0x6078,&0x02b6	;0x6078
    8818:	b6 02 

0000881a <_finish>:
		asm ("_finish:");

		/* Clear the counters*/
		asm ("mov #0x0000, &0x6000");	//4 cycles
    881a:	82 43 00 60 	mov	#0,	&0x6000	;r3 As==00

0000881e <.Loc.707.1>:
		asm ("mov #0x0000, &0x6002");	//4 cycles
    881e:	82 43 02 60 	mov	#0,	&0x6002	;r3 As==00

00008822 <.Loc.708.1>:
		asm ("mov #0x0000, &0x6004");	//4 cycles
    8822:	82 43 04 60 	mov	#0,	&0x6004	;r3 As==00

00008826 <.Loc.709.1>:
		asm ("mov #0x0000, &0x6006");	//4 cycles
    8826:	82 43 06 60 	mov	#0,	&0x6006	;r3 As==00

0000882a <.Loc.710.1>:
		asm ("mov #0x0000, &0x6008");	//4 cycles
    882a:	82 43 08 60 	mov	#0,	&0x6008	;r3 As==00

0000882e <.Loc.711.1>:
		asm ("mov #0x0000, &0x600A");	//4 cycles
    882e:	82 43 0a 60 	mov	#0,	&0x600a	;r3 As==00

00008832 <.Loc.712.1>:
		asm ("mov #0x0000, &0x600C");	//4 cycles
    8832:	82 43 0c 60 	mov	#0,	&0x600c	;r3 As==00

00008836 <.Loc.713.1>:
		asm ("mov #0x0000, &0x600E");	//4 cycles
    8836:	82 43 0e 60 	mov	#0,	&0x600e	;r3 As==00

0000883a <.Loc.715.1>:

		asm ("mov #0x0000, &0x02A2");	//4 cycles
    883a:	82 43 a2 02 	mov	#0,	&0x02a2	;r3 As==00

0000883e <.Loc.716.1>:
		asm ("mov #0x0000, &0x02A4");	//4 cycles
    883e:	82 43 a4 02 	mov	#0,	&0x02a4	;r3 As==00

00008842 <.Loc.717.1>:
		asm ("mov #0x0000, &0x02A6");	//4 cycles
    8842:	82 43 a6 02 	mov	#0,	&0x02a6	;r3 As==00

00008846 <.Loc.718.1>:
		asm ("mov #0x0000, &0x02A8");	//4 cycles
    8846:	82 43 a8 02 	mov	#0,	&0x02a8	;r3 As==00

0000884a <.Loc.719.1>:
		asm ("mov #0x0000, &0x02AA");	//4 cycles
    884a:	82 43 aa 02 	mov	#0,	&0x02aa	;r3 As==00

0000884e <.Loc.720.1>:
		asm ("mov #0x0000, &0x02AC");	//4 cycles
    884e:	82 43 ac 02 	mov	#0,	&0x02ac	;r3 As==00

00008852 <.Loc.721.1>:
		asm ("mov #0x0000, &0x02AE");	//4 cycles
    8852:	82 43 ae 02 	mov	#0,	&0x02ae	;r3 As==00

00008856 <.Loc.722.1>:
		asm ("mov #0x0000, &0x02B0");	//4 cycles
    8856:	82 43 b0 02 	mov	#0,	&0x02b0	;r3 As==00

0000885a <.Loc.724.1>:

		asm ("add #0x01, &0x607A");	//4 cycles
    885a:	92 53 7a 60 	inc	&0x607a		;

0000885e <.Loc.728.1>:

		/* and re-enable Idempotency tracking */

		asm ("mov #0xFF, &0x0090 ");	
    885e:	b2 40 ff 00 	mov	#255,	&0x0090	;#0x00ff
    8862:	90 00 

00008864 <.Loc.730.1>:

		asm ("mov #0x0001, &0x02A0");	// 4 cycles
    8864:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008868 <.Loc.732.1>:

}
    8868:	03 43       	nop			
    886a:	00 13       	reti			

0000886c <ta_wait_no_lpm>:
//    TA_WAIT_NO_LPM                                 //
// ( the function implements a wait by continously ) //
// ( polling the TAR register                      ) //
//                                                   //
//---------------------------------------------------//
void ta_wait_no_lpm(unsigned int time_cnt) {
    886c:	21 83       	decd	r1		;

0000886e <.LCFI0>:
    886e:	81 4c 00 00 	mov	r12,	0(r1)	;

00008872 <.Loc.14.1>:

  // Start and re-initialize TimerA
  TACTL = TASSEL0 | TACLR | MC_2;
    8872:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    8876:	bc 40 24 01 	mov	#292,	0(r12)	;#0x0124
    887a:	00 00 

0000887c <.Loc.17.1>:

  // Wait until time is over
  while(TAR < time_cnt);
    887c:	03 43       	nop			

0000887e <.L2>:
    887e:	3c 40 70 01 	mov	#368,	r12	;#0x0170
    8882:	2c 4c       	mov	@r12,	r12	;
    8884:	2c 91       	cmp	@r1,	r12	;
    8886:	fb 2b       	jnc	$-8      	;abs 0x887e

00008888 <.Loc.19.1>:

}
    8888:	03 43       	nop			
    888a:	21 53       	incd	r1		;
    888c:	30 41       	ret			

0000888e <ta_wait>:
// ( the timerA IRQ will exit the LPM0 state    )   //
//                                                  //
//--------------------------------------------------//
unsigned int periodic_val;

void ta_wait(unsigned int time_cnt) {
    888e:	21 83       	decd	r1		;

00008890 <.LCFI1>:
    8890:	81 4c 00 00 	mov	r12,	0(r1)	;

00008894 <.Loc.32.1>:

  // Set time limit for IRQ generation
  TACCR0 = time_cnt;
    8894:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    8898:	ac 41 00 00 	mov	@r1,	0(r12)	;

0000889c <.Loc.33.1>:
  periodic_val = time_cnt;
    889c:	a2 41 16 42 	mov	@r1,	&0x4216	;

000088a0 <.Loc.35.1>:
  // Start and re-initialize TimerA
  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    88a0:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    88a4:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    88a8:	00 00 

000088aa <.Loc.40.1>:

  // Go to Low-Power-Mode 0
  //LPM0;

}
    88aa:	03 43       	nop			
    88ac:	21 53       	incd	r1		;
    88ae:	30 41       	ret			

000088b0 <INT_timerA1>:

//--------------------------------------------------//
//    TIMER A INTERRUPT                             //
//--------------------------------------------------//
wakeup interrupt (TIMERA1_VECTOR) INT_timerA1(void) {
    88b0:	0d 12       	push	r13		;

000088b2 <.LCFI2>:
    88b2:	0c 12       	push	r12		;

000088b4 <.LCFI3>:


  //Force Reset
	 // WDTCTL = 0;
	  TACTL = TAIFG;
    88b4:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    88b8:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

000088bc <.Loc.53.1>:
	  //LED_CTRL ^= 0x0F;
	  // Set time limit for IRQ generation
	  TACCR0 = periodic_val;
    88bc:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    88c0:	1d 42 16 42 	mov	&0x4216,r13	;0x4216
    88c4:	8c 4d 00 00 	mov	r13,	0(r12)	;

000088c8 <.Loc.56.1>:

	  // Start and re-initialize TimerA
	  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    88c8:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    88cc:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    88d0:	00 00 

000088d2 <.Loc.58.1>:

	 QWARK_CHECKPOINT();
    88d2:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    88d6:	2d 4c       	mov	@r12,	r13	;
    88d8:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    88dc:	3d d0 20 00 	bis	#32,	r13	;#0x0020
    88e0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000088e4 <.Loc.61.1>:


}
    88e4:	03 43       	nop			
    88e6:	b1 c0 f0 00 	bic	#240,	4(r1)	;#0x00f0
    88ea:	04 00 
    88ec:	3c 41       	pop	r12		;
    88ee:	3d 41       	pop	r13		;
    88f0:	00 13       	reti			

000088f2 <__mspabi_func_epilog_7>:
    88f2:	34 41       	pop	r4		;

000088f4 <__mspabi_func_epilog_6>:
    88f4:	35 41       	pop	r5		;

000088f6 <__mspabi_func_epilog_5>:
    88f6:	36 41       	pop	r6		;

000088f8 <__mspabi_func_epilog_4>:
    88f8:	37 41       	pop	r7		;

000088fa <__mspabi_func_epilog_3>:
    88fa:	38 41       	pop	r8		;

000088fc <__mspabi_func_epilog_2>:
    88fc:	39 41       	pop	r9		;

000088fe <__mspabi_func_epilog_1>:
    88fe:	3a 41       	pop	r10		;
    8900:	30 41       	ret			

00008902 <__mspabi_slli_15>:
    8902:	0c 5c       	rla	r12		;

00008904 <__mspabi_slli_14>:
    8904:	0c 5c       	rla	r12		;

00008906 <__mspabi_slli_13>:
    8906:	0c 5c       	rla	r12		;

00008908 <__mspabi_slli_12>:
    8908:	0c 5c       	rla	r12		;

0000890a <__mspabi_slli_11>:
    890a:	0c 5c       	rla	r12		;

0000890c <__mspabi_slli_10>:
    890c:	0c 5c       	rla	r12		;

0000890e <__mspabi_slli_9>:
    890e:	0c 5c       	rla	r12		;

00008910 <__mspabi_slli_8>:
    8910:	0c 5c       	rla	r12		;

00008912 <__mspabi_slli_7>:
    8912:	0c 5c       	rla	r12		;

00008914 <__mspabi_slli_6>:
    8914:	0c 5c       	rla	r12		;

00008916 <__mspabi_slli_5>:
    8916:	0c 5c       	rla	r12		;

00008918 <__mspabi_slli_4>:
    8918:	0c 5c       	rla	r12		;

0000891a <__mspabi_slli_3>:
    891a:	0c 5c       	rla	r12		;

0000891c <__mspabi_slli_2>:
    891c:	0c 5c       	rla	r12		;

0000891e <__mspabi_slli_1>:
    891e:	0c 5c       	rla	r12		;
    8920:	30 41       	ret			

00008922 <.L11>:
    8922:	3d 53       	add	#-1,	r13	;r3 As==11
    8924:	0c 5c       	rla	r12		;

00008926 <__mspabi_slli>:
    8926:	0d 93       	cmp	#0,	r13	;r3 As==00
    8928:	fc 23       	jnz	$-6      	;abs 0x8922
    892a:	30 41       	ret			

0000892c <__mspabi_slll_15>:
    892c:	0c 5c       	rla	r12		;
    892e:	0d 6d       	rlc	r13		;

00008930 <__mspabi_slll_14>:
    8930:	0c 5c       	rla	r12		;
    8932:	0d 6d       	rlc	r13		;

00008934 <__mspabi_slll_13>:
    8934:	0c 5c       	rla	r12		;
    8936:	0d 6d       	rlc	r13		;

00008938 <__mspabi_slll_12>:
    8938:	0c 5c       	rla	r12		;
    893a:	0d 6d       	rlc	r13		;

0000893c <__mspabi_slll_11>:
    893c:	0c 5c       	rla	r12		;
    893e:	0d 6d       	rlc	r13		;

00008940 <__mspabi_slll_10>:
    8940:	0c 5c       	rla	r12		;
    8942:	0d 6d       	rlc	r13		;

00008944 <__mspabi_slll_9>:
    8944:	0c 5c       	rla	r12		;
    8946:	0d 6d       	rlc	r13		;

00008948 <__mspabi_slll_8>:
    8948:	0c 5c       	rla	r12		;
    894a:	0d 6d       	rlc	r13		;

0000894c <__mspabi_slll_7>:
    894c:	0c 5c       	rla	r12		;
    894e:	0d 6d       	rlc	r13		;

00008950 <__mspabi_slll_6>:
    8950:	0c 5c       	rla	r12		;
    8952:	0d 6d       	rlc	r13		;

00008954 <__mspabi_slll_5>:
    8954:	0c 5c       	rla	r12		;
    8956:	0d 6d       	rlc	r13		;

00008958 <__mspabi_slll_4>:
    8958:	0c 5c       	rla	r12		;
    895a:	0d 6d       	rlc	r13		;

0000895c <__mspabi_slll_3>:
    895c:	0c 5c       	rla	r12		;
    895e:	0d 6d       	rlc	r13		;

00008960 <__mspabi_slll_2>:
    8960:	0c 5c       	rla	r12		;
    8962:	0d 6d       	rlc	r13		;

00008964 <__mspabi_slll_1>:
    8964:	0c 5c       	rla	r12		;
    8966:	0d 6d       	rlc	r13		;
    8968:	30 41       	ret			

0000896a <.L12>:
    896a:	3e 53       	add	#-1,	r14	;r3 As==11
    896c:	0c 5c       	rla	r12		;
    896e:	0d 6d       	rlc	r13		;

00008970 <__mspabi_slll>:
    8970:	0e 93       	cmp	#0,	r14	;r3 As==00
    8972:	fb 23       	jnz	$-8      	;abs 0x896a
    8974:	30 41       	ret			

00008976 <__mspabi_srli_15>:
    8976:	12 c3       	clrc			
    8978:	0c 10       	rrc	r12		;

0000897a <__mspabi_srli_14>:
    897a:	12 c3       	clrc			
    897c:	0c 10       	rrc	r12		;

0000897e <__mspabi_srli_13>:
    897e:	12 c3       	clrc			
    8980:	0c 10       	rrc	r12		;

00008982 <__mspabi_srli_12>:
    8982:	12 c3       	clrc			
    8984:	0c 10       	rrc	r12		;

00008986 <__mspabi_srli_11>:
    8986:	12 c3       	clrc			
    8988:	0c 10       	rrc	r12		;

0000898a <__mspabi_srli_10>:
    898a:	12 c3       	clrc			
    898c:	0c 10       	rrc	r12		;

0000898e <__mspabi_srli_9>:
    898e:	12 c3       	clrc			
    8990:	0c 10       	rrc	r12		;

00008992 <__mspabi_srli_8>:
    8992:	12 c3       	clrc			
    8994:	0c 10       	rrc	r12		;

00008996 <__mspabi_srli_7>:
    8996:	12 c3       	clrc			
    8998:	0c 10       	rrc	r12		;

0000899a <__mspabi_srli_6>:
    899a:	12 c3       	clrc			
    899c:	0c 10       	rrc	r12		;

0000899e <__mspabi_srli_5>:
    899e:	12 c3       	clrc			
    89a0:	0c 10       	rrc	r12		;

000089a2 <__mspabi_srli_4>:
    89a2:	12 c3       	clrc			
    89a4:	0c 10       	rrc	r12		;

000089a6 <__mspabi_srli_3>:
    89a6:	12 c3       	clrc			
    89a8:	0c 10       	rrc	r12		;

000089aa <__mspabi_srli_2>:
    89aa:	12 c3       	clrc			
    89ac:	0c 10       	rrc	r12		;

000089ae <__mspabi_srli_1>:
    89ae:	12 c3       	clrc			
    89b0:	0c 10       	rrc	r12		;
    89b2:	30 41       	ret			

000089b4 <.L11>:
    89b4:	3d 53       	add	#-1,	r13	;r3 As==11
    89b6:	12 c3       	clrc			
    89b8:	0c 10       	rrc	r12		;

000089ba <__mspabi_srli>:
    89ba:	0d 93       	cmp	#0,	r13	;r3 As==00
    89bc:	fb 23       	jnz	$-8      	;abs 0x89b4
    89be:	30 41       	ret			

000089c0 <__mspabi_srll_15>:
    89c0:	12 c3       	clrc			
    89c2:	0d 10       	rrc	r13		;
    89c4:	0c 10       	rrc	r12		;

000089c6 <__mspabi_srll_14>:
    89c6:	12 c3       	clrc			
    89c8:	0d 10       	rrc	r13		;
    89ca:	0c 10       	rrc	r12		;

000089cc <__mspabi_srll_13>:
    89cc:	12 c3       	clrc			
    89ce:	0d 10       	rrc	r13		;
    89d0:	0c 10       	rrc	r12		;

000089d2 <__mspabi_srll_12>:
    89d2:	12 c3       	clrc			
    89d4:	0d 10       	rrc	r13		;
    89d6:	0c 10       	rrc	r12		;

000089d8 <__mspabi_srll_11>:
    89d8:	12 c3       	clrc			
    89da:	0d 10       	rrc	r13		;
    89dc:	0c 10       	rrc	r12		;

000089de <__mspabi_srll_10>:
    89de:	12 c3       	clrc			
    89e0:	0d 10       	rrc	r13		;
    89e2:	0c 10       	rrc	r12		;

000089e4 <__mspabi_srll_9>:
    89e4:	12 c3       	clrc			
    89e6:	0d 10       	rrc	r13		;
    89e8:	0c 10       	rrc	r12		;

000089ea <__mspabi_srll_8>:
    89ea:	12 c3       	clrc			
    89ec:	0d 10       	rrc	r13		;
    89ee:	0c 10       	rrc	r12		;

000089f0 <__mspabi_srll_7>:
    89f0:	12 c3       	clrc			
    89f2:	0d 10       	rrc	r13		;
    89f4:	0c 10       	rrc	r12		;

000089f6 <__mspabi_srll_6>:
    89f6:	12 c3       	clrc			
    89f8:	0d 10       	rrc	r13		;
    89fa:	0c 10       	rrc	r12		;

000089fc <__mspabi_srll_5>:
    89fc:	12 c3       	clrc			
    89fe:	0d 10       	rrc	r13		;
    8a00:	0c 10       	rrc	r12		;

00008a02 <__mspabi_srll_4>:
    8a02:	12 c3       	clrc			
    8a04:	0d 10       	rrc	r13		;
    8a06:	0c 10       	rrc	r12		;

00008a08 <__mspabi_srll_3>:
    8a08:	12 c3       	clrc			
    8a0a:	0d 10       	rrc	r13		;
    8a0c:	0c 10       	rrc	r12		;

00008a0e <__mspabi_srll_2>:
    8a0e:	12 c3       	clrc			
    8a10:	0d 10       	rrc	r13		;
    8a12:	0c 10       	rrc	r12		;

00008a14 <__mspabi_srll_1>:
    8a14:	12 c3       	clrc			
    8a16:	0d 10       	rrc	r13		;
    8a18:	0c 10       	rrc	r12		;
    8a1a:	30 41       	ret			

00008a1c <.L12>:
    8a1c:	3e 53       	add	#-1,	r14	;r3 As==11
    8a1e:	12 c3       	clrc			
    8a20:	0d 10       	rrc	r13		;
    8a22:	0c 10       	rrc	r12		;

00008a24 <__mspabi_srll>:
    8a24:	0e 93       	cmp	#0,	r14	;r3 As==00
    8a26:	fa 23       	jnz	$-10     	;abs 0x8a1c
    8a28:	30 41       	ret			

00008a2a <strlen>:
    8a2a:	0d 4c       	mov	r12,	r13	;

00008a2c <.L2>:
    8a2c:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    8a30:	03 20       	jnz	$+8      	;abs 0x8a38

00008a32 <.Loc.88.1>:
    8a32:	0d 8c       	sub	r12,	r13	;

00008a34 <.LVL3>:
    8a34:	0c 4d       	mov	r13,	r12	;

00008a36 <.LVL4>:
    8a36:	30 41       	ret			

00008a38 <.L3>:
    8a38:	1d 53       	inc	r13		;
    8a3a:	30 40 2c 8a 	br	#0x8a2c		;

00008a3e <memmove>:
    8a3e:	0d 9c       	cmp	r12,	r13	;
    8a40:	0a 28       	jnc	$+22     	;abs 0x8a56

00008a42 <.L5>:
    8a42:	0f 4c       	mov	r12,	r15	;
    8a44:	0e 5c       	add	r12,	r14	;

00008a46 <.L3>:
    8a46:	0e 9f       	cmp	r15,	r14	;
    8a48:	0d 24       	jz	$+28     	;abs 0x8a64

00008a4a <.LVL3>:
    8a4a:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    8a4e:	1f 53       	inc	r15		;

00008a50 <.LVL4>:
    8a50:	1d 53       	inc	r13		;
    8a52:	30 40 46 8a 	br	#0x8a46		;

00008a56 <.L2>:
    8a56:	0f 4d       	mov	r13,	r15	;
    8a58:	0f 5e       	add	r14,	r15	;
    8a5a:	0c 9f       	cmp	r15,	r12	;
    8a5c:	f2 2f       	jc	$-26     	;abs 0x8a42

00008a5e <.L4>:
    8a5e:	3e 53       	add	#-1,	r14	;r3 As==11

00008a60 <.LVL7>:
    8a60:	3e 93       	cmp	#-1,	r14	;r3 As==11
    8a62:	01 20       	jnz	$+4      	;abs 0x8a66

00008a64 <.L10>:
    8a64:	30 41       	ret			

00008a66 <.L6>:
    8a66:	0b 4c       	mov	r12,	r11	;
    8a68:	0b 5e       	add	r14,	r11	;
    8a6a:	0f 4d       	mov	r13,	r15	;
    8a6c:	0f 5e       	add	r14,	r15	;
    8a6e:	eb 4f 00 00 	mov.b	@r15,	0(r11)	;
    8a72:	30 40 5e 8a 	br	#0x8a5e		;

00008a76 <memset>:
    8a76:	0f 4c       	mov	r12,	r15	;
    8a78:	0e 5c       	add	r12,	r14	;

00008a7a <.L2>:
    8a7a:	0f 9e       	cmp	r14,	r15	;
    8a7c:	01 20       	jnz	$+4      	;abs 0x8a80

00008a7e <.Loc.104.1>:
    8a7e:	30 41       	ret			

00008a80 <.L3>:
    8a80:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    8a84:	1f 53       	inc	r15		;

00008a86 <.LVL4>:
    8a86:	30 40 7a 8a 	br	#0x8a7a		;

00008a8a <__do_global_ctors_aux>:
    8a8a:	0a 12       	push	r10		;
    8a8c:	3a 40 08 80 	mov	#32776,	r10	;#0x8008

00008a90 <.L2>:
    8a90:	2c 4a       	mov	@r10,	r12	;
    8a92:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8a94:	02 20       	jnz	$+6      	;abs 0x8a9a
    8a96:	3a 41       	pop	r10		;
    8a98:	30 41       	ret			

00008a9a <.L3>:
    8a9a:	8c 12       	call	r12		;
    8a9c:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    8aa0:	30 40 90 8a 	br	#0x8a90		;

00008aa4 <__msp430_init>:
    8aa4:	b0 12 dc 82 	call	#33500		;#0x82dc
    8aa8:	b0 12 8a 8a 	call	#35466		;#0x8a8a

00008aac <L0>:
    8aac:	b0 12 18 82 	call	#33304		;#0x8218

00008ab0 <.Loc.19.1>:
    8ab0:	b0 12 0a 82 	call	#33290		;#0x820a

00008ab4 <.Loc.20.1>:
    8ab4:	30 41       	ret			

00008ab6 <__msp430_fini>:
    8ab6:	b0 12 26 82 	call	#33318		;#0x8226

00008aba <L0>:
    8aba:	b0 12 8e 82 	call	#33422		;#0x828e

00008abe <L0>:
    8abe:	30 41       	ret			

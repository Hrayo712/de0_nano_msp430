
leds.elf:     file format elf32-msp430

SYMBOL TABLE:
0000ffe8 l    d  __interrupt_vector_5	00000000 __interrupt_vector_5
0000fff0 l    d  __interrupt_vector_9	00000000 __interrupt_vector_9
0000fffe l    d  __reset_vector	00000000 __reset_vector
00008000 l    d  .rodata	00000000 .rodata
0000802c l    d  .text	00000000 .text
00004000 l    d  .data	00000000 .data
0000410e l    d  .bss	00000000 .bss
00004122 l    d  .noinit	00000000 .noinit
00000000 l    d  .MP430.attributes	00000000 .MP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 qwark.c
00008068 l       .text	00000000 __qwark_retry_1st_setup
0000805c l       .text	00000000 __qwark_restore_2nd_setup
0000807c l       .text	00000000 __qwark_retry_2nd_setup
00008050 l       .text	00000000 __qwark_restore_1st_setup
000080dc l       .text	00000000 __system_restore
0000808c l       .text	00000000 __second_stage_retry
00008094 l       .text	00000000 _retry_second_phase_commit_strt
000080b0 l       .text	00000000 _retry_byte_copy
000080c6 l       .text	00000000 __retry_complete
000080d6 l       .text	00000000 __set_flag_complete
0000813e l       .text	00000000 __Second_buffer_restore_stack
000080fe l       .text	00000000 __First_buffer_restore_stack
00008a12 l       .text	00000000 __second_buffer_init
00008a16 l       .text	00000000 __first_phase_commit
00008ab4 l       .text	00000000 __second_phase_start
00008aa8 l       .text	00000000 _scratchpad_addr_cpy
00008ac2 l       .text	00000000 __set_flag_2nd
00008ac6 l       .text	00000000 _second_phase_commit
00008b10 l       .text	00000000 _chkpt_finished
00008adc l       .text	00000000 _second_phase_commit_strt
00008afa l       .text	00000000 _byte_copy
00008aee l       .text	00000000 _pre_end_copy
00008b38 l       .text	00000000 __pre_finish_2nd_buffer
00008b56 l       .text	00000000 _finish
00000000 l    df *ABS*	00000000 timerA.c
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
000081d8 l       .text	00000000 _msp430_run_array
000081e6 l       .text	00000000 _msp430_run_done
00000000 l    df *ABS*	00000000 main.c
0000864c l     F .text	0000004a bit_shifter
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtbegin.o
00008024 l     O .rodata	00000000 __CTOR_LIST__
00008028 l     O .rodata	00000000 __DTOR_LIST__
0000801c l     O .rodata	00000000 __EH_FRAME_BEGIN__
00008f06 l     O .text	00000000 __TMC_LIST__
000081e8 l     F .text	00000000 deregister_tm_clones
00008202 l     F .text	00000000 register_tm_clones
00008230 l     F .text	00000000 __do_global_dtors_aux
0000410e l     O .bss	00000000 completed.3056
00004110 l     O .bss	00000000 dtor_idx.3058
0000827e l     F .text	00000000 frame_dummy
00004112 l     O .bss	00000000 object.3071
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtend.o
00008026 l     O .rodata	00000000 __CTOR_END__
0000801c l     O .rodata	00000000 __FRAME_END__
00008ed0 l     F .text	00000000 __do_global_ctors_aux
00000000 l    df *ABS*	00000000 crt_bss.o
00000000 l    df *ABS*	00000000 crt_movedata.o
00000000 l    df *ABS*	00000000 crt_main.o
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 lib2divHI.o
00000000 l    df *ABS*	00000000 srli.o
00000000 l    df *ABS*	00000000 lib_a-memmove.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crtn.o
00000000 l    df *ABS*	00000000 
0000802c l       .text	00000000 _start
00008de8 g       .text	00000000 .hidden __mspabi_srli_9
00008e38 g       .text	00000000 .hidden __mspabi_srll_10
00008de4 g       .text	00000000 .hidden __mspabi_srli_10
0000848e g     F .text	000000be ntbl_bitcount
00008dd0 g       .text	00000000 .hidden __mspabi_srli_15
00008e84 g     F .text	00000038 memmove
00008dfc g       .text	00000000 .hidden __mspabi_srli_4
00008d02 g     F .text	00000040 .hidden udivmodhi4
00008df0 g       .text	00000000 .hidden __mspabi_srli_7
00008e4a g       .text	00000000 .hidden __mspabi_srll_7
00008e62 g       .text	00000000 .hidden __mspabi_srll_3
00008dc2 g       .text	00000000 .hidden __mspabi_func_epilog_6
00008f06 g     O .text	00000000 .hidden __TMC_END__
00008e26 g       .text	00000000 .hidden __mspabi_srll_13
0000802a g     O .rodata	00000000 .hidden __DTOR_END__
00008020 g       .rodata	00000000 __fini_array_end
00008ddc g       .text	00000000 .hidden __mspabi_srli_12
0000802c g     F .text	00000004 __crt0_start
00008180 g     F .text	0000000e __crt0_init_bss
0000400e g     O .data	00000100 bits
00000014 g       *ABS*	00000000 __bsssize
00008d8e g     F .text	00000032 .hidden __mspabi_remi
000081a2 g     F .text	0000000a __crt0_call_init_then_main
00008dcc g       .text	00000000 .hidden __mspabi_func_epilog_1
00008dc8 g       .text	00000000 .hidden __mspabi_func_epilog_3
00008e56 g       .text	00000000 .hidden __mspabi_srll_5
00008e14 g       .text	00000000 .hidden __mspabi_srli
0000400c g     O .data	00000002 n_6
00008e32 g       .text	00000000 .hidden __mspabi_srll_11
00008df8 g       .text	00000000 .hidden __mspabi_srli_5
0000854c g     F .text	00000044 BW_btbl_bitcount
00008c1c g     F .text	000000b2 UART_WriteNumber
00000000  w      *UND*	00000000 __deregister_frame_info
00004122 g       .noinit	00000000 end
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
00008e50 g       .text	00000000 .hidden __mspabi_srll_6
000081c8 g     F .text	00000000 _msp430_run_fini_array
00008bf8 g     F .text	00000024 UART_WriteChar
00008e08 g       .text	00000000 .hidden __mspabi_srli_1
00008e20 g       .text	00000000 .hidden __mspabi_srll_14
0000832a g     F .text	00000164 bitcount
00008030 g     F .text	00000150 qwark_restore
00008dd4 g       .text	00000000 .hidden __mspabi_srli_14
0000010e g       *ABS*	00000000 __romdatacopysize
0000400a g     O .data	00000002 n_5
00008696 g     F .text	0000002c init
00008de0 g       .text	00000000 .hidden __mspabi_srli_11
00004120 g     O .bss	00000002 periodic_val
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
00008020 g       .rodata	00000000 __fini_array_start
00008d42 g     F .text	0000004c .hidden __mspabi_divi
00000000  w      *ABS*	00000000 __rom_highdatacopysize
000085fe g     F .text	0000004e ntbl_bitcnt
00008eea g       .text	00000000 __msp430_init
00008ebc g     F .text	00000014 memset
000086c2 g     F .text	00000336 main
00004000 g     O .data	00000002 n_0
00008bc0 g     F .text	00000022 ta_wait
00008e5c g       .text	00000000 .hidden __mspabi_srll_4
00008020 g       .rodata	00000000 __init_array_end
00008e04 g       .text	00000000 .hidden __mspabi_srli_2
00000000  w      *ABS*	00000000 __high_bsssize
000082e6 g     F .text	00000044 bit_count
00000000  w      *ABS*	00000000 __rom_highdatastart
00008be2 g     F .text	00000016 INT_timerA1
00008f06 g       .text	00000000 __msp430_fini_end
00008e2c g       .text	00000000 .hidden __mspabi_srll_12
00008f06 g       *ABS*	00000000 __romdatastart
00008cce g     F .text	00000034 UART_WriteString
000081ac g     F .text	00000000 _msp430_run_init_array
00008b9e g     F .text	00000022 ta_wait_no_lpm
00008df4 g       .text	00000000 .hidden __mspabi_srli_6
00004002 g     O .data	00000002 n_1
00008020 g       .rodata	00000000 __preinit_array_end
00008e00 g       .text	00000000 .hidden __mspabi_srli_3
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
0000410e g       .bss	00000000 __bssstart
00008dc4 g       .text	00000000 .hidden __mspabi_func_epilog_5
00008296 g     F .text	00000050 btbl_bitcnt
00008000 g       .noinit	00000000 __stack
000089f8 g     F .text	000001a6 INT_Qwark
00008e3e g       .text	00000000 .hidden __mspabi_srll_9
0000410e g       .data	00000000 _edata
00008efc g       .text	00000000 __msp430_init_end
00008e7e g       .text	00000000 .hidden __mspabi_srll
00000000  w      *ABS*	00000000 __high_bssstart
00008e1a g       .text	00000000 .hidden __mspabi_srll_15
00004008 g     O .data	00000002 n_4
00004004 g     O .data	00000002 n_2
00008020 g       .rodata	00000000 __init_array_start
00008590 g     F .text	0000006e AR_btbl_bitcount
00004006 g     O .data	00000002 n_3
00008dd8 g       .text	00000000 .hidden __mspabi_srli_13
00004000 g       .data	00000000 __datastart
00008e44 g       .text	00000000 .hidden __mspabi_srll_8
00008e6e g       .text	00000000 .hidden __mspabi_srll_1
00008020 g       .rodata	00000000 __preinit_array_start
0000818e g     F .text	00000014 __crt0_movedata
00008dca g       .text	00000000 .hidden __mspabi_func_epilog_2
00000000  w      *UND*	00000000 __register_frame_info
000081ba g     F .text	00000000 _msp430_run_preinit_array
00008dc0 g       .text	00000000 .hidden __mspabi_func_epilog_7
00008dc6 g       .text	00000000 .hidden __mspabi_func_epilog_4
00008e68 g       .text	00000000 .hidden __mspabi_srll_2
00008efc g       .text	00000000 __msp430_fini
00008dec g       .text	00000000 .hidden __mspabi_srli_8



Disassembly of section __interrupt_vector_5:

0000ffe8 <__interrupt_vector_5>:
    ffe8:	f8 89       	interrupt service routine at 0x89f8

Disassembly of section __interrupt_vector_9:

0000fff0 <__interrupt_vector_9>:
    fff0:	e2 8b       	interrupt service routine at 0x8be2

Disassembly of section .text:

0000802c <__crt0_start>:
    802c:	31 40 00 80 	mov	#32768,	r1	;#0x8000

00008030 <qwark_restore>:
	//    RESTORE HANDLING LOGIC																  				   //
	//	  W.C 30 CYCLES																							   //
	//-------------------------------------------------------------------------------------------------------------//

	/* Disable Qwark */
	__asm__ __volatile__ ("mov #0x0000, &0x02A0");				// 4 cycles
    8030:	82 43 a0 02 	mov	#0,	&0x02a0	;r3 As==00

00008034 <.Loc.29.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");				// 2 cycles
    8034:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

00008038 <.Loc.30.1>:
	__asm__ __volatile__ ("jz __qwark_retry_1st_setup");			// 2 cycles
    8038:	17 24       	jz	$+48     	;abs 0x8068

0000803a <.Loc.32.1>:

	__asm__ __volatile__ ("cmp.b #0x03, &0x6075");				// 3 cycles
    803a:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    803e:	75 60 

00008040 <.Loc.33.1>:
	__asm__ __volatile__ ("jz __qwark_restore_2nd_setup");			// 2 cycles
    8040:	0d 24       	jz	$+28     	;abs 0x805c

00008042 <.Loc.34.1>:
	__asm__ __volatile__ ("cmp.b #0x03, &0x6074");				// 3 cycles
    8042:	f2 90 03 00 	cmp.b	#3,	&0x6074	;
    8046:	74 60 

00008048 <.Loc.35.1>:
	__asm__ __volatile__ ("jnz __crt0_init_bss");				// 2 cycles
    8048:	9b 20       	jnz	$+312    	;abs 0x8180

0000804a <.Loc.37.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6075");				// 2 cycles
    804a:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

0000804e <.Loc.38.1>:
	__asm__ __volatile__ ("jz  __qwark_retry_2nd_setup");			// 2 cycles
    804e:	16 24       	jz	$+46     	;abs 0x807c

00008050 <__qwark_restore_1st_setup>:

	__asm__ __volatile__ ("__qwark_restore_1st_setup:");

	__asm__ __volatile__ ("mov &0X6012,   r12 ");				// 3 cycles
    8050:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008054 <.Loc.43.1>:
    __asm__ __volatile__ ("mov #0x6FFE,   r13 ");				// 2 cycles
    8054:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

00008058 <.Loc.44.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    8058:	30 40 dc 80 	br	#0x80dc		;

0000805c <__qwark_restore_2nd_setup>:

	__asm__ __volatile__ ("__qwark_restore_2nd_setup:");

	__asm__ __volatile__ ("mov &0X6042, r12   ");				// 3 cycles
    805c:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008060 <.Loc.49.1>:
    __asm__ __volatile__ ("mov #0x6BFE, r13   ");				// 2 cycles
    8060:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

00008064 <.Loc.50.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    8064:	30 40 dc 80 	br	#0x80dc		;

00008068 <__qwark_retry_1st_setup>:

	__asm__ __volatile__ ("__qwark_retry_1st_setup:");

	__asm__ __volatile__ ("mov  #0x6030,   r10 ");				// 2 cycles
    8068:	3a 40 30 60 	mov	#24624,	r10	;#0x6030

0000806c <.Loc.55.1>:
	__asm__ __volatile__ ("mov  &0X6012,   r12 ");				// 3 cycles
    806c:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008070 <.Loc.56.1>:
    __asm__ __volatile__ ("mov  #0x6FFE,   r13 ");				// 2 cycles
    8070:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

00008074 <.Loc.57.1>:
	__asm__ __volatile__ ("mov  &0x602E,   r15 ");				// 3 cycles
    8074:	1f 42 2e 60 	mov	&0x602e,r15	;0x602e

00008078 <.Loc.58.1>:
	__asm__ __volatile__ ("br  #__second_stage_retry");			// 2 cycles
    8078:	30 40 8c 80 	br	#0x808c		;

0000807c <__qwark_retry_2nd_setup>:

	__asm__ __volatile__ ("__qwark_retry_2nd_setup:");

	__asm__ __volatile__ ("mov #0x6060,   r10 ");				// 2 cycles
    807c:	3a 40 60 60 	mov	#24672,	r10	;#0x6060

00008080 <.Loc.63.1>:
	__asm__ __volatile__ ("mov &0X6042,   r12 ");				// 3 cycles
    8080:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008084 <.Loc.64.1>:
    __asm__ __volatile__ ("mov #0x6BFE,   r13 ");				// 2 cycles
    8084:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

00008088 <.Loc.65.1>:
	__asm__ __volatile__ ("mov &0x605E,   r15 ");				// 3 cycles
    8088:	1f 42 5e 60 	mov	&0x605e,r15	;0x605e

0000808c <__second_stage_retry>:
	//-------------------------------------------------------------------------------------------------------------//
	//    RETRY SECOND PHASE OF THE COMMIT PROCESS	: 148 cycles												   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__second_stage_retry:");

	__asm__ __volatile__ ("tst r15 ");     		            // 1 cycles
    808c:	0f 93       	cmp	#0,	r15	;r3 As==00

0000808e <.Loc.73.1>:
	__asm__ __volatile__ ("jz  __system_restore");		    // 2 cycles
    808e:	26 24       	jz	$+78     	;abs 0x80dc

00008090 <.Loc.75.1>:

	__asm__ __volatile__ ("mov #0x6000,  r14");			    // 2 cycles
    8090:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008094 <_retry_second_phase_commit_strt>:

	__asm__ __volatile__ ("_retry_second_phase_commit_strt:");  // Worst case

	__asm__ __volatile__ ("mov @r10+2,  r9 ");   			// 2 cycles
    8094:	39 4a       	mov	@r10+,	r9	;

00008096 <.Loc.81.1>:

	__asm__ __volatile__ ("mov r9,  r11 ");   			    // 1 cycle
    8096:	0b 49       	mov	r9,	r11	;

00008098 <.Loc.83.1>:

	__asm__ __volatile__ ("and #0x8000,  r11 ");   			// 2 cycles
    8098:	3b f0 00 80 	and	#32768,	r11	;#0x8000

0000809c <.Loc.84.1>:
	__asm__ __volatile__ ("cmp #0x8000,  r11 ");   			// 2 cycles
    809c:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

000080a0 <.Loc.85.1>:
	__asm__ __volatile__ ("jeq _retry_byte_copy ");   		// 2 cycles
    80a0:	07 24       	jz	$+16     	;abs 0x80b0

000080a2 <.Loc.87.1>:

	__asm__ __volatile__ ("mov @r14+2, @r9 ");    			// 5 cycles
    80a2:	b9 4e 00 00 	mov	@r14+,	0(r9)	;

000080a6 <.Loc.89.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    80a6:	1f 83       	dec	r15		;

000080a8 <.Loc.90.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    80a8:	0f 93       	cmp	#0,	r15	;r3 As==00

000080aa <.Loc.92.1>:

	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80aa:	f4 23       	jnz	$-22     	;abs 0x8094

000080ac <.Loc.93.1>:
	__asm__ __volatile__ ("br #__retry_complete");		    // 2 cycle
    80ac:	30 40 c6 80 	br	#0x80c6		;

000080b0 <_retry_byte_copy>:

	__asm__ __volatile__ ("_retry_byte_copy: ");
	__asm__ __volatile__ ("and #0x7FFF,  r9  ");   			// mask the highest bit 2 cycles
    80b0:	39 f0 ff 7f 	and	#32767,	r9	;#0x7fff

000080b4 <.Loc.97.1>:
	__asm__ __volatile__ ("mov r9,      r11  ");   			// 1 cycle
    80b4:	0b 49       	mov	r9,	r11	;

000080b6 <.Loc.98.1>:
	__asm__ __volatile__ ("and #0x01,    r11 ");   			// detect if its a byte write - 2 cycles
    80b6:	1b f3       	and	#1,	r11	;r3 As==01

000080b8 <.Loc.99.1>:
	__asm__ __volatile__ ("bis  r11,     r14 ");   			// detect if its a byte write - 2 cycles
    80b8:	0e db       	bis	r11,	r14	;

000080ba <.Loc.101.1>:

	__asm__ __volatile__ ("mov.b @r14, @r9  ");    			// 5 cycles
    80ba:	e9 4e 00 00 	mov.b	@r14,	0(r9)	;

000080be <.Loc.102.1>:
	__asm__ __volatile__ ("incd r14 ");    					// 1 cycle
    80be:	2e 53       	incd	r14		;

000080c0 <.Loc.104.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    80c0:	1f 83       	dec	r15		;

000080c2 <.Loc.105.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    80c2:	0f 93       	cmp	#0,	r15	;r3 As==00

000080c4 <.Loc.106.1>:
	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80c4:	e7 23       	jnz	$-48     	;abs 0x8094

000080c6 <__retry_complete>:

	//-------------------------------------------------------------------------------------------------------------//
	//    END OF THE RETRY-SECOND PHASE	: Atomic Flag Set														   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");		// 4 cycles
    80c6:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

000080ca <.Loc.115.1>:
	__asm__ __volatile__ ("jz __set_flag_complete");	// 2 cycles
    80ca:	05 24       	jz	$+12     	;abs 0x80d6

000080cc <.Loc.117.1>:

	__asm__ __volatile__ ("mov #0x0301, &0x6074 ");		// 5 cycles
    80cc:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    80d0:	74 60 

000080d2 <.Loc.118.1>:
	__asm__ __volatile__ ("br #__system_restore:");		// 2 cycles
    80d2:	30 40 dc 80 	br	#0x80dc		;

000080d6 <__set_flag_complete>:

	__asm__ __volatile__ ("__set_flag_complete:");
	__asm__ __volatile__ ("mov #0x0103, &0x6074 ");		// 5 cycles
    80d6:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    80da:	74 60 

000080dc <__system_restore>:
	//	 12 CYCLES																								   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__system_restore:");

	/* Disable The Watchdog */
	__asm__ __volatile__ ("mov #288, r8");		// 2 cycles
    80dc:	38 40 20 01 	mov	#288,	r8	;#0x0120

000080e0 <.Loc.131.1>:
	__asm__ __volatile__ ("mov #23168, 0(r8)");	// 2 cycles
    80e0:	b8 40 80 5a 	mov	#23168,	0(r8)	;#0x5a80
    80e4:	00 00 

000080e6 <.Loc.134.1>:

	/* Enable and Configure the UART */
	__asm__ __volatile__ ("mov.b #130, r8");	// 2 cycles
    80e6:	78 40 82 00 	mov.b	#130,	r8	;#0x0082

000080ea <.Loc.135.1>:
	__asm__ __volatile__ ("mov   #8, 0(r8)");	// 2 cycles
    80ea:	b8 42 00 00 	mov	#8,	0(r8)	;r2 As==11

000080ee <.Loc.137.1>:

	__asm__ __volatile__ ("mov.b #128, r8");	// 2 cycles
    80ee:	78 40 80 00 	mov.b	#128,	r8	;#0x0080

000080f2 <.Loc.138.1>:
	__asm__ __volatile__ ("mov.b   #1, 0(r8)"); // 2 cycles
    80f2:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01

000080f6 <.Loc.219.1>:
	//-------------------------------------------------------------------------------------------------------------//
	//   REGISTERS RESTORE: VERIFY WHICH REGISTERS SHOULD BE RESTORED					   						   //
	//	 																										   //
	//-------------------------------------------------------------------------------------------------------------//

	__asm__ __volatile__ ("cmp.b #0x03,&0x6075");				// 5 cycles
    80f6:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    80fa:	75 60 

000080fc <.Loc.220.1>:
	__asm__ __volatile__ ("jeq __Second_buffer_restore_stack"); // 2 cycles
    80fc:	20 24       	jz	$+66     	;abs 0x813e

000080fe <__First_buffer_restore_stack>:
	/* EDE -> Rm  : 3 cycles each 											  				  			  */
	/* EDE -> PC  : 4 cycles (1 extra cycle penalty) for openMSP430 		  				  			  */
	/* Register time: 14x3 = 42 cycles + 4 cycles (PC) = 49 Cycles + 4(Qwark enable) = 53 cycles 		  */
	__asm__ __volatile__ ("__First_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6016,r4"); 		//R4
    80fe:	14 42 16 60 	mov	&0x6016,r4	;0x6016

00008102 <.Loc.230.1>:
	__asm__ __volatile__ ("mov &0x6018,r5"); 		//R5
    8102:	15 42 18 60 	mov	&0x6018,r5	;0x6018

00008106 <.Loc.231.1>:
	__asm__ __volatile__ ("mov &0x601A,r6"); 		//R6
    8106:	16 42 1a 60 	mov	&0x601a,r6	;0x601a

0000810a <.Loc.232.1>:
	__asm__ __volatile__ ("mov &0x601C,r7"); 		//R7
    810a:	17 42 1c 60 	mov	&0x601c,r7	;0x601c

0000810e <.Loc.233.1>:
	__asm__ __volatile__ ("mov &0x601E,r8"); 		//R8
    810e:	18 42 1e 60 	mov	&0x601e,r8	;0x601e

00008112 <.Loc.234.1>:
	__asm__ __volatile__ ("mov &0x6020,r9"); 		//R9
    8112:	19 42 20 60 	mov	&0x6020,r9	;0x6020

00008116 <.Loc.235.1>:
	__asm__ __volatile__ ("mov &0x6022,r10"); 		//R10
    8116:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

0000811a <.Loc.236.1>:
	__asm__ __volatile__ ("mov &0x6024,r11"); 		//R11
    811a:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

0000811e <.Loc.237.1>:
	__asm__ __volatile__ ("mov &0x6026,r12"); 		//R12
    811e:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

00008122 <.Loc.238.1>:
	__asm__ __volatile__ ("mov &0x6028,r13"); 	    //R13
    8122:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00008126 <.Loc.239.1>:
	__asm__ __volatile__ ("mov &0x602A,r14"); 		//R14
    8126:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

0000812a <.Loc.240.1>:
	__asm__ __volatile__ ("mov &0x602C,r15"); 		//R15
    812a:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

0000812e <.Loc.241.1>:
	__asm__ __volatile__ ("mov &0x6012,r1");   		//SP/R1
    812e:	11 42 12 60 	mov	&0x6012,r1	;0x6012

00008132 <.Loc.242.1>:
	__asm__ __volatile__ ("mov &0x6014,r2"); 	    //SR/R2
    8132:	12 42 14 60 	mov	&0x6014,r2	;0x6014

00008136 <.Loc.245.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    8136:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

0000813a <.Loc.248.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6010, pc"); 	    //PC/R0
    813a:	10 42 10 60 	br	&0x6010		;

0000813e <__Second_buffer_restore_stack>:

	__asm__ __volatile__ ("__Second_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6046,r4"); 		//R4
    813e:	14 42 46 60 	mov	&0x6046,r4	;0x6046

00008142 <.Loc.253.1>:
	__asm__ __volatile__ ("mov &0x6048,r5"); 		//R5
    8142:	15 42 48 60 	mov	&0x6048,r5	;0x6048

00008146 <.Loc.254.1>:
	__asm__ __volatile__ ("mov &0x604A,r6"); 		//R6
    8146:	16 42 4a 60 	mov	&0x604a,r6	;0x604a

0000814a <.Loc.255.1>:
	__asm__ __volatile__ ("mov &0x604C,r7"); 		//R7
    814a:	17 42 4c 60 	mov	&0x604c,r7	;0x604c

0000814e <.Loc.256.1>:
	__asm__ __volatile__ ("mov &0x604E,r8"); 		//R8
    814e:	18 42 4e 60 	mov	&0x604e,r8	;0x604e

00008152 <.Loc.257.1>:
	__asm__ __volatile__ ("mov &0x6050,r9"); 		//R9
    8152:	19 42 50 60 	mov	&0x6050,r9	;0x6050

00008156 <.Loc.258.1>:
	__asm__ __volatile__ ("mov &0x6052,r10"); 		//R10
    8156:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

0000815a <.Loc.259.1>:
	__asm__ __volatile__ ("mov &0x6054,r11"); 		//R11
    815a:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

0000815e <.Loc.260.1>:
	__asm__ __volatile__ ("mov &0x6056,r12"); 		//R12
    815e:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

00008162 <.Loc.261.1>:
	__asm__ __volatile__ ("mov &0x6058,r13"); 	    //R13
    8162:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

00008166 <.Loc.262.1>:
	__asm__ __volatile__ ("mov &0x605A,r14"); 		//R14
    8166:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

0000816a <.Loc.263.1>:
	__asm__ __volatile__ ("mov &0x605C,r15"); 		//R15
    816a:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

0000816e <.Loc.264.1>:
	__asm__ __volatile__ ("mov &0x6042,r1");   		//SP/R1
    816e:	11 42 42 60 	mov	&0x6042,r1	;0x6042

00008172 <.Loc.265.1>:
	__asm__ __volatile__ ("mov &0x6044,r2"); 	    //SR/R2
    8172:	12 42 44 60 	mov	&0x6044,r2	;0x6044

00008176 <.Loc.268.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    8176:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

0000817a <.Loc.271.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6040, pc"); 	    //PC/R0
    817a:	10 42 40 60 	br	&0x6040		;

0000817e <.Loc.273.1>:

}
    817e:	03 43       	nop			

00008180 <__crt0_init_bss>:
    8180:	3c 40 0e 41 	mov	#16654,	r12	;#0x410e

00008184 <.Loc.74.1>:
    8184:	0d 43       	clr	r13		;

00008186 <.Loc.75.1>:
    8186:	3e 40 14 00 	mov	#20,	r14	;#0x0014

0000818a <.Loc.79.1>:
    818a:	b0 12 bc 8e 	call	#36540		;#0x8ebc

0000818e <__crt0_movedata>:
    818e:	3c 40 00 40 	mov	#16384,	r12	;#0x4000

00008192 <.Loc.116.1>:
    8192:	3d 40 06 8f 	mov	#36614,	r13	;#0x8f06

00008196 <.Loc.119.1>:
    8196:	0d 9c       	cmp	r12,	r13	;

00008198 <.Loc.120.1>:
    8198:	04 24       	jz	$+10     	;abs 0x81a2

0000819a <.Loc.122.1>:
    819a:	3e 40 0e 01 	mov	#270,	r14	;#0x010e

0000819e <.Loc.124.1>:
    819e:	b0 12 84 8e 	call	#36484		;#0x8e84

000081a2 <__crt0_call_init_then_main>:
    81a2:	b0 12 ea 8e 	call	#36586		;#0x8eea

000081a6 <.Loc.196.1>:
    81a6:	0c 43       	clr	r12		;

000081a8 <.Loc.197.1>:
    81a8:	b0 12 c2 86 	call	#34498		;#0x86c2

000081ac <_msp430_run_init_array>:
    81ac:	34 40 20 80 	mov	#32800,	r4	;#0x8020

000081b0 <.Loc.224.1>:
    81b0:	35 40 20 80 	mov	#32800,	r5	;#0x8020

000081b4 <.Loc.225.1>:
    81b4:	26 43       	mov	#2,	r6	;r3 As==10

000081b6 <.Loc.226.1>:
    81b6:	30 40 d8 81 	br	#0x81d8		;

000081ba <_msp430_run_preinit_array>:
    81ba:	34 40 20 80 	mov	#32800,	r4	;#0x8020

000081be <.Loc.232.1>:
    81be:	35 40 20 80 	mov	#32800,	r5	;#0x8020

000081c2 <.Loc.233.1>:
    81c2:	26 43       	mov	#2,	r6	;r3 As==10

000081c4 <.Loc.234.1>:
    81c4:	30 40 d8 81 	br	#0x81d8		;

000081c8 <_msp430_run_fini_array>:
    81c8:	34 40 20 80 	mov	#32800,	r4	;#0x8020

000081cc <.Loc.240.1>:
    81cc:	35 40 20 80 	mov	#32800,	r5	;#0x8020

000081d0 <.Loc.241.1>:
    81d0:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe

000081d4 <.Loc.242.1>:
    81d4:	30 40 d8 81 	br	#0x81d8		;

000081d8 <_msp430_run_array>:
    81d8:	05 94       	cmp	r4,	r5	;

000081da <.Loc.246.1>:
    81da:	05 24       	jz	$+12     	;abs 0x81e6

000081dc <.Loc.247.1>:
    81dc:	27 44       	mov	@r4,	r7	;

000081de <.Loc.248.1>:
    81de:	04 56       	add	r6,	r4	;

000081e0 <.Loc.249.1>:
    81e0:	a7 12       	call	@r7		;

000081e2 <.Loc.250.1>:
    81e2:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x81d8

000081e6 <_msp430_run_done>:
    81e6:	30 41       	ret			

000081e8 <deregister_tm_clones>:
    81e8:	3c 40 06 8f 	mov	#36614,	r12	;#0x8f06
    81ec:	3c 90 06 8f 	cmp	#36614,	r12	;#0x8f06
    81f0:	07 24       	jz	$+16     	;abs 0x8200
    81f2:	3d 40 00 00 	mov	#0,	r13	;
    81f6:	0d 93       	cmp	#0,	r13	;r3 As==00
    81f8:	03 24       	jz	$+8      	;abs 0x8200
    81fa:	3c 40 06 8f 	mov	#36614,	r12	;#0x8f06
    81fe:	8d 12       	call	r13		;

00008200 <.L1>:
    8200:	30 41       	ret			

00008202 <register_tm_clones>:
    8202:	0a 12       	push	r10		;
    8204:	3a 40 06 8f 	mov	#36614,	r10	;#0x8f06
    8208:	3a 80 06 8f 	sub	#36614,	r10	;#0x8f06
    820c:	0a 11       	rra	r10		;
    820e:	0c 4a       	mov	r10,	r12	;
    8210:	b0 12 d0 8d 	call	#36304		;#0x8dd0
    8214:	0c 5a       	add	r10,	r12	;
    8216:	0d 4c       	mov	r12,	r13	;
    8218:	0d 11       	rra	r13		;
    821a:	0d 93       	cmp	#0,	r13	;r3 As==00
    821c:	07 24       	jz	$+16     	;abs 0x822c
    821e:	3e 40 00 00 	mov	#0,	r14	;
    8222:	0e 93       	cmp	#0,	r14	;r3 As==00
    8224:	03 24       	jz	$+8      	;abs 0x822c
    8226:	3c 40 06 8f 	mov	#36614,	r12	;#0x8f06
    822a:	8e 12       	call	r14		;

0000822c <.L9>:
    822c:	3a 41       	pop	r10		;
    822e:	30 41       	ret			

00008230 <__do_global_dtors_aux>:
    8230:	0a 12       	push	r10		;
    8232:	09 12       	push	r9		;
    8234:	c2 93 0e 41 	cmp.b	#0,	&0x410e	;r3 As==00
    8238:	17 20       	jnz	$+48     	;abs 0x8268
    823a:	3a 40 2a 80 	mov	#32810,	r10	;#0x802a
    823e:	3a 80 28 80 	sub	#32808,	r10	;#0x8028
    8242:	0a 11       	rra	r10		;
    8244:	3a 53       	add	#-1,	r10	;r3 As==11
    8246:	39 40 28 80 	mov	#32808,	r9	;#0x8028

0000824a <.L19>:
    824a:	1c 42 10 41 	mov	&0x4110,r12	;0x4110
    824e:	0c 9a       	cmp	r10,	r12	;
    8250:	0d 28       	jnc	$+28     	;abs 0x826c
    8252:	b0 12 e8 81 	call	#33256		;#0x81e8
    8256:	3d 40 00 00 	mov	#0,	r13	;
    825a:	0d 93       	cmp	#0,	r13	;r3 As==00
    825c:	03 24       	jz	$+8      	;abs 0x8264
    825e:	3c 40 1c 80 	mov	#32796,	r12	;#0x801c
    8262:	8d 12       	call	r13		;

00008264 <.L21>:
    8264:	d2 43 0e 41 	mov.b	#1,	&0x410e	;r3 As==01

00008268 <.L17>:
    8268:	30 40 ca 8d 	br	#0x8dca		;

0000826c <.L20>:
    826c:	1c 53       	inc	r12		;
    826e:	82 4c 10 41 	mov	r12,	&0x4110	;
    8272:	0c 5c       	rla	r12		;
    8274:	0c 59       	add	r9,	r12	;
    8276:	2c 4c       	mov	@r12,	r12	;
    8278:	8c 12       	call	r12		;
    827a:	30 40 4a 82 	br	#0x824a		;

0000827e <frame_dummy>:
    827e:	3e 40 00 00 	mov	#0,	r14	;
    8282:	0e 93       	cmp	#0,	r14	;r3 As==00
    8284:	05 24       	jz	$+12     	;abs 0x8290
    8286:	3d 40 12 41 	mov	#16658,	r13	;#0x4112
    828a:	3c 40 1c 80 	mov	#32796,	r12	;#0x801c
    828e:	8e 12       	call	r14		;

00008290 <.L27>:
    8290:	b0 12 02 82 	call	#33282		;#0x8202
    8294:	30 41       	ret			

00008296 <btbl_bitcnt>:
      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8   /* 240 - 255 */
};


int btbl_bitcnt(uint32_t x)
{
    8296:	31 80 06 00 	sub	#6,	r1	;

0000829a <.LCFI0>:
    829a:	81 4c 00 00 	mov	r12,	0(r1)	;
    829e:	81 4d 02 00 	mov	r13,	2(r1)	;

000082a2 <.Loc.48.1>:
      int cnt = bits[ ((char *)&x)[0] & 0xFF ];
    82a2:	0c 41       	mov	r1,	r12	;
    82a4:	6c 4c       	mov.b	@r12,	r12	;
    82a6:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    82aa:	81 4c 04 00 	mov	r12,	4(r1)	;

000082ae <.Loc.50.1>:

      if (0L != (x >>= 8))
    82ae:	2c 41       	mov	@r1,	r12	;
    82b0:	1d 41 02 00 	mov	2(r1),	r13	;
    82b4:	b0 12 44 8e 	call	#36420		;#0x8e44
    82b8:	81 4c 00 00 	mov	r12,	0(r1)	;
    82bc:	81 4d 02 00 	mov	r13,	2(r1)	;
    82c0:	2d 41       	mov	@r1,	r13	;
    82c2:	1e 41 02 00 	mov	2(r1),	r14	;
    82c6:	0c 4d       	mov	r13,	r12	;
    82c8:	0c de       	bis	r14,	r12	;
    82ca:	0c 93       	cmp	#0,	r12	;r3 As==00
    82cc:	07 24       	jz	$+16     	;abs 0x82dc

000082ce <.Loc.51.1>:
            cnt += btbl_bitcnt(x);
    82ce:	2c 41       	mov	@r1,	r12	;
    82d0:	1d 41 02 00 	mov	2(r1),	r13	;
    82d4:	b0 12 96 82 	call	#33430		;#0x8296
    82d8:	81 5c 04 00 	add	r12,	4(r1)	;

000082dc <.L2>:
      return cnt;
    82dc:	1c 41 04 00 	mov	4(r1),	r12	;

000082e0 <.Loc.53.1>:
}
    82e0:	31 50 06 00 	add	#6,	r1	;
    82e4:	30 41       	ret			

000082e6 <bit_count>:
int bit_count(uint32_t x)
{
    82e6:	31 80 06 00 	sub	#6,	r1	;

000082ea <.LCFI1>:
    82ea:	81 4c 00 00 	mov	r12,	0(r1)	;
    82ee:	81 4d 02 00 	mov	r13,	2(r1)	;

000082f2 <.Loc.56.1>:
        int n = 0;
    82f2:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

000082f6 <.Loc.58.1>:

        if (x) do
    82f6:	2c 41       	mov	@r1,	r12	;
    82f8:	1c d1 02 00 	bis	2(r1),	r12	;
    82fc:	0c 93       	cmp	#0,	r12	;r3 As==00
    82fe:	10 24       	jz	$+34     	;abs 0x8320

00008300 <.L8>:
              n++;
    8300:	91 53 04 00 	inc	4(r1)		;

00008304 <.Loc.60.1>:
        while (0 != (x = x&(x-1))) ;
    8304:	2e 41       	mov	@r1,	r14	;
    8306:	3e 53       	add	#-1,	r14	;r3 As==11
    8308:	1f 41 02 00 	mov	2(r1),	r15	;
    830c:	3f 63       	addc	#-1,	r15	;r3 As==11
    830e:	81 fe 00 00 	and	r14,	0(r1)	;
    8312:	81 ff 02 00 	and	r15,	2(r1)	;
    8316:	2c 41       	mov	@r1,	r12	;
    8318:	1c d1 02 00 	bis	2(r1),	r12	;
    831c:	0c 93       	cmp	#0,	r12	;r3 As==00
    831e:	f0 23       	jnz	$-30     	;abs 0x8300

00008320 <.L6>:
        return(n);
    8320:	1c 41 04 00 	mov	4(r1),	r12	;

00008324 <.Loc.62.1>:
}
    8324:	31 50 06 00 	add	#6,	r1	;
    8328:	30 41       	ret			

0000832a <bitcount>:
int bitcount(uint32_t i)
{
    832a:	0a 12       	push	r10		;

0000832c <.LCFI2>:
    832c:	09 12       	push	r9		;

0000832e <.LCFI3>:
    832e:	08 12       	push	r8		;

00008330 <.LCFI4>:
    8330:	07 12       	push	r7		;

00008332 <.LCFI5>:
    8332:	06 12       	push	r6		;

00008334 <.LCFI6>:
    8334:	05 12       	push	r5		;

00008336 <.LCFI7>:
    8336:	04 12       	push	r4		;

00008338 <.LCFI8>:
    8338:	31 80 14 00 	sub	#20,	r1	;#0x0014

0000833c <.LCFI9>:
    833c:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    8340:	81 4d 12 00 	mov	r13,	18(r1)	; 0x0012

00008344 <.Loc.65.1>:
      i = ((i & 0xAAAAAAAAL) >>  1) + (i & 0x55555555L);
    8344:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8348:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    834c:	12 c3       	clrc			
    834e:	0d 10       	rrc	r13		;
    8350:	0c 10       	rrc	r12		;
    8352:	0a 4c       	mov	r12,	r10	;
    8354:	3a f0 55 55 	and	#21845,	r10	;#0x5555
    8358:	0b 4d       	mov	r13,	r11	;
    835a:	3b f0 55 55 	and	#21845,	r11	;#0x5555
    835e:	1e 41 10 00 	mov	16(r1),	r14	;0x00010
    8362:	3e f0 55 55 	and	#21845,	r14	;#0x5555
    8366:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    836a:	3f f0 55 55 	and	#21845,	r15	;#0x5555
    836e:	0c 4a       	mov	r10,	r12	;
    8370:	0c 5e       	add	r14,	r12	;
    8372:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    8376:	0c 4b       	mov	r11,	r12	;
    8378:	0c 6f       	addc	r15,	r12	;
    837a:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012

0000837e <.Loc.66.1>:
      i = ((i & 0xCCCCCCCCL) >>  2) + (i & 0x33333333L);
    837e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8382:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8386:	b0 12 68 8e 	call	#36456		;#0x8e68
    838a:	0e 4c       	mov	r12,	r14	;
    838c:	3e f0 33 33 	and	#13107,	r14	;#0x3333
    8390:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    8394:	0e 4d       	mov	r13,	r14	;
    8396:	3e f0 33 33 	and	#13107,	r14	;#0x3333
    839a:	81 4e 0e 00 	mov	r14,	14(r1)	; 0x000e
    839e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    83a2:	3c f0 33 33 	and	#13107,	r12	;#0x3333
    83a6:	81 4c 08 00 	mov	r12,	8(r1)	;
    83aa:	1e 41 12 00 	mov	18(r1),	r14	;0x00012
    83ae:	3e f0 33 33 	and	#13107,	r14	;#0x3333
    83b2:	81 4e 0a 00 	mov	r14,	10(r1)	; 0x000a
    83b6:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    83ba:	1c 51 08 00 	add	8(r1),	r12	;
    83be:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    83c2:	1e 41 0e 00 	mov	14(r1),	r14	;0x0000e
    83c6:	1e 61 0a 00 	addc	10(r1),	r14	;0x0000a
    83ca:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

000083ce <.Loc.67.1>:
      i = ((i & 0xF0F0F0F0L) >>  4) + (i & 0x0F0F0F0FL);
    83ce:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    83d2:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    83d6:	b0 12 5c 8e 	call	#36444		;#0x8e5c
    83da:	0e 4c       	mov	r12,	r14	;
    83dc:	3e f0 0f 0f 	and	#3855,	r14	;#0x0f0f
    83e0:	81 4e 04 00 	mov	r14,	4(r1)	;
    83e4:	0e 4d       	mov	r13,	r14	;
    83e6:	3e f0 0f 0f 	and	#3855,	r14	;#0x0f0f
    83ea:	81 4e 06 00 	mov	r14,	6(r1)	;
    83ee:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    83f2:	3c f0 0f 0f 	and	#3855,	r12	;#0x0f0f
    83f6:	81 4c 00 00 	mov	r12,	0(r1)	;
    83fa:	1e 41 12 00 	mov	18(r1),	r14	;0x00012
    83fe:	3e f0 0f 0f 	and	#3855,	r14	;#0x0f0f
    8402:	81 4e 02 00 	mov	r14,	2(r1)	;
    8406:	1c 41 04 00 	mov	4(r1),	r12	;
    840a:	2c 51       	add	@r1,	r12	;
    840c:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    8410:	1e 41 06 00 	mov	6(r1),	r14	;
    8414:	1e 61 02 00 	addc	2(r1),	r14	;
    8418:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

0000841c <.Loc.68.1>:
      i = ((i & 0xFF00FF00L) >>  8) + (i & 0x00FF00FFL);
    841c:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8420:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8424:	b0 12 44 8e 	call	#36420		;#0x8e44
    8428:	04 4c       	mov	r12,	r4	;
    842a:	74 f0 ff 00 	and.b	#255,	r4	;#0x00ff
    842e:	05 4d       	mov	r13,	r5	;
    8430:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff
    8434:	16 41 10 00 	mov	16(r1),	r6	;0x00010
    8438:	76 f0 ff 00 	and.b	#255,	r6	;#0x00ff
    843c:	17 41 12 00 	mov	18(r1),	r7	;0x00012
    8440:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff
    8444:	0c 44       	mov	r4,	r12	;
    8446:	0c 56       	add	r6,	r12	;
    8448:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    844c:	0e 45       	mov	r5,	r14	;
    844e:	0e 67       	addc	r7,	r14	;
    8450:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

00008454 <.Loc.69.1>:
      i = ((i & 0xFFFF0000L) >> 16) + (i & 0x0000FFFFL);
    8454:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8458:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    845c:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8460:	4f 43       	clr.b	r15		;
    8462:	b0 12 7e 8e 	call	#36478		;#0x8e7e
    8466:	18 41 10 00 	mov	16(r1),	r8	;0x00010
    846a:	08 c3       	bic	#0,	r8	;r3 As==00
    846c:	19 41 12 00 	mov	18(r1),	r9	;0x00012
    8470:	39 c3       	bic	#-1,	r9	;r3 As==11
    8472:	0e 4c       	mov	r12,	r14	;
    8474:	0e 58       	add	r8,	r14	;
    8476:	81 4e 10 00 	mov	r14,	16(r1)	; 0x0010
    847a:	0e 4d       	mov	r13,	r14	;
    847c:	0e 69       	addc	r9,	r14	;
    847e:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

00008482 <.Loc.70.1>:
      return (int)i;
    8482:	1c 41 10 00 	mov	16(r1),	r12	;0x00010

00008486 <.Loc.71.1>:
}
    8486:	31 50 14 00 	add	#20,	r1	;#0x0014
    848a:	30 40 c0 8d 	br	#0x8dc0		;

0000848e <ntbl_bitcount>:
int ntbl_bitcount(uint32_t x)
{
    848e:	0a 12       	push	r10		;

00008490 <.LCFI10>:
    8490:	21 82       	sub	#4,	r1	;r2 As==10

00008492 <.LCFI11>:
    8492:	81 4c 00 00 	mov	r12,	0(r1)	;
    8496:	81 4d 02 00 	mov	r13,	2(r1)	;

0000849a <.Loc.75.1>:
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
    849a:	2c 41       	mov	@r1,	r12	;
    849c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84a0:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    84a4:	0a 4c       	mov	r12,	r10	;

000084a6 <.Loc.76.1>:
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
    84a6:	2c 41       	mov	@r1,	r12	;
    84a8:	1d 41 02 00 	mov	2(r1),	r13	;
    84ac:	b0 12 5c 8e 	call	#36444		;#0x8e5c
    84b0:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84b4:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

000084b8 <.Loc.75.1>:
      return (int)i;
}
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
    84b8:	0a 5c       	add	r12,	r10	;

000084ba <.Loc.77.1>:
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
    84ba:	2c 41       	mov	@r1,	r12	;
    84bc:	1d 41 02 00 	mov	2(r1),	r13	;
    84c0:	b0 12 44 8e 	call	#36420		;#0x8e44
    84c4:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84c8:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

000084cc <.Loc.76.1>:
}
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
    84cc:	0a 5c       	add	r12,	r10	;

000084ce <.Loc.78.1>:
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
    84ce:	2c 41       	mov	@r1,	r12	;
    84d0:	1d 41 02 00 	mov	2(r1),	r13	;
    84d4:	b0 12 2c 8e 	call	#36396		;#0x8e2c
    84d8:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84dc:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

000084e0 <.Loc.77.1>:
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
    84e0:	0a 5c       	add	r12,	r10	;

000084e2 <.Loc.79.1>:
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
    84e2:	2c 41       	mov	@r1,	r12	;
    84e4:	1d 41 02 00 	mov	2(r1),	r13	;
    84e8:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    84ec:	4f 43       	clr.b	r15		;
    84ee:	b0 12 7e 8e 	call	#36478		;#0x8e7e
    84f2:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84f6:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

000084fa <.Loc.78.1>:
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
    84fa:	0a 5c       	add	r12,	r10	;

000084fc <.Loc.80.1>:
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
    84fc:	2c 41       	mov	@r1,	r12	;
    84fe:	1d 41 02 00 	mov	2(r1),	r13	;
    8502:	7e 40 14 00 	mov.b	#20,	r14	;#0x0014
    8506:	4f 43       	clr.b	r15		;
    8508:	b0 12 7e 8e 	call	#36478		;#0x8e7e
    850c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    8510:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

00008514 <.Loc.79.1>:
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
    8514:	0a 5c       	add	r12,	r10	;

00008516 <.Loc.81.1>:
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
    8516:	2c 41       	mov	@r1,	r12	;
    8518:	1d 41 02 00 	mov	2(r1),	r13	;
    851c:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    8520:	4f 43       	clr.b	r15		;
    8522:	b0 12 7e 8e 	call	#36478		;#0x8e7e
    8526:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    852a:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

0000852e <.Loc.80.1>:
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
    852e:	0a 5c       	add	r12,	r10	;

00008530 <.Loc.82.1>:
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
            bits[ (int)((x & 0xF0000000UL) >> 28)];
    8530:	2c 41       	mov	@r1,	r12	;
    8532:	1d 41 02 00 	mov	2(r1),	r13	;
    8536:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    853a:	4f 43       	clr.b	r15		;
    853c:	b0 12 7e 8e 	call	#36478		;#0x8e7e
    8540:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

00008544 <.Loc.81.1>:
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
    8544:	0c 5a       	add	r10,	r12	;

00008546 <.Loc.83.1>:
            bits[ (int)((x & 0xF0000000UL) >> 28)];
}
    8546:	21 52       	add	#4,	r1	;r2 As==10
    8548:	3a 41       	pop	r10		;
    854a:	30 41       	ret			

0000854c <BW_btbl_bitcount>:
int BW_btbl_bitcount(uint32_t x)
{
    854c:	31 82       	sub	#8,	r1	;r2 As==11

0000854e <.LCFI12>:
    854e:	81 4c 00 00 	mov	r12,	0(r1)	;
    8552:	81 4d 02 00 	mov	r13,	2(r1)	;

00008556 <.Loc.92.1>:
      {
            unsigned char ch[4];
            long y;
      } U;

      U.y = x;
    8556:	2c 41       	mov	@r1,	r12	;
    8558:	1d 41 02 00 	mov	2(r1),	r13	;
    855c:	81 4c 04 00 	mov	r12,	4(r1)	;
    8560:	81 4d 06 00 	mov	r13,	6(r1)	;

00008564 <.Loc.94.1>:

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    8564:	5c 41 04 00 	mov.b	4(r1),	r12	;
    8568:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    856c:	0d 4c       	mov	r12,	r13	;
    856e:	5c 41 05 00 	mov.b	5(r1),	r12	;
    8572:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    8576:	0d 5c       	add	r12,	r13	;

00008578 <.Loc.95.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    8578:	5c 41 07 00 	mov.b	7(r1),	r12	;
    857c:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e

00008580 <.Loc.94.1>:
            long y;
      } U;

      U.y = x;

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    8580:	0d 5c       	add	r12,	r13	;

00008582 <.Loc.95.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    8582:	5c 41 06 00 	mov.b	6(r1),	r12	;
    8586:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    858a:	0c 5d       	add	r13,	r12	;

0000858c <.Loc.96.1>:
}
    858c:	31 52       	add	#8,	r1	;r2 As==11
    858e:	30 41       	ret			

00008590 <AR_btbl_bitcount>:
int AR_btbl_bitcount(uint32_t x)
{
    8590:	31 82       	sub	#8,	r1	;r2 As==11

00008592 <.LCFI13>:
    8592:	81 4c 00 00 	mov	r12,	0(r1)	;
    8596:	81 4d 02 00 	mov	r13,	2(r1)	;

0000859a <.Loc.99.1>:
      unsigned char * Ptr = (unsigned char *) &x ;
    859a:	7c 42       	mov.b	#8,	r12	;r2 As==11
    859c:	0c 51       	add	r1,	r12	;
    859e:	3c 50 f8 ff 	add	#65528,	r12	;#0xfff8
    85a2:	81 4c 06 00 	mov	r12,	6(r1)	;

000085a6 <.Loc.102.1>:
      int Accu ;

      Accu  = bits[ *Ptr++ ];
    85a6:	1c 41 06 00 	mov	6(r1),	r12	;
    85aa:	0d 4c       	mov	r12,	r13	;
    85ac:	1d 53       	inc	r13		;
    85ae:	81 4d 06 00 	mov	r13,	6(r1)	;
    85b2:	6c 4c       	mov.b	@r12,	r12	;
    85b4:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    85b8:	81 4c 04 00 	mov	r12,	4(r1)	;

000085bc <.Loc.103.1>:
      Accu += bits[ *Ptr++ ];
    85bc:	1c 41 06 00 	mov	6(r1),	r12	;
    85c0:	0d 4c       	mov	r12,	r13	;
    85c2:	1d 53       	inc	r13		;
    85c4:	81 4d 06 00 	mov	r13,	6(r1)	;
    85c8:	6c 4c       	mov.b	@r12,	r12	;
    85ca:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    85ce:	81 5c 04 00 	add	r12,	4(r1)	;

000085d2 <.Loc.104.1>:
      Accu += bits[ *Ptr++ ];
    85d2:	1c 41 06 00 	mov	6(r1),	r12	;
    85d6:	0d 4c       	mov	r12,	r13	;
    85d8:	1d 53       	inc	r13		;
    85da:	81 4d 06 00 	mov	r13,	6(r1)	;
    85de:	6c 4c       	mov.b	@r12,	r12	;
    85e0:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    85e4:	81 5c 04 00 	add	r12,	4(r1)	;

000085e8 <.Loc.105.1>:
      Accu += bits[ *Ptr ];
    85e8:	1c 41 06 00 	mov	6(r1),	r12	;
    85ec:	6c 4c       	mov.b	@r12,	r12	;
    85ee:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    85f2:	81 5c 04 00 	add	r12,	4(r1)	;

000085f6 <.Loc.106.1>:
      return Accu;
    85f6:	1c 41 04 00 	mov	4(r1),	r12	;

000085fa <.Loc.107.1>:
}
    85fa:	31 52       	add	#8,	r1	;r2 As==11
    85fc:	30 41       	ret			

000085fe <ntbl_bitcnt>:
int ntbl_bitcnt(uint32_t x)
{
    85fe:	31 80 06 00 	sub	#6,	r1	;

00008602 <.LCFI14>:
    8602:	81 4c 00 00 	mov	r12,	0(r1)	;
    8606:	81 4d 02 00 	mov	r13,	2(r1)	;

0000860a <.Loc.110.1>:
      int cnt = bits[(int)(x & 0x0000000FL)];
    860a:	2c 41       	mov	@r1,	r12	;
    860c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    8610:	5c 4c 0e 40 	mov.b	16398(r12),r12	;0x0400e
    8614:	81 4c 04 00 	mov	r12,	4(r1)	;

00008618 <.Loc.112.1>:

      if (0L != (x >>= 4))
    8618:	2c 41       	mov	@r1,	r12	;
    861a:	1d 41 02 00 	mov	2(r1),	r13	;
    861e:	b0 12 5c 8e 	call	#36444		;#0x8e5c
    8622:	81 4c 00 00 	mov	r12,	0(r1)	;
    8626:	81 4d 02 00 	mov	r13,	2(r1)	;
    862a:	2c 41       	mov	@r1,	r12	;
    862c:	1c d1 02 00 	bis	2(r1),	r12	;
    8630:	0c 93       	cmp	#0,	r12	;r3 As==00
    8632:	07 24       	jz	$+16     	;abs 0x8642

00008634 <.Loc.113.1>:
            cnt += ntbl_bitcnt(x);
    8634:	2c 41       	mov	@r1,	r12	;
    8636:	1d 41 02 00 	mov	2(r1),	r13	;
    863a:	b0 12 fe 85 	call	#34302		;#0x85fe
    863e:	81 5c 04 00 	add	r12,	4(r1)	;

00008642 <.L19>:

      return cnt;
    8642:	1c 41 04 00 	mov	4(r1),	r12	;

00008646 <.Loc.116.1>:
}
    8646:	31 50 06 00 	add	#6,	r1	;
    864a:	30 41       	ret			

0000864c <bit_shifter>:

static int bit_shifter(uint32_t x)
{
    864c:	31 82       	sub	#8,	r1	;r2 As==11

0000864e <.LCFI15>:
    864e:	81 4c 00 00 	mov	r12,	0(r1)	;
    8652:	81 4d 02 00 	mov	r13,	2(r1)	;

00008656 <.Loc.121.1>:
  int i, n;
  for (i = n = 0; x && (i < (sizeof(uint32_t) * CHAR_BIT)); ++i, x >>= 1)
    8656:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    865a:	91 41 04 00 	mov	4(r1),	6(r1)	;
    865e:	06 00 
    8660:	30 40 78 86 	br	#0x8678		;

00008664 <.L26>:
    n += (int)(x & 1L);
    8664:	2c 41       	mov	@r1,	r12	;
    8666:	5c f3       	and.b	#1,	r12	;r3 As==01
    8668:	81 5c 04 00 	add	r12,	4(r1)	;

0000866c <.Loc.121.1>:
}

static int bit_shifter(uint32_t x)
{
  int i, n;
  for (i = n = 0; x && (i < (sizeof(uint32_t) * CHAR_BIT)); ++i, x >>= 1)
    866c:	91 53 06 00 	inc	6(r1)		;
    8670:	12 c3       	clrc			
    8672:	11 10 02 00 	rrc	2(r1)		;
    8676:	21 10       	rrc	@r1		;

00008678 <.L23>:
    8678:	2c 41       	mov	@r1,	r12	;
    867a:	1c d1 02 00 	bis	2(r1),	r12	;
    867e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8680:	06 24       	jz	$+14     	;abs 0x868e
    8682:	1d 41 06 00 	mov	6(r1),	r13	;
    8686:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    868a:	0c 9d       	cmp	r13,	r12	;
    868c:	eb 2f       	jc	$-40     	;abs 0x8664

0000868e <.L24>:
    n += (int)(x & 1L);
  return n;
    868e:	1c 41 04 00 	mov	4(r1),	r12	;

00008692 <.Loc.124.1>:
}
    8692:	31 52       	add	#8,	r1	;r2 As==11
    8694:	30 41       	ret			

00008696 <init>:


void init()
{
     WDTCTL = WDTPW | WDTHOLD; // Stop WDT
    8696:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    869a:	bc 40 80 5a 	mov	#23168,	0(r12)	;#0x5a80
    869e:	00 00 

000086a0 <.Loc.130.1>:
  	 __asm__ __volatile__ ("nop");
    86a0:	03 43       	nop			

000086a2 <.Loc.131.1>:
     eint();
    86a2:	32 d2       	eint			
    86a4:	03 43       	nop			

000086a6 <.Loc.132.1>:
 	 UART_BAUD = BAUD;                   // Init UART
    86a6:	7c 40 82 00 	mov.b	#130,	r12	;#0x0082
    86aa:	bc 42 00 00 	mov	#8,	0(r12)	;r2 As==11

000086ae <.Loc.133.1>:
     UART_CTL  = UART_EN;
    86ae:	7c 40 80 00 	mov.b	#128,	r12	;#0x0080
    86b2:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000086b6 <.Loc.135.1>:
     //Enable QWARK
     QWARK_CTL = QWARK_EN;
    86b6:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    86ba:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

000086be <.Loc.136.1>:
}
    86be:	03 43       	nop			
    86c0:	30 41       	ret			

000086c2 <main>:



int main()
{
    86c2:	31 82       	sub	#8,	r1	;r2 As==11

000086c4 <.LCFI16>:
	init();
    86c4:	b0 12 96 86 	call	#34454		;#0x8696

000086c8 <.Loc.143.1>:
	LED_CTRL = 0xAA;
    86c8:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    86cc:	fc 40 aa ff 	mov.b	#65450,	0(r12)	;#0xffaa
    86d0:	00 00 

000086d2 <.L53>:

	/* Iterate through the 7 func statements 0 - 7*/
	/* Each statement executes a different bitcount routine, with a different seed value, a 100 times*/
	while(1){

	LED_CTRL ^= 0xFF;
    86d2:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    86d6:	6d 4c       	mov.b	@r12,	r13	;
    86d8:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    86dc:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    86de:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    86e2:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000086e6 <.Loc.160.1>:

	//Initialize the variables upon every loop

	n_0=0;
    86e6:	82 43 00 40 	mov	#0,	&0x4000	;r3 As==00

000086ea <.Loc.161.1>:
	n_1=0;
    86ea:	82 43 02 40 	mov	#0,	&0x4002	;r3 As==00

000086ee <.Loc.162.1>:
	n_2=0;
    86ee:	82 43 04 40 	mov	#0,	&0x4004	;r3 As==00

000086f2 <.Loc.163.1>:
	n_3=0;
    86f2:	82 43 06 40 	mov	#0,	&0x4006	;r3 As==00

000086f6 <.Loc.164.1>:
	n_4=0;
    86f6:	82 43 08 40 	mov	#0,	&0x4008	;r3 As==00

000086fa <.Loc.165.1>:
	n_5=0;
    86fa:	82 43 0a 40 	mov	#0,	&0x400a	;r3 As==00

000086fe <.Loc.166.1>:
	n_6=0;
    86fe:	82 43 0c 40 	mov	#0,	&0x400c	;r3 As==00

00008702 <.Loc.170.1>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {
    8702:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    8706:	30 40 e6 88 	br	#0x88e6		;

0000870a <.L52>:

		seed = (uint32_t)SEED;
    870a:	a1 42 04 00 	mov	#4,	4(r1)	;r2 As==10
    870e:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00008712 <.Loc.173.1>:
		if(func == 0){
    8712:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    8716:	1e 20       	jnz	$+62     	;abs 0x8754

00008718 <.Loc.174.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8718:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    871c:	30 40 46 87 	br	#0x8746		;

00008720 <.L33>:

				n_0 += bit_count(seed);
    8720:	1c 41 04 00 	mov	4(r1),	r12	;
    8724:	1d 41 06 00 	mov	6(r1),	r13	;
    8728:	b0 12 e6 82 	call	#33510		;#0x82e6
    872c:	0d 4c       	mov	r12,	r13	;
    872e:	1c 42 00 40 	mov	&0x4000,r12	;0x4000
    8732:	0c 5d       	add	r13,	r12	;
    8734:	82 4c 00 40 	mov	r12,	&0x4000	;

00008738 <.Loc.174.1>:

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
		if(func == 0){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8738:	91 53 02 00 	inc	2(r1)		;
    873c:	b1 50 0d 00 	add	#13,	4(r1)	;#0x000d
    8740:	04 00 
    8742:	81 63 06 00 	adc	6(r1)		;

00008746 <.L32>:
    8746:	7c 40 63 00 	mov.b	#99,	r12	;#0x0063
    874a:	1c 91 02 00 	cmp	2(r1),	r12	;
    874e:	e8 2f       	jc	$-46     	;abs 0x8720
    8750:	30 40 e2 88 	br	#0x88e2		;

00008754 <.L31>:

				n_0 += bit_count(seed);
			}
		}
		else if(func == 1){
    8754:	91 93 00 00 	cmp	#1,	0(r1)	;r3 As==01
    8758:	1e 20       	jnz	$+62     	;abs 0x8796

0000875a <.Loc.180.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    875a:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    875e:	30 40 88 87 	br	#0x8788		;

00008762 <.L37>:

				n_1 += bitcount(seed);
    8762:	1c 41 04 00 	mov	4(r1),	r12	;
    8766:	1d 41 06 00 	mov	6(r1),	r13	;
    876a:	b0 12 2a 83 	call	#33578		;#0x832a
    876e:	0d 4c       	mov	r12,	r13	;
    8770:	1c 42 02 40 	mov	&0x4002,r12	;0x4002
    8774:	0c 5d       	add	r13,	r12	;
    8776:	82 4c 02 40 	mov	r12,	&0x4002	;

0000877a <.Loc.180.1>:

				n_0 += bit_count(seed);
			}
		}
		else if(func == 1){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    877a:	91 53 02 00 	inc	2(r1)		;
    877e:	b1 50 0d 00 	add	#13,	4(r1)	;#0x000d
    8782:	04 00 
    8784:	81 63 06 00 	adc	6(r1)		;

00008788 <.L36>:
    8788:	7c 40 63 00 	mov.b	#99,	r12	;#0x0063
    878c:	1c 91 02 00 	cmp	2(r1),	r12	;
    8790:	e8 2f       	jc	$-46     	;abs 0x8762
    8792:	30 40 e2 88 	br	#0x88e2		;

00008796 <.L35>:

				n_1 += bitcount(seed);
			}
		}
		else if(func == 2){
    8796:	a1 93 00 00 	cmp	#2,	0(r1)	;r3 As==10
    879a:	1e 20       	jnz	$+62     	;abs 0x87d8

0000879c <.Loc.186.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    879c:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    87a0:	30 40 ca 87 	br	#0x87ca		;

000087a4 <.L40>:

				n_2 += ntbl_bitcnt(seed);
    87a4:	1c 41 04 00 	mov	4(r1),	r12	;
    87a8:	1d 41 06 00 	mov	6(r1),	r13	;
    87ac:	b0 12 fe 85 	call	#34302		;#0x85fe
    87b0:	0d 4c       	mov	r12,	r13	;
    87b2:	1c 42 04 40 	mov	&0x4004,r12	;0x4004
    87b6:	0c 5d       	add	r13,	r12	;
    87b8:	82 4c 04 40 	mov	r12,	&0x4004	;

000087bc <.Loc.186.1>:

				n_1 += bitcount(seed);
			}
		}
		else if(func == 2){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    87bc:	91 53 02 00 	inc	2(r1)		;
    87c0:	b1 50 0d 00 	add	#13,	4(r1)	;#0x000d
    87c4:	04 00 
    87c6:	81 63 06 00 	adc	6(r1)		;

000087ca <.L39>:
    87ca:	7c 40 63 00 	mov.b	#99,	r12	;#0x0063
    87ce:	1c 91 02 00 	cmp	2(r1),	r12	;
    87d2:	e8 2f       	jc	$-46     	;abs 0x87a4
    87d4:	30 40 e2 88 	br	#0x88e2		;

000087d8 <.L38>:

				n_2 += ntbl_bitcnt(seed);
			}
		}
		else if(func == 3){
    87d8:	b1 90 03 00 	cmp	#3,	0(r1)	;
    87dc:	00 00 
    87de:	1e 20       	jnz	$+62     	;abs 0x881c

000087e0 <.Loc.192.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    87e0:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    87e4:	30 40 0e 88 	br	#0x880e		;

000087e8 <.L43>:

				n_3 += ntbl_bitcount(seed);
    87e8:	1c 41 04 00 	mov	4(r1),	r12	;
    87ec:	1d 41 06 00 	mov	6(r1),	r13	;
    87f0:	b0 12 8e 84 	call	#33934		;#0x848e
    87f4:	0d 4c       	mov	r12,	r13	;
    87f6:	1c 42 06 40 	mov	&0x4006,r12	;0x4006
    87fa:	0c 5d       	add	r13,	r12	;
    87fc:	82 4c 06 40 	mov	r12,	&0x4006	;

00008800 <.Loc.192.1>:

				n_2 += ntbl_bitcnt(seed);
			}
		}
		else if(func == 3){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8800:	91 53 02 00 	inc	2(r1)		;
    8804:	b1 50 0d 00 	add	#13,	4(r1)	;#0x000d
    8808:	04 00 
    880a:	81 63 06 00 	adc	6(r1)		;

0000880e <.L42>:
    880e:	7c 40 63 00 	mov.b	#99,	r12	;#0x0063
    8812:	1c 91 02 00 	cmp	2(r1),	r12	;
    8816:	e8 2f       	jc	$-46     	;abs 0x87e8
    8818:	30 40 e2 88 	br	#0x88e2		;

0000881c <.L41>:

				n_3 += ntbl_bitcount(seed);
			}
		}
		else if(func == 4){
    881c:	a1 92 00 00 	cmp	#4,	0(r1)	;r2 As==10
    8820:	1e 20       	jnz	$+62     	;abs 0x885e

00008822 <.Loc.198.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8822:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8826:	30 40 50 88 	br	#0x8850		;

0000882a <.L46>:

				n_4 += BW_btbl_bitcount(seed);
    882a:	1c 41 04 00 	mov	4(r1),	r12	;
    882e:	1d 41 06 00 	mov	6(r1),	r13	;
    8832:	b0 12 4c 85 	call	#34124		;#0x854c
    8836:	0d 4c       	mov	r12,	r13	;
    8838:	1c 42 08 40 	mov	&0x4008,r12	;0x4008
    883c:	0c 5d       	add	r13,	r12	;
    883e:	82 4c 08 40 	mov	r12,	&0x4008	;

00008842 <.Loc.198.1>:

				n_3 += ntbl_bitcount(seed);
			}
		}
		else if(func == 4){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8842:	91 53 02 00 	inc	2(r1)		;
    8846:	b1 50 0d 00 	add	#13,	4(r1)	;#0x000d
    884a:	04 00 
    884c:	81 63 06 00 	adc	6(r1)		;

00008850 <.L45>:
    8850:	7c 40 63 00 	mov.b	#99,	r12	;#0x0063
    8854:	1c 91 02 00 	cmp	2(r1),	r12	;
    8858:	e8 2f       	jc	$-46     	;abs 0x882a
    885a:	30 40 e2 88 	br	#0x88e2		;

0000885e <.L44>:

				n_4 += BW_btbl_bitcount(seed);
			}
		}
		else if(func == 5){
    885e:	b1 90 05 00 	cmp	#5,	0(r1)	;
    8862:	00 00 
    8864:	1e 20       	jnz	$+62     	;abs 0x88a2

00008866 <.Loc.204.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8866:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    886a:	30 40 94 88 	br	#0x8894		;

0000886e <.L49>:

				n_5 += AR_btbl_bitcount(seed);
    886e:	1c 41 04 00 	mov	4(r1),	r12	;
    8872:	1d 41 06 00 	mov	6(r1),	r13	;
    8876:	b0 12 90 85 	call	#34192		;#0x8590
    887a:	0d 4c       	mov	r12,	r13	;
    887c:	1c 42 0a 40 	mov	&0x400a,r12	;0x400a
    8880:	0c 5d       	add	r13,	r12	;
    8882:	82 4c 0a 40 	mov	r12,	&0x400a	;

00008886 <.Loc.204.1>:

				n_4 += BW_btbl_bitcount(seed);
			}
		}
		else if(func == 5){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8886:	91 53 02 00 	inc	2(r1)		;
    888a:	b1 50 0d 00 	add	#13,	4(r1)	;#0x000d
    888e:	04 00 
    8890:	81 63 06 00 	adc	6(r1)		;

00008894 <.L48>:
    8894:	7c 40 63 00 	mov.b	#99,	r12	;#0x0063
    8898:	1c 91 02 00 	cmp	2(r1),	r12	;
    889c:	e8 2f       	jc	$-46     	;abs 0x886e
    889e:	30 40 e2 88 	br	#0x88e2		;

000088a2 <.L47>:

				n_5 += AR_btbl_bitcount(seed);
			}
		}
		else if(func == 6){
    88a2:	b1 90 06 00 	cmp	#6,	0(r1)	;
    88a6:	00 00 
    88a8:	1c 20       	jnz	$+58     	;abs 0x88e2

000088aa <.Loc.210.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    88aa:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    88ae:	30 40 d8 88 	br	#0x88d8		;

000088b2 <.L51>:

				n_6 += bit_shifter(seed);
    88b2:	1c 41 04 00 	mov	4(r1),	r12	;
    88b6:	1d 41 06 00 	mov	6(r1),	r13	;
    88ba:	b0 12 4c 86 	call	#34380		;#0x864c
    88be:	0d 4c       	mov	r12,	r13	;
    88c0:	1c 42 0c 40 	mov	&0x400c,r12	;0x400c
    88c4:	0c 5d       	add	r13,	r12	;
    88c6:	82 4c 0c 40 	mov	r12,	&0x400c	;

000088ca <.Loc.210.1>:

				n_5 += AR_btbl_bitcount(seed);
			}
		}
		else if(func == 6){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    88ca:	91 53 02 00 	inc	2(r1)		;
    88ce:	b1 50 0d 00 	add	#13,	4(r1)	;#0x000d
    88d2:	04 00 
    88d4:	81 63 06 00 	adc	6(r1)		;

000088d8 <.L50>:
    88d8:	7c 40 63 00 	mov.b	#99,	r12	;#0x0063
    88dc:	1c 91 02 00 	cmp	2(r1),	r12	;
    88e0:	e8 2f       	jc	$-46     	;abs 0x88b2

000088e2 <.L34>:
	n_5=0;
	n_6=0;

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {
    88e2:	91 53 00 00 	inc	0(r1)		;

000088e6 <.L30>:
    88e6:	7c 40 06 00 	mov.b	#6,	r12	;
    88ea:	2c 91       	cmp	@r1,	r12	;
    88ec:	0e 2f       	jc	$-482    	;abs 0x870a

000088ee <.Loc.219.1>:
		}
	}
   //QWARK_CHECKPOINT();

#ifdef UART_DBG
		LED_CTRL = 0xBE;
    88ee:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    88f2:	fc 40 be ff 	mov.b	#65470,	0(r12)	;#0xffbe
    88f6:	00 00 

000088f8 <.Loc.220.1>:
	UART_WriteString("Benchmark Complete! \r\n");
    88f8:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    88fc:	b0 12 ce 8c 	call	#36046		;#0x8cce

00008900 <.Loc.221.1>:
		LED_CTRL = 0x00;
    8900:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8904:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

00008908 <.Loc.222.1>:
	UART_WriteNumber(n_0);
    8908:	1c 42 00 40 	mov	&0x4000,r12	;0x4000
    890c:	b0 12 1c 8c 	call	#35868		;#0x8c1c

00008910 <.Loc.223.1>:
		LED_CTRL = 0xE0;	
    8910:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8914:	fc 40 e0 ff 	mov.b	#65504,	0(r12)	;#0xffe0
    8918:	00 00 

0000891a <.Loc.224.1>:
	UART_WriteString("\r\n");
    891a:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    891e:	b0 12 ce 8c 	call	#36046		;#0x8cce

00008922 <.Loc.225.1>:
		LED_CTRL = 0x01;
    8922:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8926:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

0000892a <.Loc.226.1>:
	UART_WriteNumber(n_1);
    892a:	1c 42 02 40 	mov	&0x4002,r12	;0x4002
    892e:	b0 12 1c 8c 	call	#35868		;#0x8c1c

00008932 <.Loc.228.1>:
		
		LED_CTRL = 0xE1;	
    8932:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8936:	fc 40 e1 ff 	mov.b	#65505,	0(r12)	;#0xffe1
    893a:	00 00 

0000893c <.Loc.229.1>:
	UART_WriteString("\r\n");
    893c:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    8940:	b0 12 ce 8c 	call	#36046		;#0x8cce

00008944 <.Loc.230.1>:
		LED_CTRL = 0x02;
    8944:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8948:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000894c <.Loc.231.1>:
	UART_WriteNumber(n_2);
    894c:	1c 42 04 40 	mov	&0x4004,r12	;0x4004
    8950:	b0 12 1c 8c 	call	#35868		;#0x8c1c

00008954 <.Loc.233.1>:

		LED_CTRL = 0xE2;	
    8954:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8958:	fc 40 e2 ff 	mov.b	#65506,	0(r12)	;#0xffe2
    895c:	00 00 

0000895e <.Loc.234.1>:
	UART_WriteString("\r\n");
    895e:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    8962:	b0 12 ce 8c 	call	#36046		;#0x8cce

00008966 <.Loc.235.1>:
		LED_CTRL = 0x03;
    8966:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    896a:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    896e:	00 00 

00008970 <.Loc.236.1>:
	UART_WriteNumber(n_3);
    8970:	1c 42 06 40 	mov	&0x4006,r12	;0x4006
    8974:	b0 12 1c 8c 	call	#35868		;#0x8c1c

00008978 <.Loc.237.1>:
		LED_CTRL = 0xE3;	
    8978:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    897c:	fc 40 e3 ff 	mov.b	#65507,	0(r12)	;#0xffe3
    8980:	00 00 

00008982 <.Loc.238.1>:
	UART_WriteString("\r\n");
    8982:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    8986:	b0 12 ce 8c 	call	#36046		;#0x8cce

0000898a <.Loc.239.1>:
		LED_CTRL = 0x04;
    898a:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    898e:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10

00008992 <.Loc.240.1>:
	UART_WriteNumber(n_4);
    8992:	1c 42 08 40 	mov	&0x4008,r12	;0x4008
    8996:	b0 12 1c 8c 	call	#35868		;#0x8c1c

0000899a <.Loc.241.1>:
		LED_CTRL = 0xE4;	
    899a:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    899e:	fc 40 e4 ff 	mov.b	#65508,	0(r12)	;#0xffe4
    89a2:	00 00 

000089a4 <.Loc.242.1>:
	UART_WriteString("\r\n");
    89a4:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    89a8:	b0 12 ce 8c 	call	#36046		;#0x8cce

000089ac <.Loc.243.1>:
		LED_CTRL = 0x05;
    89ac:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    89b0:	fc 40 05 00 	mov.b	#5,	0(r12)	;
    89b4:	00 00 

000089b6 <.Loc.244.1>:
	UART_WriteNumber(n_5);
    89b6:	1c 42 0a 40 	mov	&0x400a,r12	;0x400a
    89ba:	b0 12 1c 8c 	call	#35868		;#0x8c1c

000089be <.Loc.245.1>:
		LED_CTRL = 0xE5;	
    89be:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    89c2:	fc 40 e5 ff 	mov.b	#65509,	0(r12)	;#0xffe5
    89c6:	00 00 

000089c8 <.Loc.246.1>:
	UART_WriteString("\r\n");
    89c8:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    89cc:	b0 12 ce 8c 	call	#36046		;#0x8cce

000089d0 <.Loc.247.1>:
		LED_CTRL = 0x06;
    89d0:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    89d4:	fc 40 06 00 	mov.b	#6,	0(r12)	;
    89d8:	00 00 

000089da <.Loc.248.1>:
	UART_WriteNumber(n_6);
    89da:	1c 42 0c 40 	mov	&0x400c,r12	;0x400c
    89de:	b0 12 1c 8c 	call	#35868		;#0x8c1c

000089e2 <.Loc.249.1>:
		LED_CTRL = 0xE6;	
    89e2:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    89e6:	fc 40 e6 ff 	mov.b	#65510,	0(r12)	;#0xffe6
    89ea:	00 00 

000089ec <.Loc.250.1>:
	UART_WriteString("\r\n");
    89ec:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    89f0:	b0 12 ce 8c 	call	#36046		;#0x8cce

000089f4 <.Loc.156.1>:

	/* Iterate through the 7 func statements 0 - 7*/
	/* Each statement executes a different bitcount routine, with a different seed value, a 100 times*/
	while(1){

	LED_CTRL ^= 0xFF;
    89f4:	30 40 d2 86 	br	#0x86d2		;

000089f8 <INT_Qwark>:
	//---------------------------------------------------------------------------------------------------------------------------------//
	//    CHECKPOINT SETUP: Identify which of the 2 checkpoint buffers should be written, one should always be consistent		   //
	//	  W.C. 18 CYCLES  													   //	 
	//	  B.C. 10 CYCLES 													   //
	//---------------------------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov r13, &0x6070"); 		//temporal r13: 4 cycles
    89f8:	82 4d 70 60 	mov	r13,	&0x6070	;

000089fc <.Loc.291.1>:
		__asm__ __volatile__ ("mov r12, &0x6072"); 		//temporal r12: 4 cycles
    89fc:	82 4c 72 60 	mov	r12,	&0x6072	;

00008a00 <.Loc.293.1>:

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075"); 		//4 cycles
    8a00:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

00008a04 <.Loc.294.1>:
		__asm__ __volatile__ ("jz __second_buffer_init");	//2 cycles
    8a04:	06 24       	jz	$+14     	;abs 0x8a12

00008a06 <.Loc.296.1>:

		__asm__ __volatile__ ("mov #0x6010, r12"); 		//Load the base pointer of the first checkpoint buffer: 2 cycles
    8a06:	3c 40 10 60 	mov	#24592,	r12	;#0x6010

00008a0a <.Loc.297.1>:
		__asm__ __volatile__ ("mov.b #0x01,&0x6074");		//4 cycles
    8a0a:	d2 43 74 60 	mov.b	#1,	&0x6074	;r3 As==01

00008a0e <.Loc.298.1>:
		__asm__ __volatile__ ("br #__first_phase_commit");	//2 cycles
    8a0e:	30 40 16 8a 	br	#0x8a16		;

00008a12 <__second_buffer_init>:

		__asm__ __volatile__ ("__second_buffer_init:");

		__asm__ __volatile__ ("mov #0x6040, r12"); 		//Load the base pointer of the second checkpoint buffer: 2 cycles
    8a12:	3c 40 40 60 	mov	#24640,	r12	;#0x6040

00008a16 <__first_phase_commit>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 2(r1),@r12"); 	//PC/R0   6 cycles
    8a16:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    8a1a:	00 00 

00008a1c <.Loc.321.1>:
		__asm__ __volatile__ ("incd r12");		//	  1 cycle
    8a1c:	2c 53       	incd	r12		;

00008a1e <.Loc.327.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark  - 3 cycles
		//__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles	

		__asm__ __volatile__ ("mov r1,@r12");   	//SP/R1   4 cycles
    8a1e:	8c 41 00 00 	mov	r1,	0(r12)	;

00008a22 <.Loc.328.1>:
		__asm__ __volatile__ ("add #0x04,@r12");	//	  5 cycles
    8a22:	ac 52 00 00 	add	#4,	0(r12)	;r2 As==10

00008a26 <.Loc.329.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8a26:	2c 53       	incd	r12		;

00008a28 <.Loc.335.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 0(r1),@r12"); 	//SR/R2   6 cycles
    8a28:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008a2c <.Loc.336.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8a2c:	2c 53       	incd	r12		;

00008a2e <.Loc.338.1>:

		__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark and signal a buffer reset without modifying the data - 3 cycles
    8a2e:	1d 42 a0 02 	mov	&0x02a0,r13	;0x02a0

00008a32 <.Loc.339.1>:
		__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
    8a32:	3d f0 3e 00 	and	#62,	r13	;#0x003e

00008a36 <.Loc.340.1>:
		__asm__ __volatile__ ("bis #0x40,r13"); 	//	  2 cycles
    8a36:	3d d0 40 00 	bis	#64,	r13	;#0x0040

00008a3a <.Loc.341.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    8a3a:	82 4d a0 02 	mov	r13,	&0x02a0	;

00008a3e <.Loc.342.1>:
		__asm__ __volatile__ ("and #0xBF,r13"); 	//	  2 cycles
    8a3e:	3d f0 bf 00 	and	#191,	r13	;#0x00bf

00008a42 <.Loc.343.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    8a42:	82 4d a0 02 	mov	r13,	&0x02a0	;

00008a46 <.Loc.345.1>:

		__asm__ __volatile__ ("mov r4,@r12"); 		//R4	  4 cycles
    8a46:	8c 44 00 00 	mov	r4,	0(r12)	;

00008a4a <.Loc.346.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8a4a:	2c 53       	incd	r12		;

00008a4c <.Loc.348.1>:

		__asm__ __volatile__ ("mov r5,@r12"); 		//R5	  4 cycles
    8a4c:	8c 45 00 00 	mov	r5,	0(r12)	;

00008a50 <.Loc.349.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    8a50:	2c 53       	incd	r12		;

00008a52 <.Loc.351.1>:

		__asm__ __volatile__ ("mov r6,@r12"); 		//R6	  4 cycles
    8a52:	8c 46 00 00 	mov	r6,	0(r12)	;

00008a56 <.Loc.352.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    8a56:	2c 53       	incd	r12		;

00008a58 <.Loc.354.1>:

		__asm__ __volatile__ ("mov r7,@r12"); 		//R7	  4 cycles
    8a58:	8c 47 00 00 	mov	r7,	0(r12)	;

00008a5c <.Loc.355.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a5c:	2c 53       	incd	r12		;

00008a5e <.Loc.357.1>:

		__asm__ __volatile__ ("mov r8,@r12"); 		//R8	  4 cycles
    8a5e:	8c 48 00 00 	mov	r8,	0(r12)	;

00008a62 <.Loc.358.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a62:	2c 53       	incd	r12		;

00008a64 <.Loc.360.1>:

		__asm__ __volatile__ ("mov r9,@r12"); 		//R9	  4 cycles
    8a64:	8c 49 00 00 	mov	r9,	0(r12)	;

00008a68 <.Loc.361.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a68:	2c 53       	incd	r12		;

00008a6a <.Loc.363.1>:

		__asm__ __volatile__ ("mov r10,@r12"); 		//R10	  4 cycles
    8a6a:	8c 4a 00 00 	mov	r10,	0(r12)	;

00008a6e <.Loc.364.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a6e:	2c 53       	incd	r12		;

00008a70 <.Loc.366.1>:

		__asm__ __volatile__ ("mov r11,@r12"); 		//R11	  4 cycles
    8a70:	8c 4b 00 00 	mov	r11,	0(r12)	;

00008a74 <.Loc.367.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a74:	2c 53       	incd	r12		;

00008a76 <.Loc.369.1>:

		__asm__ __volatile__ ("mov &0x6072,@r12"); 	//R12	  6 cycles
    8a76:	9c 42 72 60 	mov	&0x6072,0(r12)	;0x6072
    8a7a:	00 00 

00008a7c <.Loc.370.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a7c:	2c 53       	incd	r12		;

00008a7e <.Loc.372.1>:

		__asm__ __volatile__ ("mov &0x6070,@r12"); 	//R13	  4 cycles
    8a7e:	9c 42 70 60 	mov	&0x6070,0(r12)	;0x6070
    8a82:	00 00 

00008a84 <.Loc.373.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a84:	2c 53       	incd	r12		;

00008a86 <.Loc.375.1>:

		__asm__ __volatile__ ("mov r14,@r12"); 		//R14	  4 cycles
    8a86:	8c 4e 00 00 	mov	r14,	0(r12)	;

00008a8a <.Loc.376.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a8a:	2c 53       	incd	r12		;

00008a8c <.Loc.378.1>:

		__asm__ __volatile__ ("mov r15,@r12"); 		//R15	  4 cycles
    8a8c:	8c 4f 00 00 	mov	r15,	0(r12)	;

00008a90 <.Loc.379.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8a90:	2c 53       	incd	r12		;

00008a92 <.Loc.387.1>:
		//    WAR VIOLATION INDEX CHECKPOINT: Get the index indicating the amount of violations stored 				   //
		//	  10 CYCLES																								   //
		//																											   //
		//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("mov &0x02A0, r14");	// 		  3 cycles
    8a92:	1e 42 a0 02 	mov	&0x02a0,r14	;0x02a0

00008a96 <.Loc.388.1>:
		__asm__ __volatile__ ("RRA r14");			// 		  1 cycle
    8a96:	0e 11       	rra	r14		;

00008a98 <.Loc.389.1>:
		__asm__ __volatile__ ("mov.b r14, @r12");	// 		  4 cycles
    8a98:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00008a9c <.Loc.390.1>:
		__asm__ __volatile__ ("mov r14, r15 ");		// 		  1 cycle (save the index for later)
    8a9c:	0f 4e       	mov	r14,	r15	;

00008a9e <.Loc.391.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 Cycle
    8a9e:	2c 53       	incd	r12		;

00008aa0 <.Loc.401.1>:
		//	  B.C.	 5 CYCLES FOR EMPTY TLB																			   //
		//-------------------------------------------------------------------------------------------------------------//

		/* Setup registers for copy*/

		__asm__ __volatile__ ("tst r14 ");     	    // 		  1 cycle
    8aa0:	0e 93       	cmp	#0,	r14	;r3 As==00

00008aa2 <.Loc.402.1>:
		__asm__ __volatile__ ("jz  __second_phase_start");	// 		  2 cycles
    8aa2:	08 24       	jz	$+18     	;abs 0x8ab4

00008aa4 <.Loc.404.1>:

		__asm__ __volatile__ ("mov #0x02A2, r13");	// 		  2 cycles
    8aa4:	3d 40 a2 02 	mov	#674,	r13	;#0x02a2

00008aa8 <_scratchpad_addr_cpy>:

		__asm__ __volatile__ ("_scratchpad_addr_cpy:");   // Each iteration takes 10 cycles - Worst case 70 cycles

		__asm__ __volatile__ ("mov @r13+2, @r12");  // 		  5 cycles
    8aa8:	bc 4d 00 00 	mov	@r13+,	0(r12)	;

00008aac <.Loc.409.1>:
		__asm__ __volatile__ ("incd r12");  		// 		  1 cycle
    8aac:	2c 53       	incd	r12		;

00008aae <.Loc.410.1>:
		__asm__ __volatile__ ("dec r14 ");      	// 		  1 cycle
    8aae:	1e 83       	dec	r14		;

00008ab0 <.Loc.411.1>:
		__asm__ __volatile__ ("tst r14 ");     		// 		  1 cycle
    8ab0:	0e 93       	cmp	#0,	r14	;r3 As==00

00008ab2 <.Loc.412.1>:
		__asm__ __volatile__ ("jnz  _scratchpad_addr_cpy");// 2 cycles
    8ab2:	fa 23       	jnz	$-10     	;abs 0x8aa8

00008ab4 <__second_phase_start>:
	//    END OF THE FIRST PHASE: Atomic Flag Handling for halfway through checkpoint							   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("__second_phase_start:");

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075");		 // 4 cycles
    8ab4:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

00008ab8 <.Loc.460.1>:
		__asm__ __volatile__ ("jz  __set_flag_2nd ");		 // 2 cycles
    8ab8:	04 24       	jz	$+10     	;abs 0x8ac2

00008aba <.Loc.462.1>:

		__asm__ __volatile__ ("add.b #0x01, &0x6074 "); 	 //4 cycles
    8aba:	d2 53 74 60 	inc.b	&0x6074		;

00008abe <.Loc.463.1>:
		__asm__ __volatile__ ("br  #_second_phase_commit "); //4 cycles
    8abe:	30 40 c6 8a 	br	#0x8ac6		;

00008ac2 <__set_flag_2nd>:

		__asm__ __volatile__ ("__set_flag_2nd:");
		__asm__ __volatile__ ("add.b #0x01, &0x6075 "); 	 // 4 cycles		/* after setting this bit, THE RESTORE ROUTINE CAN FINALIZE THIS HALFWAY CHECKPOINT  */
    8ac2:	d2 53 75 60 	inc.b	&0x6075		;

00008ac6 <_second_phase_commit>:
	//	  ASSUMMING ONLY WORD ADDRESSING. 																		   //
	//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("_second_phase_commit:");

		__asm__ __volatile__ ("tst r15 ");     		         // 1 cycle
    8ac6:	0f 93       	cmp	#0,	r15	;r3 As==00

00008ac8 <.Loc.477.1>:
		__asm__ __volatile__ ("jz  _chkpt_finished");		 // 2 cycles
    8ac8:	23 24       	jz	$+72     	;abs 0x8b10

00008aca <.Loc.479.1>:

		__asm__ __volatile__ ("mov #0x6000,  r14 ");		 // 2 cycles
    8aca:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008ace <.Loc.481.1>:

		__asm__ __volatile__ ("mov #0x6060,  r12 ");		 // 2 cycles
    8ace:	3c 40 60 60 	mov	#24672,	r12	;#0x6060

00008ad2 <.Loc.482.1>:
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");		 // 4 cycles
    8ad2:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008ad6 <.Loc.483.1>:
		__asm__ __volatile__ ("jz _second_phase_commit_strt");   // 2 cycles
    8ad6:	02 24       	jz	$+6      	;abs 0x8adc

00008ad8 <.Loc.485.1>:

		__asm__ __volatile__ ("mov #0x6030,  r12 ");		 // 2 cycles
    8ad8:	3c 40 30 60 	mov	#24624,	r12	;#0x6030

00008adc <_second_phase_commit_strt>:


		__asm__ __volatile__ ("_second_phase_commit_strt:"); 	 // Worst case

		__asm__ __volatile__ ("mov @r12+2,  r13 ");   		 // 3 cycles
    8adc:	3d 4c       	mov	@r12+,	r13	;

00008ade <.Loc.492.1>:

		__asm__ __volatile__ ("mov r13,  r11 ");   		 // 1 cycle
    8ade:	0b 4d       	mov	r13,	r11	;

00008ae0 <.Loc.494.1>:

		__asm__ __volatile__ ("and #0x8000,  r11 ");   		 // 2 cycles
    8ae0:	3b f0 00 80 	and	#32768,	r11	;#0x8000

00008ae4 <.Loc.495.1>:
		__asm__ __volatile__ ("cmp #0x8000,  r11 ");   		 // 2 cycles
    8ae4:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

00008ae8 <.Loc.496.1>:
		__asm__ __volatile__ ("jeq _byte_copy ");   		 // 2 cycles
    8ae8:	08 24       	jz	$+18     	;abs 0x8afa

00008aea <.Loc.507.1>:
	
		//__asm__ __volatile__ ("incd r10 	  ");    	 // 1 cycle
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		 // 1 cycle - verify that the redirected value corresponds to the current PC return value
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	 // 2 cycles
  
		__asm__ __volatile__ ("mov @r14, @r13 ");    		 // 5 cycles
    8aea:	ad 4e 00 00 	mov	@r14,	0(r13)	;

00008aee <_pre_end_copy>:

		__asm__ __volatile__ ("_pre_end_copy:");
		__asm__ __volatile__ ("incd r14");    			 // 1 cycle
    8aee:	2e 53       	incd	r14		;

00008af0 <.Loc.511.1>:
		__asm__ __volatile__ ("dec r15");    			 // 1 cycle
    8af0:	1f 83       	dec	r15		;

00008af2 <.Loc.512.1>:
		__asm__ __volatile__ ("tst r15");    			 // 1 cycle
    8af2:	0f 93       	cmp	#0,	r15	;r3 As==00

00008af4 <.Loc.514.1>:

		__asm__ __volatile__ ("jnz  _second_phase_commit_strt"); // 2 cycles
    8af4:	f3 23       	jnz	$-24     	;abs 0x8adc

00008af6 <.Loc.515.1>:
		__asm__ __volatile__ ("br #_chkpt_finished");		 // 2 cycles
    8af6:	30 40 10 8b 	br	#0x8b10		;

00008afa <_byte_copy>:

		__asm__ __volatile__ ("_byte_copy:");
		__asm__ __volatile__ ("and #0x7FFF,  r13 ");   		// mask the highest bit - 2 cycles
    8afa:	3d f0 ff 7f 	and	#32767,	r13	;#0x7fff

00008afe <.Loc.519.1>:
		__asm__ __volatile__ ("mov r13,      r11 ");   		// 1 cycle
    8afe:	0b 4d       	mov	r13,	r11	;

00008b00 <.Loc.520.1>:
		__asm__ __volatile__ ("and #0x01,    r11 ");   		// detect if its a byte write - 1 cycle
    8b00:	1b f3       	and	#1,	r11	;r3 As==01

00008b02 <.Loc.521.1>:
		__asm__ __volatile__ ("bis  r11,     r14 ");   		// detect if its a byte write - 1 cycle
    8b02:	0e db       	bis	r11,	r14	;

00008b04 <.Loc.533.1>:
		//__asm__ __volatile__ ("incd r10 	  ");    	// 1 cycle							
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		// 1 cycle - verify that the PC will not be overwritten by a previous violation (Discard it)
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	// 2 cycles


		__asm__ __volatile__ ("mov.b @r14, @r13 ");    				// 5 cycles
    8b04:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00008b08 <.Loc.535.1>:

		__asm__ __volatile__ ("incd r14");    				 		// 1 cycle
    8b08:	2e 53       	incd	r14		;

00008b0a <.Loc.536.1>:
		__asm__ __volatile__ ("dec r15");    						// 1 cycles
    8b0a:	1f 83       	dec	r15		;

00008b0c <.Loc.537.1>:
		__asm__ __volatile__ ("tst r15");    						// 1 cycles
    8b0c:	0f 93       	cmp	#0,	r15	;r3 As==00

00008b0e <.Loc.538.1>:
		__asm__ __volatile__ ("jnz  _second_phase_commit_strt");	// 2 cycles
    8b0e:	e6 23       	jnz	$-50     	;abs 0x8adc

00008b10 <_chkpt_finished>:
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("_chkpt_finished:");


	    /* Set second phase complete Bit - Atomic Flag*/
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");			//4 cycles
    8b10:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008b14 <.Loc.549.1>:
		__asm__ __volatile__ ("jeq  __pre_finish_2nd_buffer "); //2 cycles
    8b14:	11 24       	jz	$+36     	;abs 0x8b38

00008b16 <.Loc.551.1>:

		__asm__ __volatile__ ("mov #0x0103, &0x6074 "); //5 cycles	/* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 1ST CHECKPOINT COMPLETELY  */
    8b16:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    8b1a:	74 60 

00008b1c <.Loc.557.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//																											   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6022,r10"); 		//3 cycles
    8b1c:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

00008b20 <.Loc.558.1>:
		__asm__ __volatile__ ("mov &0x6024,r11"); 		//3 cycles
    8b20:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

00008b24 <.Loc.559.1>:
		__asm__ __volatile__ ("mov &0x6026,r12"); 		//3 cycles
    8b24:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

00008b28 <.Loc.560.1>:
		__asm__ __volatile__ ("mov &0x6028,r13"); 	    //3 cycles
    8b28:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00008b2c <.Loc.561.1>:
		__asm__ __volatile__ ("mov &0x602A,r14"); 	    //3 cycles
    8b2c:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

00008b30 <.Loc.562.1>:
		__asm__ __volatile__ ("mov &0x602C,r15"); 	    //3 cycles
    8b30:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

00008b34 <.Loc.564.1>:

		__asm__ __volatile__ ("br #_finish"); 	   		//3 cycles
    8b34:	30 40 56 8b 	br	#0x8b56		;

00008b38 <__pre_finish_2nd_buffer>:

		__asm__ __volatile__ ("__pre_finish_2nd_buffer:");

		__asm__ __volatile__ ("mov #0x0301, &0x6074 "); //4 cycles /* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 2ND CHECKPOINT COMPLETELY  */
    8b38:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    8b3c:	74 60 

00008b3e <.Loc.573.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6052,r10"); 	    //3 cycles		
    8b3e:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

00008b42 <.Loc.574.1>:
		__asm__ __volatile__ ("mov &0x6054,r11"); 	    //3 cycles
    8b42:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

00008b46 <.Loc.575.1>:
		__asm__ __volatile__ ("mov &0x6056,r12"); 	    //3 cycles
    8b46:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

00008b4a <.Loc.576.1>:
		__asm__ __volatile__ ("mov &0x6058,r13"); 	    //3 cycles
    8b4a:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

00008b4e <.Loc.577.1>:
		__asm__ __volatile__ ("mov &0x605A,r14"); 	    //3 cycles
    8b4e:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

00008b52 <.Loc.578.1>:
		__asm__ __volatile__ ("mov &0x605C,r15"); 	    //3 cycles
    8b52:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

00008b56 <_finish>:

		__asm__ __volatile__ ("_finish:");
		/* Clear the counters, and re-enable Idempotency tracking*/
		__asm__ __volatile__ ("mov #0x0000, &0x6000");	//4 cycles
    8b56:	82 43 00 60 	mov	#0,	&0x6000	;r3 As==00

00008b5a <.Loc.583.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6002");	//4 cycles
    8b5a:	82 43 02 60 	mov	#0,	&0x6002	;r3 As==00

00008b5e <.Loc.584.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6004");	//4 cycles
    8b5e:	82 43 04 60 	mov	#0,	&0x6004	;r3 As==00

00008b62 <.Loc.585.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6006");	//4 cycles
    8b62:	82 43 06 60 	mov	#0,	&0x6006	;r3 As==00

00008b66 <.Loc.586.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6008");	//4 cycles
    8b66:	82 43 08 60 	mov	#0,	&0x6008	;r3 As==00

00008b6a <.Loc.587.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600A");	//4 cycles
    8b6a:	82 43 0a 60 	mov	#0,	&0x600a	;r3 As==00

00008b6e <.Loc.588.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600C");	//4 cycles
    8b6e:	82 43 0c 60 	mov	#0,	&0x600c	;r3 As==00

00008b72 <.Loc.589.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600E");	//4 cycles
    8b72:	82 43 0e 60 	mov	#0,	&0x600e	;r3 As==00

00008b76 <.Loc.591.1>:

		__asm__ __volatile__ ("mov #0x0000, &0x02A2");	//4 cycles
    8b76:	82 43 a2 02 	mov	#0,	&0x02a2	;r3 As==00

00008b7a <.Loc.592.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A4");	//4 cycles
    8b7a:	82 43 a4 02 	mov	#0,	&0x02a4	;r3 As==00

00008b7e <.Loc.593.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A6");	//4 cycles
    8b7e:	82 43 a6 02 	mov	#0,	&0x02a6	;r3 As==00

00008b82 <.Loc.594.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A8");	//4 cycles
    8b82:	82 43 a8 02 	mov	#0,	&0x02a8	;r3 As==00

00008b86 <.Loc.595.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AA");	//4 cycles
    8b86:	82 43 aa 02 	mov	#0,	&0x02aa	;r3 As==00

00008b8a <.Loc.596.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AC");	//4 cycles
    8b8a:	82 43 ac 02 	mov	#0,	&0x02ac	;r3 As==00

00008b8e <.Loc.597.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AE");	//4 cycles
    8b8e:	82 43 ae 02 	mov	#0,	&0x02ae	;r3 As==00

00008b92 <.Loc.598.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02B0");	//4 cycles
    8b92:	82 43 b0 02 	mov	#0,	&0x02b0	;r3 As==00

00008b96 <.Loc.604.1>:

		//Test software to measure the amount of checkpoints

		//__asm__ __volatile__ ("add #0x01, &0x6076");	//4 cycles

		__asm__ __volatile__ ("mov #0x0001, &0x02A0");	//4 cycles
    8b96:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008b9a <.Loc.608.1>:



}
    8b9a:	03 43       	nop			
    8b9c:	00 13       	reti			

00008b9e <ta_wait_no_lpm>:
//    TA_WAIT_NO_LPM                                 //
// ( the function implements a wait by continously ) //
// ( polling the TAR register                      ) //
//                                                   //
//---------------------------------------------------//
void ta_wait_no_lpm(unsigned int time_cnt) {
    8b9e:	21 83       	decd	r1		;

00008ba0 <.LCFI0>:
    8ba0:	81 4c 00 00 	mov	r12,	0(r1)	;

00008ba4 <.Loc.14.1>:

  // Start and re-initialize TimerA
  TACTL = TASSEL0 | TACLR | MC_2;
    8ba4:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    8ba8:	bc 40 24 01 	mov	#292,	0(r12)	;#0x0124
    8bac:	00 00 

00008bae <.Loc.17.1>:

  // Wait until time is over
  while(TAR < time_cnt);
    8bae:	03 43       	nop			

00008bb0 <.L2>:
    8bb0:	3c 40 70 01 	mov	#368,	r12	;#0x0170
    8bb4:	2c 4c       	mov	@r12,	r12	;
    8bb6:	2c 91       	cmp	@r1,	r12	;
    8bb8:	fb 2b       	jnc	$-8      	;abs 0x8bb0

00008bba <.Loc.19.1>:

}
    8bba:	03 43       	nop			
    8bbc:	21 53       	incd	r1		;
    8bbe:	30 41       	ret			

00008bc0 <ta_wait>:
// ( the function brings the core to LPM0 state )   //
// ( the timerA IRQ will exit the LPM0 state    )   //
//                                                  //
//--------------------------------------------------//
unsigned int periodic_val;
void ta_wait(unsigned int time_cnt) {
    8bc0:	21 83       	decd	r1		;

00008bc2 <.LCFI1>:
    8bc2:	81 4c 00 00 	mov	r12,	0(r1)	;

00008bc6 <.Loc.31.1>:

  // Set time limit for IRQ generation
  TACCR0 = time_cnt;
    8bc6:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    8bca:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008bce <.Loc.32.1>:
  periodic_val = time_cnt;
    8bce:	a2 41 20 41 	mov	@r1,	&0x4120	;

00008bd2 <.Loc.34.1>:
  // Start and re-initialize TimerA
  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    8bd2:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    8bd6:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    8bda:	00 00 

00008bdc <.Loc.39.1>:

  // Go to Low-Power-Mode 0
  //LPM0;

}
    8bdc:	03 43       	nop			
    8bde:	21 53       	incd	r1		;
    8be0:	30 41       	ret			

00008be2 <INT_timerA1>:

//--------------------------------------------------//
//    TIMER A INTERRUPT                             //
//--------------------------------------------------//
wakeup interrupt (TIMERA1_VECTOR) INT_timerA1(void) {
    8be2:	0c 12       	push	r12		;

00008be4 <.LCFI2>:


      //Force Reset
	  WDTCTL = 0;
    8be4:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    8be8:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00008bec <.Loc.60.1>:
	  //TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;

	  //QWARK_CHECKPOINT();


}
    8bec:	03 43       	nop			
    8bee:	b1 c0 f0 00 	bic	#240,	2(r1)	;#0x00f0
    8bf2:	02 00 
    8bf4:	3c 41       	pop	r12		;
    8bf6:	00 13       	reti			

00008bf8 <UART_WriteChar>:

//--------------------------------------------------//
//                 tty_putc function                 //
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {
    8bf8:	21 83       	decd	r1		;

00008bfa <.LCFI0>:
    8bfa:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00008bfe <.Loc.19.1>:

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    8bfe:	03 43       	nop			

00008c00 <.L2>:
    8c00:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081
    8c04:	6c 4c       	mov.b	@r12,	r12	;
    8c06:	7c f2       	and.b	#8,	r12	;r2 As==11
    8c08:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c0a:	fa 23       	jnz	$-10     	;abs 0x8c00

00008c0c <.Loc.22.1>:

  // Write the output character
  UART_TXD = txdata;
    8c0c:	7c 40 84 00 	mov.b	#132,	r12	;#0x0084
    8c10:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    8c14:	00 00 

00008c16 <.Loc.24.1>:

  return 0;
    8c16:	4c 43       	clr.b	r12		;

00008c18 <.Loc.25.1>:
}
    8c18:	21 53       	incd	r1		;
    8c1a:	30 41       	ret			

00008c1c <UART_WriteNumber>:


void UART_WriteNumber (int n)
{
    8c1c:	31 80 18 00 	sub	#24,	r1	;#0x0018

00008c20 <.LCFI1>:
    8c20:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c24 <.Loc.31.1>:
  char buf[20];
  int i = 0;
    8c24:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00008c28 <.Loc.32.1>:
  if (n < 0)
    8c28:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    8c2c:	25 34       	jge	$+76     	;abs 0x8c78

00008c2e <.Loc.34.1>:
    {
	  UART_WriteChar ('-');
    8c2e:	7c 40 2d 00 	mov.b	#45,	r12	;#0x002d
    8c32:	b0 12 f8 8b 	call	#35832		;#0x8bf8

00008c36 <.Loc.35.1>:
      n = -n;
    8c36:	4c 43       	clr.b	r12		;
    8c38:	2c 81       	sub	@r1,	r12	;
    8c3a:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c3e <.Loc.37.1>:
    }
  while (n > 9)
    8c3e:	30 40 78 8c 	br	#0x8c78		;

00008c42 <.L7>:
    {
      buf[i++] = (n%10) + '0';
    8c42:	2c 41       	mov	@r1,	r12	;
    8c44:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8c48:	b0 12 8e 8d 	call	#36238		;#0x8d8e
    8c4c:	4d 4c       	mov.b	r12,	r13	;
    8c4e:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    8c52:	0e 4c       	mov	r12,	r14	;
    8c54:	1e 53       	inc	r14		;
    8c56:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    8c5a:	7d 50 30 00 	add.b	#48,	r13	;#0x0030
    8c5e:	4e 4d       	mov.b	r13,	r14	;
    8c60:	0d 41       	mov	r1,	r13	;
    8c62:	2d 53       	incd	r13		;
    8c64:	0c 5d       	add	r13,	r12	;
    8c66:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00008c6a <.Loc.40.1>:
      n /= 10;
    8c6a:	2c 41       	mov	@r1,	r12	;
    8c6c:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8c70:	b0 12 42 8d 	call	#36162		;#0x8d42
    8c74:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c78 <.L6>:
  if (n < 0)
    {
	  UART_WriteChar ('-');
      n = -n;
    }
  while (n > 9)
    8c78:	7c 40 09 00 	mov.b	#9,	r12	;
    8c7c:	2c 91       	cmp	@r1,	r12	;
    8c7e:	e1 3b       	jl	$-60     	;abs 0x8c42

00008c80 <.Loc.42.1>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
    8c80:	2c 41       	mov	@r1,	r12	;
    8c82:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8c86:	b0 12 8e 8d 	call	#36238		;#0x8d8e
    8c8a:	4d 4c       	mov.b	r12,	r13	;
    8c8c:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    8c90:	0e 4c       	mov	r12,	r14	;
    8c92:	1e 53       	inc	r14		;
    8c94:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    8c98:	7d 50 30 00 	add.b	#48,	r13	;#0x0030
    8c9c:	4e 4d       	mov.b	r13,	r14	;
    8c9e:	0d 41       	mov	r1,	r13	;
    8ca0:	2d 53       	incd	r13		;
    8ca2:	0c 5d       	add	r13,	r12	;
    8ca4:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00008ca8 <.Loc.43.1>:
  while (i > 0)
    8ca8:	30 40 be 8c 	br	#0x8cbe		;

00008cac <.L9>:
	  UART_WriteChar (buf[--i]);
    8cac:	b1 53 16 00 	add	#-1,	22(r1)	;r3 As==11, 0x0016
    8cb0:	0c 41       	mov	r1,	r12	;
    8cb2:	2c 53       	incd	r12		;
    8cb4:	1c 51 16 00 	add	22(r1),	r12	;0x00016
    8cb8:	6c 4c       	mov.b	@r12,	r12	;
    8cba:	b0 12 f8 8b 	call	#35832		;#0x8bf8

00008cbe <.L8>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
  while (i > 0)
    8cbe:	4c 43       	clr.b	r12		;
    8cc0:	1c 91 16 00 	cmp	22(r1),	r12	;0x00016
    8cc4:	f3 3b       	jl	$-24     	;abs 0x8cac

00008cc6 <.Loc.45.1>:
	  UART_WriteChar (buf[--i]);
}
    8cc6:	03 43       	nop			
    8cc8:	31 50 18 00 	add	#24,	r1	;#0x0018
    8ccc:	30 41       	ret			

00008cce <UART_WriteString>:
/* This function prints a string of characters on the UART. The usage of this function is mostly    */
/* for debugging purposes.                                                                          */
/* Parameter(s)                                                                                     */
/* string      string of characters that will be printed through the UART                           */

void UART_WriteString(char* string){
    8cce:	21 82       	sub	#4,	r1	;r2 As==10

00008cd0 <.LCFI2>:
    8cd0:	81 4c 00 00 	mov	r12,	0(r1)	;

00008cd4 <.Loc.54.1>:

    char i = 0;
    8cd4:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00008cd8 <.Loc.57.1>:

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    8cd8:	30 40 f0 8c 	br	#0x8cf0		;

00008cdc <.L12>:
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);
    8cdc:	5c 41 03 00 	mov.b	3(r1),	r12	;
    8ce0:	4d 4c       	mov.b	r12,	r13	;
    8ce2:	5d 53       	inc.b	r13		;
    8ce4:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    8ce8:	2c 51       	add	@r1,	r12	;
    8cea:	6c 4c       	mov.b	@r12,	r12	;
    8cec:	b0 12 f8 8b 	call	#35832		;#0x8bf8

00008cf0 <.L11>:
void UART_WriteString(char* string){

    char i = 0;

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    8cf0:	5c 41 03 00 	mov.b	3(r1),	r12	;
    8cf4:	2c 51       	add	@r1,	r12	;
    8cf6:	6c 4c       	mov.b	@r12,	r12	;
    8cf8:	0c 93       	cmp	#0,	r12	;r3 As==00
    8cfa:	f0 23       	jnz	$-30     	;abs 0x8cdc

00008cfc <.Loc.63.1>:
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);

    }
 }
    8cfc:	03 43       	nop			
    8cfe:	21 52       	add	#4,	r1	;r2 As==10
    8d00:	30 41       	ret			

00008d02 <udivmodhi4>:
    8d02:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011

00008d06 <.Loc.35.1>:
    8d06:	5b 43       	mov.b	#1,	r11	;r3 As==01

00008d08 <.L2>:
    8d08:	0d 9c       	cmp	r12,	r13	;
    8d0a:	08 28       	jnc	$+18     	;abs 0x8d1c

00008d0c <.L15>:
    8d0c:	4f 43       	clr.b	r15		;

00008d0e <.L4>:
    8d0e:	0b 93       	cmp	#0,	r11	;r3 As==00
    8d10:	0e 20       	jnz	$+30     	;abs 0x8d2e

00008d12 <.L5>:
    8d12:	0e 93       	cmp	#0,	r14	;r3 As==00
    8d14:	01 24       	jz	$+4      	;abs 0x8d18
    8d16:	0f 4c       	mov	r12,	r15	;

00008d18 <.L1>:
    8d18:	0c 4f       	mov	r15,	r12	;
    8d1a:	30 41       	ret			

00008d1c <.L3>:
    8d1c:	3f 53       	add	#-1,	r15	;r3 As==11

00008d1e <.Loc.38.1>:
    8d1e:	0f 93       	cmp	#0,	r15	;r3 As==00
    8d20:	f8 27       	jz	$-14     	;abs 0x8d12

00008d22 <.Loc.38.1>:
    8d22:	0d 93       	cmp	#0,	r13	;r3 As==00
    8d24:	f3 3b       	jl	$-24     	;abs 0x8d0c

00008d26 <.Loc.40.1>:
    8d26:	0d 5d       	rla	r13		;

00008d28 <.Loc.41.1>:
    8d28:	0b 5b       	rla	r11		;
    8d2a:	30 40 08 8d 	br	#0x8d08		;

00008d2e <.L9>:
    8d2e:	0c 9d       	cmp	r13,	r12	;
    8d30:	02 28       	jnc	$+6      	;abs 0x8d36

00008d32 <.Loc.47.1>:
    8d32:	0c 8d       	sub	r13,	r12	;

00008d34 <.Loc.48.1>:
    8d34:	0f db       	bis	r11,	r15	;

00008d36 <.L8>:
    8d36:	12 c3       	clrc			
    8d38:	0b 10       	rrc	r11		;

00008d3a <.Loc.51.1>:
    8d3a:	12 c3       	clrc			
    8d3c:	0d 10       	rrc	r13		;
    8d3e:	30 40 0e 8d 	br	#0x8d0e		;

00008d42 <__mspabi_divi>:
    8d42:	0a 12       	push	r10		;

00008d44 <.LCFI0>:
    8d44:	0f 4c       	mov	r12,	r15	;
    8d46:	0e 4d       	mov	r13,	r14	;

00008d48 <.LVL14>:
    8d48:	3b 40 02 8d 	mov	#36098,	r11	;#0x8d02

00008d4c <.Loc.64.1>:
    8d4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d4e:	1a 34       	jge	$+54     	;abs 0x8d84

00008d50 <.Loc.66.1>:
    8d50:	4c 43       	clr.b	r12		;

00008d52 <.LVL15>:
    8d52:	0c 8f       	sub	r15,	r12	;
    8d54:	0f 4c       	mov	r12,	r15	;

00008d56 <.LVL16>:
    8d56:	0d 93       	cmp	#0,	r13	;r3 As==00
    8d58:	0d 34       	jge	$+28     	;abs 0x8d74

00008d5a <.Loc.67.1>:
    8d5a:	5a 43       	mov.b	#1,	r10	;r3 As==01

00008d5c <.L21>:
    8d5c:	0d 43       	clr	r13		;
    8d5e:	0d 8e       	sub	r14,	r13	;

00008d60 <.LVL18>:
    8d60:	4e 43       	clr.b	r14		;

00008d62 <.LVL19>:
    8d62:	0c 4f       	mov	r15,	r12	;

00008d64 <.LVL20>:
    8d64:	8b 12       	call	r11		;

00008d66 <.LVL21>:
    8d66:	1a 93       	cmp	#1,	r10	;r3 As==01
    8d68:	03 24       	jz	$+8      	;abs 0x8d70

00008d6a <.L20>:
    8d6a:	4d 43       	clr.b	r13		;
    8d6c:	0d 8c       	sub	r12,	r13	;
    8d6e:	0c 4d       	mov	r13,	r12	;

00008d70 <.L16>:
    8d70:	3a 41       	pop	r10		;
    8d72:	30 41       	ret			

00008d74 <.L18>:
    8d74:	4e 43       	clr.b	r14		;
    8d76:	8b 12       	call	r11		;

00008d78 <.LVL25>:
    8d78:	30 40 6a 8d 	br	#0x8d6a		;

00008d7c <.L27>:
    8d7c:	4e 43       	clr.b	r14		;
    8d7e:	8b 12       	call	r11		;

00008d80 <.LVL27>:
    8d80:	30 40 70 8d 	br	#0x8d70		;

00008d84 <.L17>:
    8d84:	0d 93       	cmp	#0,	r13	;r3 As==00
    8d86:	fa 37       	jge	$-10     	;abs 0x8d7c

00008d88 <.Loc.61.1>:
    8d88:	4a 43       	clr.b	r10		;
    8d8a:	30 40 5c 8d 	br	#0x8d5c		;

00008d8e <__mspabi_remi>:
    8d8e:	0a 12       	push	r10		;

00008d90 <.LCFI1>:
    8d90:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d92:	13 34       	jge	$+40     	;abs 0x8dba

00008d94 <.Loc.92.1>:
    8d94:	4e 43       	clr.b	r14		;
    8d96:	0e 8c       	sub	r12,	r14	;
    8d98:	0c 4e       	mov	r14,	r12	;

00008d9a <.LVL31>:
    8d9a:	5a 43       	mov.b	#1,	r10	;r3 As==01

00008d9c <.L29>:
    8d9c:	0d 93       	cmp	#0,	r13	;r3 As==00
    8d9e:	03 34       	jge	$+8      	;abs 0x8da6
    8da0:	4e 43       	clr.b	r14		;
    8da2:	0e 8d       	sub	r13,	r14	;
    8da4:	0d 4e       	mov	r14,	r13	;

00008da6 <.L30>:
    8da6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    8da8:	b0 12 02 8d 	call	#36098		;#0x8d02

00008dac <.LVL34>:
    8dac:	0a 93       	cmp	#0,	r10	;r3 As==00
    8dae:	03 24       	jz	$+8      	;abs 0x8db6

00008db0 <.LVL35>:
    8db0:	4d 43       	clr.b	r13		;
    8db2:	0d 8c       	sub	r12,	r13	;
    8db4:	0c 4d       	mov	r13,	r12	;

00008db6 <.L28>:
    8db6:	3a 41       	pop	r10		;
    8db8:	30 41       	ret			

00008dba <.L32>:
    8dba:	4a 43       	clr.b	r10		;
    8dbc:	30 40 9c 8d 	br	#0x8d9c		;

00008dc0 <__mspabi_func_epilog_7>:
    8dc0:	34 41       	pop	r4		;

00008dc2 <__mspabi_func_epilog_6>:
    8dc2:	35 41       	pop	r5		;

00008dc4 <__mspabi_func_epilog_5>:
    8dc4:	36 41       	pop	r6		;

00008dc6 <__mspabi_func_epilog_4>:
    8dc6:	37 41       	pop	r7		;

00008dc8 <__mspabi_func_epilog_3>:
    8dc8:	38 41       	pop	r8		;

00008dca <__mspabi_func_epilog_2>:
    8dca:	39 41       	pop	r9		;

00008dcc <__mspabi_func_epilog_1>:
    8dcc:	3a 41       	pop	r10		;
    8dce:	30 41       	ret			

00008dd0 <__mspabi_srli_15>:
    8dd0:	12 c3       	clrc			
    8dd2:	0c 10       	rrc	r12		;

00008dd4 <__mspabi_srli_14>:
    8dd4:	12 c3       	clrc			
    8dd6:	0c 10       	rrc	r12		;

00008dd8 <__mspabi_srli_13>:
    8dd8:	12 c3       	clrc			
    8dda:	0c 10       	rrc	r12		;

00008ddc <__mspabi_srli_12>:
    8ddc:	12 c3       	clrc			
    8dde:	0c 10       	rrc	r12		;

00008de0 <__mspabi_srli_11>:
    8de0:	12 c3       	clrc			
    8de2:	0c 10       	rrc	r12		;

00008de4 <__mspabi_srli_10>:
    8de4:	12 c3       	clrc			
    8de6:	0c 10       	rrc	r12		;

00008de8 <__mspabi_srli_9>:
    8de8:	12 c3       	clrc			
    8dea:	0c 10       	rrc	r12		;

00008dec <__mspabi_srli_8>:
    8dec:	12 c3       	clrc			
    8dee:	0c 10       	rrc	r12		;

00008df0 <__mspabi_srli_7>:
    8df0:	12 c3       	clrc			
    8df2:	0c 10       	rrc	r12		;

00008df4 <__mspabi_srli_6>:
    8df4:	12 c3       	clrc			
    8df6:	0c 10       	rrc	r12		;

00008df8 <__mspabi_srli_5>:
    8df8:	12 c3       	clrc			
    8dfa:	0c 10       	rrc	r12		;

00008dfc <__mspabi_srli_4>:
    8dfc:	12 c3       	clrc			
    8dfe:	0c 10       	rrc	r12		;

00008e00 <__mspabi_srli_3>:
    8e00:	12 c3       	clrc			
    8e02:	0c 10       	rrc	r12		;

00008e04 <__mspabi_srli_2>:
    8e04:	12 c3       	clrc			
    8e06:	0c 10       	rrc	r12		;

00008e08 <__mspabi_srli_1>:
    8e08:	12 c3       	clrc			
    8e0a:	0c 10       	rrc	r12		;
    8e0c:	30 41       	ret			

00008e0e <.L11>:
    8e0e:	3d 53       	add	#-1,	r13	;r3 As==11
    8e10:	12 c3       	clrc			
    8e12:	0c 10       	rrc	r12		;

00008e14 <__mspabi_srli>:
    8e14:	0d 93       	cmp	#0,	r13	;r3 As==00
    8e16:	fb 23       	jnz	$-8      	;abs 0x8e0e
    8e18:	30 41       	ret			

00008e1a <__mspabi_srll_15>:
    8e1a:	12 c3       	clrc			
    8e1c:	0d 10       	rrc	r13		;
    8e1e:	0c 10       	rrc	r12		;

00008e20 <__mspabi_srll_14>:
    8e20:	12 c3       	clrc			
    8e22:	0d 10       	rrc	r13		;
    8e24:	0c 10       	rrc	r12		;

00008e26 <__mspabi_srll_13>:
    8e26:	12 c3       	clrc			
    8e28:	0d 10       	rrc	r13		;
    8e2a:	0c 10       	rrc	r12		;

00008e2c <__mspabi_srll_12>:
    8e2c:	12 c3       	clrc			
    8e2e:	0d 10       	rrc	r13		;
    8e30:	0c 10       	rrc	r12		;

00008e32 <__mspabi_srll_11>:
    8e32:	12 c3       	clrc			
    8e34:	0d 10       	rrc	r13		;
    8e36:	0c 10       	rrc	r12		;

00008e38 <__mspabi_srll_10>:
    8e38:	12 c3       	clrc			
    8e3a:	0d 10       	rrc	r13		;
    8e3c:	0c 10       	rrc	r12		;

00008e3e <__mspabi_srll_9>:
    8e3e:	12 c3       	clrc			
    8e40:	0d 10       	rrc	r13		;
    8e42:	0c 10       	rrc	r12		;

00008e44 <__mspabi_srll_8>:
    8e44:	12 c3       	clrc			
    8e46:	0d 10       	rrc	r13		;
    8e48:	0c 10       	rrc	r12		;

00008e4a <__mspabi_srll_7>:
    8e4a:	12 c3       	clrc			
    8e4c:	0d 10       	rrc	r13		;
    8e4e:	0c 10       	rrc	r12		;

00008e50 <__mspabi_srll_6>:
    8e50:	12 c3       	clrc			
    8e52:	0d 10       	rrc	r13		;
    8e54:	0c 10       	rrc	r12		;

00008e56 <__mspabi_srll_5>:
    8e56:	12 c3       	clrc			
    8e58:	0d 10       	rrc	r13		;
    8e5a:	0c 10       	rrc	r12		;

00008e5c <__mspabi_srll_4>:
    8e5c:	12 c3       	clrc			
    8e5e:	0d 10       	rrc	r13		;
    8e60:	0c 10       	rrc	r12		;

00008e62 <__mspabi_srll_3>:
    8e62:	12 c3       	clrc			
    8e64:	0d 10       	rrc	r13		;
    8e66:	0c 10       	rrc	r12		;

00008e68 <__mspabi_srll_2>:
    8e68:	12 c3       	clrc			
    8e6a:	0d 10       	rrc	r13		;
    8e6c:	0c 10       	rrc	r12		;

00008e6e <__mspabi_srll_1>:
    8e6e:	12 c3       	clrc			
    8e70:	0d 10       	rrc	r13		;
    8e72:	0c 10       	rrc	r12		;
    8e74:	30 41       	ret			

00008e76 <.L12>:
    8e76:	3e 53       	add	#-1,	r14	;r3 As==11
    8e78:	12 c3       	clrc			
    8e7a:	0d 10       	rrc	r13		;
    8e7c:	0c 10       	rrc	r12		;

00008e7e <__mspabi_srll>:
    8e7e:	0e 93       	cmp	#0,	r14	;r3 As==00
    8e80:	fa 23       	jnz	$-10     	;abs 0x8e76
    8e82:	30 41       	ret			

00008e84 <memmove>:
    8e84:	0d 9c       	cmp	r12,	r13	;
    8e86:	0a 28       	jnc	$+22     	;abs 0x8e9c

00008e88 <.L5>:
    8e88:	0f 4c       	mov	r12,	r15	;
    8e8a:	0e 5c       	add	r12,	r14	;

00008e8c <.L3>:
    8e8c:	0e 9f       	cmp	r15,	r14	;
    8e8e:	0d 24       	jz	$+28     	;abs 0x8eaa

00008e90 <.LVL3>:
    8e90:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    8e94:	1f 53       	inc	r15		;

00008e96 <.LVL4>:
    8e96:	1d 53       	inc	r13		;
    8e98:	30 40 8c 8e 	br	#0x8e8c		;

00008e9c <.L2>:
    8e9c:	0f 4d       	mov	r13,	r15	;
    8e9e:	0f 5e       	add	r14,	r15	;
    8ea0:	0c 9f       	cmp	r15,	r12	;
    8ea2:	f2 2f       	jc	$-26     	;abs 0x8e88

00008ea4 <.L4>:
    8ea4:	3e 53       	add	#-1,	r14	;r3 As==11

00008ea6 <.LVL7>:
    8ea6:	3e 93       	cmp	#-1,	r14	;r3 As==11
    8ea8:	01 20       	jnz	$+4      	;abs 0x8eac

00008eaa <.L10>:
    8eaa:	30 41       	ret			

00008eac <.L6>:
    8eac:	0b 4c       	mov	r12,	r11	;
    8eae:	0b 5e       	add	r14,	r11	;
    8eb0:	0f 4d       	mov	r13,	r15	;
    8eb2:	0f 5e       	add	r14,	r15	;
    8eb4:	eb 4f 00 00 	mov.b	@r15,	0(r11)	;
    8eb8:	30 40 a4 8e 	br	#0x8ea4		;

00008ebc <memset>:
    8ebc:	0f 4c       	mov	r12,	r15	;
    8ebe:	0e 5c       	add	r12,	r14	;

00008ec0 <.L2>:
    8ec0:	0f 9e       	cmp	r14,	r15	;
    8ec2:	01 20       	jnz	$+4      	;abs 0x8ec6

00008ec4 <.Loc.104.1>:
    8ec4:	30 41       	ret			

00008ec6 <.L3>:
    8ec6:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    8eca:	1f 53       	inc	r15		;

00008ecc <.LVL4>:
    8ecc:	30 40 c0 8e 	br	#0x8ec0		;

00008ed0 <__do_global_ctors_aux>:
    8ed0:	0a 12       	push	r10		;
    8ed2:	3a 40 24 80 	mov	#32804,	r10	;#0x8024

00008ed6 <.L2>:
    8ed6:	2c 4a       	mov	@r10,	r12	;
    8ed8:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8eda:	02 20       	jnz	$+6      	;abs 0x8ee0
    8edc:	3a 41       	pop	r10		;
    8ede:	30 41       	ret			

00008ee0 <.L3>:
    8ee0:	8c 12       	call	r12		;
    8ee2:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    8ee6:	30 40 d6 8e 	br	#0x8ed6		;

00008eea <__msp430_init>:
    8eea:	b0 12 7e 82 	call	#33406		;#0x827e
    8eee:	b0 12 d0 8e 	call	#36560		;#0x8ed0

00008ef2 <L0>:
    8ef2:	b0 12 ba 81 	call	#33210		;#0x81ba

00008ef6 <.Loc.19.1>:
    8ef6:	b0 12 ac 81 	call	#33196		;#0x81ac

00008efa <.Loc.20.1>:
    8efa:	30 41       	ret			

00008efc <__msp430_fini>:
    8efc:	b0 12 c8 81 	call	#33224		;#0x81c8

00008f00 <L0>:
    8f00:	b0 12 30 82 	call	#33328		;#0x8230

00008f04 <L0>:
    8f04:	30 41       	ret			

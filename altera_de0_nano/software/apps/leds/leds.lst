
leds.elf:     file format elf32-msp430

SYMBOL TABLE:
0000ffe8 l    d  __interrupt_vector_5	00000000 __interrupt_vector_5
0000fff0 l    d  __interrupt_vector_9	00000000 __interrupt_vector_9
0000fffe l    d  __reset_vector	00000000 __reset_vector
00008000 l    d  .rodata	00000000 .rodata
0000807c l    d  .text	00000000 .text
00004000 l    d  .data	00000000 .data
0000407e l    d  .bss	00000000 .bss
00004122 l    d  .noinit	00000000 .noinit
00000000 l    d  .MP430.attributes	00000000 .MP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 qwark.c
000080b8 l       .text	00000000 __qwark_retry_1st_setup
000080ac l       .text	00000000 __qwark_restore_2nd_setup
000080cc l       .text	00000000 __qwark_retry_2nd_setup
000080a0 l       .text	00000000 __qwark_restore_1st_setup
0000812c l       .text	00000000 __system_restore
000080dc l       .text	00000000 __second_stage_retry
000080e4 l       .text	00000000 _retry_second_phase_commit_strt
00008100 l       .text	00000000 _retry_byte_copy
00008116 l       .text	00000000 __retry_complete
00008126 l       .text	00000000 __set_flag_complete
0000818e l       .text	00000000 __Second_buffer_restore_stack
0000814e l       .text	00000000 __First_buffer_restore_stack
00008e32 l       .text	00000000 __second_buffer_init
00008e36 l       .text	00000000 __first_phase_commit
00008ed4 l       .text	00000000 __second_phase_start
00008ec8 l       .text	00000000 _scratchpad_addr_cpy
00008ee2 l       .text	00000000 __set_flag_2nd
00008ee6 l       .text	00000000 _second_phase_commit
00008f34 l       .text	00000000 _chkpt_finished
00008efc l       .text	00000000 _second_phase_commit_strt
00008f1a l       .text	00000000 _byte_copy
00008f0e l       .text	00000000 _pre_end_copy
00008f5c l       .text	00000000 __pre_finish_2nd_buffer
00008f7a l       .text	00000000 _finish
00000000 l    df *ABS*	00000000 timerA.c
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
00008228 l       .text	00000000 _msp430_run_array
00008236 l       .text	00000000 _msp430_run_done
00000000 l    df *ABS*	00000000 main.c
00004004 l     O .data	00000002 _v_seed.2309
00000000 l    df *ABS*	00000000 lib_a-impure.o
00004006 l     O .data	00000078 impure_data
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtbegin.o
00008074 l     O .rodata	00000000 __CTOR_LIST__
00008078 l     O .rodata	00000000 __DTOR_LIST__
0000806c l     O .rodata	00000000 __EH_FRAME_BEGIN__
00009556 l     O .text	00000000 __TMC_LIST__
00008238 l     F .text	00000000 deregister_tm_clones
00008252 l     F .text	00000000 register_tm_clones
00008280 l     F .text	00000000 __do_global_dtors_aux
0000407e l     O .bss	00000000 completed.3056
00004080 l     O .bss	00000000 dtor_idx.3058
000082ce l     F .text	00000000 frame_dummy
00004082 l     O .bss	00000000 object.3071
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtend.o
00008076 l     O .rodata	00000000 __CTOR_END__
0000806c l     O .rodata	00000000 __FRAME_END__
00009520 l     F .text	00000000 __do_global_ctors_aux
00000000 l    df *ABS*	00000000 crt_bss.o
00000000 l    df *ABS*	00000000 crt_movedata.o
00000000 l    df *ABS*	00000000 crt_main.o
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 lib2divHI.o
00000000 l    df *ABS*	00000000 srli.o
00000000 l    df *ABS*	00000000 lib2hw_mul_16.o
00000130 l       *ABS*	00000000 MPY_OP1
00000132 l       *ABS*	00000000 MPY_OP1_S
00000134 l       *ABS*	00000000 MAC_OP1
00000138 l       *ABS*	00000000 MPY_OP2
00000138 l       *ABS*	00000000 MAC_OP2
0000013a l       *ABS*	00000000 RESULT_LO
0000013c l       *ABS*	00000000 RESULT_HI
00000000 l    df *ABS*	00000000 lib_a-exit.o
00000000 l    df *ABS*	00000000 lib_a-__call_atexit.o
00000000 l    df *ABS*	00000000 slli.o
00000000 l    df *ABS*	00000000 ciosyscalls.o
00000000 l    df *ABS*	00000000 lib_a-memmove.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crtn.o
00000000 l    df *ABS*	00000000 
0000807c l       .text	00000000 _start
000092d6 g     F .text	00000000 __mspabi_mpyl
0000949e g       .text	00000000 .hidden __mspabi_slll_9
0000948e g       .text	00000000 .hidden __mspabi_slll_13
00008ca6 g     F .text	00000016 end_of_benchmark
00009226 g       .text	00000000 .hidden __mspabi_srli_9
00009276 g       .text	00000000 .hidden __mspabi_srll_10
000084ba g     F .text	000000d6 transform
00009222 g       .text	00000000 .hidden __mspabi_srli_10
00008b90 g     F .text	00000094 train
00009468 g       .text	00000000 .hidden __mspabi_slli_9
0000920e g       .text	00000000 .hidden __mspabi_srli_15
000094d4 g     F .text	00000038 memmove
0000923a g       .text	00000000 .hidden __mspabi_srli_4
00009462 g       .text	00000000 .hidden __mspabi_slli_12
00009130 g     F .text	00000040 .hidden udivmodhi4
00008d80 g     F .text	00000020 dummy_function_one
00004090 g     O .bss	00000002 count2
0000922e g       .text	00000000 .hidden __mspabi_srli_7
00009288 g       .text	00000000 .hidden __mspabi_srll_7
000092a0 g       .text	00000000 .hidden __mspabi_srll_3
00004092 g     O .bss	00000002 ptr3
000092d6 g     F .text	0000002e __mulsi2
00009200 g       .text	00000000 .hidden __mspabi_func_epilog_6
00009556 g     O .text	00000000 .hidden __TMC_END__
00009264 g       .text	00000000 .hidden __mspabi_srll_13
0000807a g     O .rodata	00000000 .hidden __DTOR_END__
00008070 g       .rodata	00000000 __fini_array_end
00008a70 g     F .text	000000f2 print_stats
0000921a g       .text	00000000 .hidden __mspabi_srli_12
00004094 g     O .bss	00000002 sum
000092d6 g     F .text	00000000 __mspabi_mpyl_hw
0000807c g     F .text	00000004 __crt0_start
00009496 g       .text	00000000 .hidden __mspabi_slll_11
00009486 g       .text	00000000 .hidden __mspabi_slll_15
0000945e g       .text	00000000 .hidden __mspabi_slli_14
00009472 g       .text	00000000 .hidden __mspabi_slli_4
000081d0 g     F .text	0000000e __crt0_init_bss
000000a4 g       *ABS*	00000000 __bsssize
000094ba g       .text	00000000 .hidden __mspabi_slll_2
00004096 g     O .bss	00000002 ptr
000091bc g     F .text	00000032 .hidden __mspabi_remi
000081f2 g     F .text	0000000a __crt0_call_init_then_main
0000920a g       .text	00000000 .hidden __mspabi_func_epilog_1
00009480 g       .text	00000000 .hidden __mspabi_slli
00004098 g     O .bss	00000080 model
00009206 g       .text	00000000 .hidden __mspabi_func_epilog_3
00008068 g     O .rodata	00000002 _global_impure_ptr
00009294 g       .text	00000000 .hidden __mspabi_srll_5
00009252 g       .text	00000000 .hidden __mspabi_srli
000092c2 g     F .text	00000000 __mspabi_mpyi_hw
000092c2 g     F .text	00000014 __mulhi2
00009270 g       .text	00000000 .hidden __mspabi_srll_11
000094ae g       .text	00000000 .hidden __mspabi_slll_5
00009464 g       .text	00000000 .hidden __mspabi_slli_11
00009474 g       .text	00000000 .hidden __mspabi_slli_3
00009236 g       .text	00000000 .hidden __mspabi_srli_5
00008590 g     F .text	000002c6 featurize
00000000  w      *UND*	00000000 __sf_fake_stderr
0000904a g     F .text	000000b2 UART_WriteNumber
00000000  w      *UND*	00000000 __deregister_frame_info
00004122 g       .noinit	00000000 end
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
00009476 g       .text	00000000 .hidden __mspabi_slli_2
00004118 g     O .bss	00000002 resultStationaryPct
000091f6 g     F .text	00000008 .hidden __mspabi_remu
0000928e g       .text	00000000 .hidden __mspabi_srll_6
00009322 g     F .text	0000013a __call_exitprocs
0000411a g     O .bss	00000002 ptr2
000094aa g       .text	00000000 .hidden __mspabi_slll_6
000094b2 g       .text	00000000 .hidden __mspabi_slll_4
000094a2 g       .text	00000000 .hidden __mspabi_slll_8
00008218 g     F .text	00000000 _msp430_run_fini_array
0000901c g     F .text	0000002e UART_WriteChar
00009246 g       .text	00000000 .hidden __mspabi_srli_1
0000925e g       .text	00000000 .hidden __mspabi_srll_14
0000946e g       .text	00000000 .hidden __mspabi_slli_6
000092c2 g     F .text	00000000 __mspabi_mpyi
0000411c g     O .bss	00000002 resultMovingPct
00008080 g     F .text	00000150 qwark_restore
00009212 g       .text	00000000 .hidden __mspabi_srli_14
0000007e g       *ABS*	00000000 __romdatacopysize
00008d54 g     F .text	0000002c init
0000948a g       .text	00000000 .hidden __mspabi_slll_14
0000921e g       .text	00000000 .hidden __mspabi_srli_11
000094a6 g       .text	00000000 .hidden __mspabi_slll_7
00004120 g     O .bss	00000002 periodic_val
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
00008070 g       .rodata	00000000 __fini_array_start
00009170 g     F .text	0000004c .hidden __mspabi_divi
00000000  w      *UND*	00000000 __sf_fake_stdin
00000000  w      *ABS*	00000000 __rom_highdatacopysize
0000953a g       .text	00000000 __msp430_init
0000950c g     F .text	00000014 memset
00009492 g       .text	00000000 .hidden __mspabi_slll_12
00008dae g     F .text	0000006a main
00008fe4 g     F .text	00000022 ta_wait
0000929a g       .text	00000000 .hidden __mspabi_srll_4
00008070 g       .rodata	00000000 __init_array_end
00009242 g       .text	00000000 .hidden __mspabi_srli_2
00009478 g       .text	00000000 .hidden __mspabi_slli_1
000091ee g     F .text	00000008 .hidden __mspabi_divu
00000000  w      *ABS*	00000000 __high_bsssize
000094b6 g       .text	00000000 .hidden __mspabi_slll_3
00000000  w      *ABS*	00000000 __rom_highdatastart
00009006 g     F .text	00000016 INT_timerA1
00009556 g       .text	00000000 __msp430_fini_end
00008a12 g     F .text	0000005e record_stats
00008cbc g     F .text	00000004 count_error
00004000 g     O .data	00000002 count
0000926a g       .text	00000000 .hidden __mspabi_srll_12
00009470 g       .text	00000000 .hidden __mspabi_slli_5
00008b62 g     F .text	0000002e warmup_sensor
00009556 g       *ABS*	00000000 __romdatastart
000090fc g     F .text	00000034 UART_WriteString
00009460 g       .text	00000000 .hidden __mspabi_slli_13
000082e6 g     F .text	00000114 sqrt16
000081fc g     F .text	00000000 _msp430_run_init_array
00008fc2 g     F .text	00000022 ta_wait_no_lpm
00009232 g       .text	00000000 .hidden __mspabi_srli_6
00008070 g       .rodata	00000000 __preinit_array_end
000083fa g     F .text	00000074 ACCEL_singleSample
00009466 g       .text	00000000 .hidden __mspabi_slli_10
0000411e g     O .bss	00000002 var
0000923e g       .text	00000000 .hidden __mspabi_srli_3
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
0000407e g       .bss	00000000 __bssstart
00008856 g     F .text	000001bc classify
00008cc0 g     F .text	00000094 select_mode
00009202 g       .text	00000000 .hidden __mspabi_func_epilog_5
000094ca g       .text	00000000 .hidden __mspabi_slll
00008000 g       .noinit	00000000 __stack
00008e18 g     F .text	000001aa INT_Qwark
00004002 g     O .data	00000001 dummy
0000927c g       .text	00000000 .hidden __mspabi_srll_9
0000407e g       .data	00000000 _edata
0000954c g       .text	00000000 __msp430_init_end
000092bc g       .text	00000000 .hidden __mspabi_srll
00009304 g     F .text	0000001e exit
00000000  w      *ABS*	00000000 __high_bssstart
0000946a g       .text	00000000 .hidden __mspabi_slli_8
00009258 g       .text	00000000 .hidden __mspabi_srll_15
00008da0 g     F .text	0000000e dummy_function_two
0000949a g       .text	00000000 .hidden __mspabi_slll_10
00000000  w      *UND*	00000000 __sf_fake_stdout
0000945c g       .text	00000000 .hidden __mspabi_slli_15
00008070 g       .rodata	00000000 __init_array_start
000094d0  w    F .text	00000004 _exit
00009216 g       .text	00000000 .hidden __mspabi_srli_13
00004000 g       .data	00000000 __datastart
000094be g       .text	00000000 .hidden __mspabi_slll_1
00009282 g       .text	00000000 .hidden __mspabi_srll_8
000092ac g       .text	00000000 .hidden __mspabi_srll_1
0000946c g       .text	00000000 .hidden __mspabi_slli_7
00008070 g       .rodata	00000000 __preinit_array_start
000081de g     F .text	00000014 __crt0_movedata
00009208 g       .text	00000000 .hidden __mspabi_func_epilog_2
00000000  w      *UND*	00000000 __register_frame_info
0000820a g     F .text	00000000 _msp430_run_preinit_array
0000846e g     F .text	0000004c acquire_window
000091fe g       .text	00000000 .hidden __mspabi_func_epilog_7
00009204 g       .text	00000000 .hidden __mspabi_func_epilog_4
000092a6 g       .text	00000000 .hidden __mspabi_srll_2
0000954c g       .text	00000000 __msp430_fini
0000922a g       .text	00000000 .hidden __mspabi_srli_8
00008c24 g     F .text	00000082 recognize
00000000  w      *UND*	00000000 free



Disassembly of section __interrupt_vector_5:

0000ffe8 <__interrupt_vector_5>:
    ffe8:	18 8e       	interrupt service routine at 0x8e18

Disassembly of section __interrupt_vector_9:

0000fff0 <__interrupt_vector_9>:
    fff0:	06 90       	interrupt service routine at 0x9006

Disassembly of section .text:

0000807c <__crt0_start>:
    807c:	31 40 00 80 	mov	#32768,	r1	;#0x8000

00008080 <qwark_restore>:
	//    RESTORE HANDLING LOGIC																  				   //
	//	  W.C 30 CYCLES																							   //
	//-------------------------------------------------------------------------------------------------------------//

	/* Disable Qwark */
	__asm__ __volatile__ ("mov #0x0000, &0x02A0");				// 4 cycles
    8080:	82 43 a0 02 	mov	#0,	&0x02a0	;r3 As==00

00008084 <.Loc.29.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");				// 2 cycles
    8084:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

00008088 <.Loc.30.1>:
	__asm__ __volatile__ ("jz __qwark_retry_1st_setup");			// 2 cycles
    8088:	17 24       	jz	$+48     	;abs 0x80b8

0000808a <.Loc.32.1>:

	__asm__ __volatile__ ("cmp.b #0x03, &0x6075");				// 3 cycles
    808a:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    808e:	75 60 

00008090 <.Loc.33.1>:
	__asm__ __volatile__ ("jz __qwark_restore_2nd_setup");			// 2 cycles
    8090:	0d 24       	jz	$+28     	;abs 0x80ac

00008092 <.Loc.34.1>:
	__asm__ __volatile__ ("cmp.b #0x03, &0x6074");				// 3 cycles
    8092:	f2 90 03 00 	cmp.b	#3,	&0x6074	;
    8096:	74 60 

00008098 <.Loc.35.1>:
	__asm__ __volatile__ ("jnz __crt0_init_bss");				// 2 cycles
    8098:	9b 20       	jnz	$+312    	;abs 0x81d0

0000809a <.Loc.37.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6075");				// 2 cycles
    809a:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

0000809e <.Loc.38.1>:
	__asm__ __volatile__ ("jz  __qwark_retry_2nd_setup");			// 2 cycles
    809e:	16 24       	jz	$+46     	;abs 0x80cc

000080a0 <__qwark_restore_1st_setup>:

	__asm__ __volatile__ ("__qwark_restore_1st_setup:");

	__asm__ __volatile__ ("mov &0X6012,   r12 ");				// 3 cycles
    80a0:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

000080a4 <.Loc.43.1>:
    __asm__ __volatile__ ("mov #0x6FFE,   r13 ");				// 2 cycles
    80a4:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

000080a8 <.Loc.44.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    80a8:	30 40 2c 81 	br	#0x812c		;

000080ac <__qwark_restore_2nd_setup>:

	__asm__ __volatile__ ("__qwark_restore_2nd_setup:");

	__asm__ __volatile__ ("mov &0X6042, r12   ");				// 3 cycles
    80ac:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

000080b0 <.Loc.49.1>:
    __asm__ __volatile__ ("mov #0x6BFE, r13   ");				// 2 cycles
    80b0:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

000080b4 <.Loc.50.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    80b4:	30 40 2c 81 	br	#0x812c		;

000080b8 <__qwark_retry_1st_setup>:

	__asm__ __volatile__ ("__qwark_retry_1st_setup:");

	__asm__ __volatile__ ("mov  #0x6030,   r10 ");				// 2 cycles
    80b8:	3a 40 30 60 	mov	#24624,	r10	;#0x6030

000080bc <.Loc.55.1>:
	__asm__ __volatile__ ("mov  &0X6012,   r12 ");				// 3 cycles
    80bc:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

000080c0 <.Loc.56.1>:
    __asm__ __volatile__ ("mov  #0x6FFE,   r13 ");				// 2 cycles
    80c0:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

000080c4 <.Loc.57.1>:
	__asm__ __volatile__ ("mov  &0x602E,   r15 ");				// 3 cycles
    80c4:	1f 42 2e 60 	mov	&0x602e,r15	;0x602e

000080c8 <.Loc.58.1>:
	__asm__ __volatile__ ("br  #__second_stage_retry");			// 2 cycles
    80c8:	30 40 dc 80 	br	#0x80dc		;

000080cc <__qwark_retry_2nd_setup>:

	__asm__ __volatile__ ("__qwark_retry_2nd_setup:");

	__asm__ __volatile__ ("mov #0x6060,   r10 ");				// 2 cycles
    80cc:	3a 40 60 60 	mov	#24672,	r10	;#0x6060

000080d0 <.Loc.63.1>:
	__asm__ __volatile__ ("mov &0X6042,   r12 ");				// 3 cycles
    80d0:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

000080d4 <.Loc.64.1>:
    __asm__ __volatile__ ("mov #0x6BFE,   r13 ");				// 2 cycles
    80d4:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

000080d8 <.Loc.65.1>:
	__asm__ __volatile__ ("mov &0x605E,   r15 ");				// 3 cycles
    80d8:	1f 42 5e 60 	mov	&0x605e,r15	;0x605e

000080dc <__second_stage_retry>:
	//-------------------------------------------------------------------------------------------------------------//
	//    RETRY SECOND PHASE OF THE COMMIT PROCESS	: 148 cycles												   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__second_stage_retry:");

	__asm__ __volatile__ ("tst r15 ");     		            // 1 cycles
    80dc:	0f 93       	cmp	#0,	r15	;r3 As==00

000080de <.Loc.73.1>:
	__asm__ __volatile__ ("jz  __system_restore");		    // 2 cycles
    80de:	26 24       	jz	$+78     	;abs 0x812c

000080e0 <.Loc.75.1>:

	__asm__ __volatile__ ("mov #0x6000,  r14");			    // 2 cycles
    80e0:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

000080e4 <_retry_second_phase_commit_strt>:

	__asm__ __volatile__ ("_retry_second_phase_commit_strt:");  // Worst case

	__asm__ __volatile__ ("mov @r10+2,  r9 ");   			// 2 cycles
    80e4:	39 4a       	mov	@r10+,	r9	;

000080e6 <.Loc.81.1>:

	__asm__ __volatile__ ("mov r9,  r11 ");   			    // 1 cycle
    80e6:	0b 49       	mov	r9,	r11	;

000080e8 <.Loc.83.1>:

	__asm__ __volatile__ ("and #0x8000,  r11 ");   			// 2 cycles
    80e8:	3b f0 00 80 	and	#32768,	r11	;#0x8000

000080ec <.Loc.84.1>:
	__asm__ __volatile__ ("cmp #0x8000,  r11 ");   			// 2 cycles
    80ec:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

000080f0 <.Loc.85.1>:
	__asm__ __volatile__ ("jeq _retry_byte_copy ");   		// 2 cycles
    80f0:	07 24       	jz	$+16     	;abs 0x8100

000080f2 <.Loc.87.1>:

	__asm__ __volatile__ ("mov @r14+2, @r9 ");    			// 5 cycles
    80f2:	b9 4e 00 00 	mov	@r14+,	0(r9)	;

000080f6 <.Loc.89.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    80f6:	1f 83       	dec	r15		;

000080f8 <.Loc.90.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    80f8:	0f 93       	cmp	#0,	r15	;r3 As==00

000080fa <.Loc.92.1>:

	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80fa:	f4 23       	jnz	$-22     	;abs 0x80e4

000080fc <.Loc.93.1>:
	__asm__ __volatile__ ("br #__retry_complete");		    // 2 cycle
    80fc:	30 40 16 81 	br	#0x8116		;

00008100 <_retry_byte_copy>:

	__asm__ __volatile__ ("_retry_byte_copy: ");
	__asm__ __volatile__ ("and #0x7FFF,  r9  ");   			// mask the highest bit 2 cycles
    8100:	39 f0 ff 7f 	and	#32767,	r9	;#0x7fff

00008104 <.Loc.97.1>:
	__asm__ __volatile__ ("mov r9,      r11  ");   			// 1 cycle
    8104:	0b 49       	mov	r9,	r11	;

00008106 <.Loc.98.1>:
	__asm__ __volatile__ ("and #0x01,    r11 ");   			// detect if its a byte write - 2 cycles
    8106:	1b f3       	and	#1,	r11	;r3 As==01

00008108 <.Loc.99.1>:
	__asm__ __volatile__ ("bis  r11,     r14 ");   			// detect if its a byte write - 2 cycles
    8108:	0e db       	bis	r11,	r14	;

0000810a <.Loc.101.1>:

	__asm__ __volatile__ ("mov.b @r14, @r9  ");    			// 5 cycles
    810a:	e9 4e 00 00 	mov.b	@r14,	0(r9)	;

0000810e <.Loc.102.1>:
	__asm__ __volatile__ ("incd r14 ");    					// 1 cycle
    810e:	2e 53       	incd	r14		;

00008110 <.Loc.104.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    8110:	1f 83       	dec	r15		;

00008112 <.Loc.105.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    8112:	0f 93       	cmp	#0,	r15	;r3 As==00

00008114 <.Loc.106.1>:
	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    8114:	e7 23       	jnz	$-48     	;abs 0x80e4

00008116 <__retry_complete>:

	//-------------------------------------------------------------------------------------------------------------//
	//    END OF THE RETRY-SECOND PHASE	: Atomic Flag Set														   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");		// 4 cycles
    8116:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

0000811a <.Loc.115.1>:
	__asm__ __volatile__ ("jz __set_flag_complete");	// 2 cycles
    811a:	05 24       	jz	$+12     	;abs 0x8126

0000811c <.Loc.117.1>:

	__asm__ __volatile__ ("mov #0x0301, &0x6074 ");		// 5 cycles
    811c:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    8120:	74 60 

00008122 <.Loc.118.1>:
	__asm__ __volatile__ ("br #__system_restore:");		// 2 cycles
    8122:	30 40 2c 81 	br	#0x812c		;

00008126 <__set_flag_complete>:

	__asm__ __volatile__ ("__set_flag_complete:");
	__asm__ __volatile__ ("mov #0x0103, &0x6074 ");		// 5 cycles
    8126:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    812a:	74 60 

0000812c <__system_restore>:
	//	 12 CYCLES																								   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__system_restore:");

	/* Disable The Watchdog */
	__asm__ __volatile__ ("mov #288, r8");		// 2 cycles
    812c:	38 40 20 01 	mov	#288,	r8	;#0x0120

00008130 <.Loc.131.1>:
	__asm__ __volatile__ ("mov #23168, 0(r8)");	// 2 cycles
    8130:	b8 40 80 5a 	mov	#23168,	0(r8)	;#0x5a80
    8134:	00 00 

00008136 <.Loc.134.1>:

	/* Enable and Configure the UART */
	__asm__ __volatile__ ("mov.b #130, r8");	// 2 cycles
    8136:	78 40 82 00 	mov.b	#130,	r8	;#0x0082

0000813a <.Loc.135.1>:
	__asm__ __volatile__ ("mov   #8, 0(r8)");	// 2 cycles
    813a:	b8 42 00 00 	mov	#8,	0(r8)	;r2 As==11

0000813e <.Loc.137.1>:

	__asm__ __volatile__ ("mov.b #128, r8");	// 2 cycles
    813e:	78 40 80 00 	mov.b	#128,	r8	;#0x0080

00008142 <.Loc.138.1>:
	__asm__ __volatile__ ("mov.b   #1, 0(r8)"); // 2 cycles
    8142:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01

00008146 <.Loc.219.1>:
	//-------------------------------------------------------------------------------------------------------------//
	//   REGISTERS RESTORE: VERIFY WHICH REGISTERS SHOULD BE RESTORED					   						   //
	//	 																										   //
	//-------------------------------------------------------------------------------------------------------------//

	__asm__ __volatile__ ("cmp.b #0x03,&0x6075");				// 5 cycles
    8146:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    814a:	75 60 

0000814c <.Loc.220.1>:
	__asm__ __volatile__ ("jeq __Second_buffer_restore_stack"); // 2 cycles
    814c:	20 24       	jz	$+66     	;abs 0x818e

0000814e <__First_buffer_restore_stack>:
	/* EDE -> Rm  : 3 cycles each 											  				  			  */
	/* EDE -> PC  : 4 cycles (1 extra cycle penalty) for openMSP430 		  				  			  */
	/* Register time: 14x3 = 42 cycles + 4 cycles (PC) = 49 Cycles + 4(Qwark enable) = 53 cycles 		  */
	__asm__ __volatile__ ("__First_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6016,r4"); 		//R4
    814e:	14 42 16 60 	mov	&0x6016,r4	;0x6016

00008152 <.Loc.230.1>:
	__asm__ __volatile__ ("mov &0x6018,r5"); 		//R5
    8152:	15 42 18 60 	mov	&0x6018,r5	;0x6018

00008156 <.Loc.231.1>:
	__asm__ __volatile__ ("mov &0x601A,r6"); 		//R6
    8156:	16 42 1a 60 	mov	&0x601a,r6	;0x601a

0000815a <.Loc.232.1>:
	__asm__ __volatile__ ("mov &0x601C,r7"); 		//R7
    815a:	17 42 1c 60 	mov	&0x601c,r7	;0x601c

0000815e <.Loc.233.1>:
	__asm__ __volatile__ ("mov &0x601E,r8"); 		//R8
    815e:	18 42 1e 60 	mov	&0x601e,r8	;0x601e

00008162 <.Loc.234.1>:
	__asm__ __volatile__ ("mov &0x6020,r9"); 		//R9
    8162:	19 42 20 60 	mov	&0x6020,r9	;0x6020

00008166 <.Loc.235.1>:
	__asm__ __volatile__ ("mov &0x6022,r10"); 		//R10
    8166:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

0000816a <.Loc.236.1>:
	__asm__ __volatile__ ("mov &0x6024,r11"); 		//R11
    816a:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

0000816e <.Loc.237.1>:
	__asm__ __volatile__ ("mov &0x6026,r12"); 		//R12
    816e:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

00008172 <.Loc.238.1>:
	__asm__ __volatile__ ("mov &0x6028,r13"); 	    //R13
    8172:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00008176 <.Loc.239.1>:
	__asm__ __volatile__ ("mov &0x602A,r14"); 		//R14
    8176:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

0000817a <.Loc.240.1>:
	__asm__ __volatile__ ("mov &0x602C,r15"); 		//R15
    817a:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

0000817e <.Loc.241.1>:
	__asm__ __volatile__ ("mov &0x6012,r1");   		//SP/R1
    817e:	11 42 12 60 	mov	&0x6012,r1	;0x6012

00008182 <.Loc.242.1>:
	__asm__ __volatile__ ("mov &0x6014,r2"); 	    //SR/R2
    8182:	12 42 14 60 	mov	&0x6014,r2	;0x6014

00008186 <.Loc.245.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    8186:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

0000818a <.Loc.248.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6010, pc"); 	    //PC/R0
    818a:	10 42 10 60 	br	&0x6010		;

0000818e <__Second_buffer_restore_stack>:

	__asm__ __volatile__ ("__Second_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6046,r4"); 		//R4
    818e:	14 42 46 60 	mov	&0x6046,r4	;0x6046

00008192 <.Loc.253.1>:
	__asm__ __volatile__ ("mov &0x6048,r5"); 		//R5
    8192:	15 42 48 60 	mov	&0x6048,r5	;0x6048

00008196 <.Loc.254.1>:
	__asm__ __volatile__ ("mov &0x604A,r6"); 		//R6
    8196:	16 42 4a 60 	mov	&0x604a,r6	;0x604a

0000819a <.Loc.255.1>:
	__asm__ __volatile__ ("mov &0x604C,r7"); 		//R7
    819a:	17 42 4c 60 	mov	&0x604c,r7	;0x604c

0000819e <.Loc.256.1>:
	__asm__ __volatile__ ("mov &0x604E,r8"); 		//R8
    819e:	18 42 4e 60 	mov	&0x604e,r8	;0x604e

000081a2 <.Loc.257.1>:
	__asm__ __volatile__ ("mov &0x6050,r9"); 		//R9
    81a2:	19 42 50 60 	mov	&0x6050,r9	;0x6050

000081a6 <.Loc.258.1>:
	__asm__ __volatile__ ("mov &0x6052,r10"); 		//R10
    81a6:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

000081aa <.Loc.259.1>:
	__asm__ __volatile__ ("mov &0x6054,r11"); 		//R11
    81aa:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

000081ae <.Loc.260.1>:
	__asm__ __volatile__ ("mov &0x6056,r12"); 		//R12
    81ae:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

000081b2 <.Loc.261.1>:
	__asm__ __volatile__ ("mov &0x6058,r13"); 	    //R13
    81b2:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

000081b6 <.Loc.262.1>:
	__asm__ __volatile__ ("mov &0x605A,r14"); 		//R14
    81b6:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

000081ba <.Loc.263.1>:
	__asm__ __volatile__ ("mov &0x605C,r15"); 		//R15
    81ba:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

000081be <.Loc.264.1>:
	__asm__ __volatile__ ("mov &0x6042,r1");   		//SP/R1
    81be:	11 42 42 60 	mov	&0x6042,r1	;0x6042

000081c2 <.Loc.265.1>:
	__asm__ __volatile__ ("mov &0x6044,r2"); 	    //SR/R2
    81c2:	12 42 44 60 	mov	&0x6044,r2	;0x6044

000081c6 <.Loc.268.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    81c6:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

000081ca <.Loc.271.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6040, pc"); 	    //PC/R0
    81ca:	10 42 40 60 	br	&0x6040		;

000081ce <.Loc.273.1>:

}
    81ce:	03 43       	nop			

000081d0 <__crt0_init_bss>:
    81d0:	3c 40 7e 40 	mov	#16510,	r12	;#0x407e

000081d4 <.Loc.74.1>:
    81d4:	0d 43       	clr	r13		;

000081d6 <.Loc.75.1>:
    81d6:	3e 40 a4 00 	mov	#164,	r14	;#0x00a4

000081da <.Loc.79.1>:
    81da:	b0 12 0c 95 	call	#38156		;#0x950c

000081de <__crt0_movedata>:
    81de:	3c 40 00 40 	mov	#16384,	r12	;#0x4000

000081e2 <.Loc.116.1>:
    81e2:	3d 40 56 95 	mov	#38230,	r13	;#0x9556

000081e6 <.Loc.119.1>:
    81e6:	0d 9c       	cmp	r12,	r13	;

000081e8 <.Loc.120.1>:
    81e8:	04 24       	jz	$+10     	;abs 0x81f2

000081ea <.Loc.122.1>:
    81ea:	3e 40 7e 00 	mov	#126,	r14	;#0x007e

000081ee <.Loc.124.1>:
    81ee:	b0 12 d4 94 	call	#38100		;#0x94d4

000081f2 <__crt0_call_init_then_main>:
    81f2:	b0 12 3a 95 	call	#38202		;#0x953a

000081f6 <.Loc.196.1>:
    81f6:	0c 43       	clr	r12		;

000081f8 <.Loc.197.1>:
    81f8:	b0 12 ae 8d 	call	#36270		;#0x8dae

000081fc <_msp430_run_init_array>:
    81fc:	34 40 70 80 	mov	#32880,	r4	;#0x8070

00008200 <.Loc.224.1>:
    8200:	35 40 70 80 	mov	#32880,	r5	;#0x8070

00008204 <.Loc.225.1>:
    8204:	26 43       	mov	#2,	r6	;r3 As==10

00008206 <.Loc.226.1>:
    8206:	30 40 28 82 	br	#0x8228		;

0000820a <_msp430_run_preinit_array>:
    820a:	34 40 70 80 	mov	#32880,	r4	;#0x8070

0000820e <.Loc.232.1>:
    820e:	35 40 70 80 	mov	#32880,	r5	;#0x8070

00008212 <.Loc.233.1>:
    8212:	26 43       	mov	#2,	r6	;r3 As==10

00008214 <.Loc.234.1>:
    8214:	30 40 28 82 	br	#0x8228		;

00008218 <_msp430_run_fini_array>:
    8218:	34 40 70 80 	mov	#32880,	r4	;#0x8070

0000821c <.Loc.240.1>:
    821c:	35 40 70 80 	mov	#32880,	r5	;#0x8070

00008220 <.Loc.241.1>:
    8220:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe

00008224 <.Loc.242.1>:
    8224:	30 40 28 82 	br	#0x8228		;

00008228 <_msp430_run_array>:
    8228:	05 94       	cmp	r4,	r5	;

0000822a <.Loc.246.1>:
    822a:	05 24       	jz	$+12     	;abs 0x8236

0000822c <.Loc.247.1>:
    822c:	27 44       	mov	@r4,	r7	;

0000822e <.Loc.248.1>:
    822e:	04 56       	add	r6,	r4	;

00008230 <.Loc.249.1>:
    8230:	a7 12       	call	@r7		;

00008232 <.Loc.250.1>:
    8232:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x8228

00008236 <_msp430_run_done>:
    8236:	30 41       	ret			

00008238 <deregister_tm_clones>:
    8238:	3c 40 56 95 	mov	#38230,	r12	;#0x9556
    823c:	3c 90 56 95 	cmp	#38230,	r12	;#0x9556
    8240:	07 24       	jz	$+16     	;abs 0x8250
    8242:	3d 40 00 00 	mov	#0,	r13	;
    8246:	0d 93       	cmp	#0,	r13	;r3 As==00
    8248:	03 24       	jz	$+8      	;abs 0x8250
    824a:	3c 40 56 95 	mov	#38230,	r12	;#0x9556
    824e:	8d 12       	call	r13		;

00008250 <.L1>:
    8250:	30 41       	ret			

00008252 <register_tm_clones>:
    8252:	0a 12       	push	r10		;
    8254:	3a 40 56 95 	mov	#38230,	r10	;#0x9556
    8258:	3a 80 56 95 	sub	#38230,	r10	;#0x9556
    825c:	0a 11       	rra	r10		;
    825e:	0c 4a       	mov	r10,	r12	;
    8260:	b0 12 0e 92 	call	#37390		;#0x920e
    8264:	0c 5a       	add	r10,	r12	;
    8266:	0d 4c       	mov	r12,	r13	;
    8268:	0d 11       	rra	r13		;
    826a:	0d 93       	cmp	#0,	r13	;r3 As==00
    826c:	07 24       	jz	$+16     	;abs 0x827c
    826e:	3e 40 00 00 	mov	#0,	r14	;
    8272:	0e 93       	cmp	#0,	r14	;r3 As==00
    8274:	03 24       	jz	$+8      	;abs 0x827c
    8276:	3c 40 56 95 	mov	#38230,	r12	;#0x9556
    827a:	8e 12       	call	r14		;

0000827c <.L9>:
    827c:	3a 41       	pop	r10		;
    827e:	30 41       	ret			

00008280 <__do_global_dtors_aux>:
    8280:	0a 12       	push	r10		;
    8282:	09 12       	push	r9		;
    8284:	c2 93 7e 40 	cmp.b	#0,	&0x407e	;r3 As==00
    8288:	17 20       	jnz	$+48     	;abs 0x82b8
    828a:	3a 40 7a 80 	mov	#32890,	r10	;#0x807a
    828e:	3a 80 78 80 	sub	#32888,	r10	;#0x8078
    8292:	0a 11       	rra	r10		;
    8294:	3a 53       	add	#-1,	r10	;r3 As==11
    8296:	39 40 78 80 	mov	#32888,	r9	;#0x8078

0000829a <.L19>:
    829a:	1c 42 80 40 	mov	&0x4080,r12	;0x4080
    829e:	0c 9a       	cmp	r10,	r12	;
    82a0:	0d 28       	jnc	$+28     	;abs 0x82bc
    82a2:	b0 12 38 82 	call	#33336		;#0x8238
    82a6:	3d 40 00 00 	mov	#0,	r13	;
    82aa:	0d 93       	cmp	#0,	r13	;r3 As==00
    82ac:	03 24       	jz	$+8      	;abs 0x82b4
    82ae:	3c 40 6c 80 	mov	#32876,	r12	;#0x806c
    82b2:	8d 12       	call	r13		;

000082b4 <.L21>:
    82b4:	d2 43 7e 40 	mov.b	#1,	&0x407e	;r3 As==01

000082b8 <.L17>:
    82b8:	30 40 08 92 	br	#0x9208		;

000082bc <.L20>:
    82bc:	1c 53       	inc	r12		;
    82be:	82 4c 80 40 	mov	r12,	&0x4080	;
    82c2:	0c 5c       	rla	r12		;
    82c4:	0c 59       	add	r9,	r12	;
    82c6:	2c 4c       	mov	@r12,	r12	;
    82c8:	8c 12       	call	r12		;
    82ca:	30 40 9a 82 	br	#0x829a		;

000082ce <frame_dummy>:
    82ce:	3e 40 00 00 	mov	#0,	r14	;
    82d2:	0e 93       	cmp	#0,	r14	;r3 As==00
    82d4:	05 24       	jz	$+12     	;abs 0x82e0
    82d6:	3d 40 82 40 	mov	#16514,	r13	;#0x4082
    82da:	3c 40 6c 80 	mov	#32876,	r12	;#0x806c
    82de:	8e 12       	call	r14		;

000082e0 <.L27>:
    82e0:	b0 12 52 82 	call	#33362		;#0x8252
    82e4:	30 41       	ret			

000082e6 <sqrt16>:


/* Sqrt.c */
/* Square root by Newton's method */
uint16_t sqrt16(uint32_t x)
{
    82e6:	0a 12       	push	r10		;

000082e8 <.LCFI0>:
    82e8:	09 12       	push	r9		;

000082ea <.LCFI1>:
    82ea:	08 12       	push	r8		;

000082ec <.LCFI2>:
    82ec:	07 12       	push	r7		;

000082ee <.LCFI3>:
    82ee:	06 12       	push	r6		;

000082f0 <.LCFI4>:
    82f0:	05 12       	push	r5		;

000082f2 <.LCFI5>:
    82f2:	31 80 1e 00 	sub	#30,	r1	;#0x001e

000082f6 <.LCFI6>:
    82f6:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    82fa:	81 4d 12 00 	mov	r13,	18(r1)	; 0x0012

000082fe <.Loc.31.1>:
    uint16_t hi = 0xffff;
    82fe:	b1 43 1c 00 	mov	#-1,	28(r1)	;r3 As==11, 0x001c

00008302 <.Loc.32.1>:
    uint16_t lo = 0;
    8302:	81 43 1a 00 	mov	#0,	26(r1)	;r3 As==00, 0x001a

00008306 <.Loc.33.1>:
    uint16_t mid = ((uint32_t)hi + (uint32_t)lo) >> 1;
    8306:	1c 41 1c 00 	mov	28(r1),	r12	;0x0001c
    830a:	05 4c       	mov	r12,	r5	;
    830c:	46 43       	clr.b	r6		;
    830e:	1c 41 1a 00 	mov	26(r1),	r12	;0x0001a
    8312:	0e 4c       	mov	r12,	r14	;
    8314:	4f 43       	clr.b	r15		;
    8316:	0c 45       	mov	r5,	r12	;
    8318:	0c 5e       	add	r14,	r12	;
    831a:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    831e:	0c 46       	mov	r6,	r12	;
    8320:	0c 6f       	addc	r15,	r12	;
    8322:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    8326:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    832a:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    832e:	12 c3       	clrc			
    8330:	0d 10       	rrc	r13		;
    8332:	0c 10       	rrc	r12		;
    8334:	81 4c 18 00 	mov	r12,	24(r1)	; 0x0018

00008338 <.Loc.34.1>:
    uint32_t s = 0;
    8338:	81 43 14 00 	mov	#0,	20(r1)	;r3 As==00, 0x0014
    833c:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00008340 <.Loc.36.1>:

    while (s != x && hi - lo > 1) {
    8340:	30 40 d0 83 	br	#0x83d0		;

00008344 <.L7>:
        mid = ((uint32_t)hi + (uint32_t)lo) >> 1;
    8344:	1c 41 1c 00 	mov	28(r1),	r12	;0x0001c
    8348:	09 4c       	mov	r12,	r9	;
    834a:	4a 43       	clr.b	r10		;
    834c:	1c 41 1a 00 	mov	26(r1),	r12	;0x0001a
    8350:	07 4c       	mov	r12,	r7	;
    8352:	48 43       	clr.b	r8		;
    8354:	0c 49       	mov	r9,	r12	;
    8356:	0c 57       	add	r7,	r12	;
    8358:	81 4c 08 00 	mov	r12,	8(r1)	;
    835c:	0c 4a       	mov	r10,	r12	;
    835e:	0c 68       	addc	r8,	r12	;
    8360:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    8364:	1c 41 08 00 	mov	8(r1),	r12	;
    8368:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    836c:	12 c3       	clrc			
    836e:	0d 10       	rrc	r13		;
    8370:	0c 10       	rrc	r12		;
    8372:	81 4c 18 00 	mov	r12,	24(r1)	; 0x0018

00008376 <.Loc.38.1>:
        s = (uint32_t)mid* (uint32_t)mid;
    8376:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    837a:	81 4c 04 00 	mov	r12,	4(r1)	;
    837e:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    8382:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    8386:	81 4c 00 00 	mov	r12,	0(r1)	;
    838a:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    838e:	2e 41       	mov	@r1,	r14	;
    8390:	1f 41 02 00 	mov	2(r1),	r15	;
    8394:	1c 41 04 00 	mov	4(r1),	r12	;
    8398:	1d 41 06 00 	mov	6(r1),	r13	;
    839c:	b0 12 d6 92 	call	#37590		;#0x92d6
    83a0:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    83a4:	81 4d 16 00 	mov	r13,	22(r1)	; 0x0016

000083a8 <.Loc.39.1>:
        if (s < x)
    83a8:	91 91 12 00 	cmp	18(r1),	22(r1)	;0x00012, 0x0016
    83ac:	16 00 
    83ae:	08 28       	jnc	$+18     	;abs 0x83c0
    83b0:	91 91 16 00 	cmp	22(r1),	18(r1)	;0x00016, 0x0012
    83b4:	12 00 
    83b6:	09 20       	jnz	$+20     	;abs 0x83ca
    83b8:	91 91 10 00 	cmp	16(r1),	20(r1)	;0x00010, 0x0014
    83bc:	14 00 
    83be:	05 2c       	jc	$+12     	;abs 0x83ca

000083c0 <.L9>:
            lo = mid;
    83c0:	91 41 18 00 	mov	24(r1),	26(r1)	;0x00018, 0x001a
    83c4:	1a 00 
    83c6:	30 40 d0 83 	br	#0x83d0		;

000083ca <.L3>:
        else
            hi = mid;
    83ca:	91 41 18 00 	mov	24(r1),	28(r1)	;0x00018, 0x001c
    83ce:	1c 00 

000083d0 <.L2>:
    uint16_t hi = 0xffff;
    uint16_t lo = 0;
    uint16_t mid = ((uint32_t)hi + (uint32_t)lo) >> 1;
    uint32_t s = 0;

    while (s != x && hi - lo > 1) {
    83d0:	91 91 10 00 	cmp	16(r1),	20(r1)	;0x00010, 0x0014
    83d4:	14 00 
    83d6:	04 20       	jnz	$+10     	;abs 0x83e0
    83d8:	91 91 12 00 	cmp	18(r1),	22(r1)	;0x00012, 0x0016
    83dc:	16 00 
    83de:	07 24       	jz	$+16     	;abs 0x83ee

000083e0 <.L10>:
    83e0:	1d 41 1c 00 	mov	28(r1),	r13	;0x0001c
    83e4:	1d 81 1a 00 	sub	26(r1),	r13	;0x0001a
    83e8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    83ea:	0c 9d       	cmp	r13,	r12	;
    83ec:	ab 2b       	jnc	$-168    	;abs 0x8344

000083ee <.L5>:
            lo = mid;
        else
            hi = mid;
    }

    return mid;
    83ee:	1c 41 18 00 	mov	24(r1),	r12	;0x00018

000083f2 <.Loc.46.1>:
}
    83f2:	31 50 1e 00 	add	#30,	r1	;#0x001e
    83f6:	30 40 00 92 	br	#0x9200		;

000083fa <ACCEL_singleSample>:
//NVM model_t model;

unsigned int count = 1;
model_t model;

void ACCEL_singleSample(threeAxis_t_8* result){
    83fa:	21 82       	sub	#4,	r1	;r2 As==10

000083fc <.LCFI7>:
    83fc:	81 4c 00 00 	mov	r12,	0(r1)	;

00008400 <.Loc.136.1>:

    //NVM static unsigned int _v_seed = 1;
    static unsigned int _v_seed = 1;

    unsigned int seed = _v_seed;
    8400:	91 42 04 40 	mov	&0x4004,2(r1)	;0x4004
    8404:	02 00 

00008406 <.Loc.138.1>:

    result->x = (seed*17)%85;
    8406:	1d 41 02 00 	mov	2(r1),	r13	;
    840a:	0c 4d       	mov	r13,	r12	;
    840c:	0c 5c       	rla	r12		;
    840e:	0c 5c       	rla	r12		;
    8410:	0c 5c       	rla	r12		;
    8412:	0c 5c       	rla	r12		;
    8414:	0c 5d       	add	r13,	r12	;
    8416:	7d 40 55 00 	mov.b	#85,	r13	;#0x0055
    841a:	b0 12 f6 91 	call	#37366		;#0x91f6
    841e:	4d 4c       	mov.b	r12,	r13	;
    8420:	2c 41       	mov	@r1,	r12	;
    8422:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00008426 <.Loc.139.1>:
    result->y = (seed*17*17)%85;
    8426:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    842a:	1c 41 02 00 	mov	2(r1),	r12	;
    842e:	b0 12 c2 92 	call	#37570		;#0x92c2
    8432:	7d 40 55 00 	mov.b	#85,	r13	;#0x0055
    8436:	b0 12 f6 91 	call	#37366		;#0x91f6
    843a:	4d 4c       	mov.b	r12,	r13	;
    843c:	2c 41       	mov	@r1,	r12	;
    843e:	cc 4d 01 00 	mov.b	r13,	1(r12)	;

00008442 <.Loc.140.1>:
    result->z = (seed*17*17*17)%85;
    8442:	3d 40 31 13 	mov	#4913,	r13	;#0x1331
    8446:	1c 41 02 00 	mov	2(r1),	r12	;
    844a:	b0 12 c2 92 	call	#37570		;#0x92c2
    844e:	7d 40 55 00 	mov.b	#85,	r13	;#0x0055
    8452:	b0 12 f6 91 	call	#37366		;#0x91f6
    8456:	4d 4c       	mov.b	r12,	r13	;
    8458:	2c 41       	mov	@r1,	r12	;
    845a:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

0000845e <.Loc.141.1>:
    _v_seed = ++seed;
    845e:	91 53 02 00 	inc	2(r1)		;
    8462:	92 41 02 00 	mov	2(r1),	&0x4004	;
    8466:	04 40 

00008468 <.Loc.142.1>:
}
    8468:	03 43       	nop			
    846a:	21 52       	add	#4,	r1	;r2 As==10
    846c:	30 41       	ret			

0000846e <acquire_window>:


#define accel_sample ACCEL_singleSample

void acquire_window(accelWindow window)
{
    846e:	31 82       	sub	#8,	r1	;r2 As==11

00008470 <.LCFI8>:
    8470:	81 4c 00 00 	mov	r12,	0(r1)	;

00008474 <.Loc.150.1>:
    accelReading sample;
    unsigned samplesInWindow = 0;
    8474:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00008478 <.Loc.154.1>:

    TASK_CHECKPOINT();

    while (samplesInWindow < ACCEL_WINDOW_SIZE) {
    8478:	30 40 ac 84 	br	#0x84ac		;

0000847c <.L14>:
        accel_sample(&sample);
    847c:	0c 41       	mov	r1,	r12	;
    847e:	3c 50 03 00 	add	#3,	r12	;
    8482:	b0 12 fa 83 	call	#33786		;#0x83fa

00008486 <.Loc.158.1>:
        LOG("acquire: sample %u %u %u\r\n", sample.x, sample.y, sample.z);

        window[samplesInWindow++] = sample;
    8486:	1d 41 06 00 	mov	6(r1),	r13	;
    848a:	0c 4d       	mov	r13,	r12	;
    848c:	1c 53       	inc	r12		;
    848e:	81 4c 06 00 	mov	r12,	6(r1)	;
    8492:	0c 4d       	mov	r13,	r12	;
    8494:	0c 5c       	rla	r12		;
    8496:	0c 5d       	add	r13,	r12	;
    8498:	2c 51       	add	@r1,	r12	;
    849a:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    849e:	00 00 
    84a0:	dc 41 04 00 	mov.b	4(r1),	1(r12)	;
    84a4:	01 00 
    84a6:	dc 41 05 00 	mov.b	5(r1),	2(r12)	;
    84aa:	02 00 

000084ac <.L13>:
    accelReading sample;
    unsigned samplesInWindow = 0;

    TASK_CHECKPOINT();

    while (samplesInWindow < ACCEL_WINDOW_SIZE) {
    84ac:	6c 43       	mov.b	#2,	r12	;r3 As==10
    84ae:	1c 91 06 00 	cmp	6(r1),	r12	;
    84b2:	e4 2f       	jc	$-54     	;abs 0x847c

000084b4 <.Loc.160.1>:
        accel_sample(&sample);
        LOG("acquire: sample %u %u %u\r\n", sample.x, sample.y, sample.z);

        window[samplesInWindow++] = sample;
    }
}
    84b4:	03 43       	nop			
    84b6:	31 52       	add	#8,	r1	;r2 As==11
    84b8:	30 41       	ret			

000084ba <transform>:

void transform(accelWindow window)
{
    84ba:	31 80 06 00 	sub	#6,	r1	;

000084be <.LCFI9>:
    84be:	81 4c 00 00 	mov	r12,	0(r1)	;

000084c2 <.Loc.164.1>:
    unsigned i = 0;
    84c2:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

000084c6 <.Loc.168.1>:

    LOG("transform\r\n");

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    84c6:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    84ca:	30 40 80 85 	br	#0x8580		;

000084ce <.L25>:
        accelReading *sample = &window[i];
    84ce:	1d 41 04 00 	mov	4(r1),	r13	;
    84d2:	0c 4d       	mov	r13,	r12	;
    84d4:	0c 5c       	rla	r12		;
    84d6:	0c 5d       	add	r13,	r12	;
    84d8:	2d 41       	mov	@r1,	r13	;
    84da:	0d 5c       	add	r12,	r13	;
    84dc:	81 4d 02 00 	mov	r13,	2(r1)	;

000084e0 <.Loc.171.1>:

        if (sample->x < SAMPLE_NOISE_FLOOR ||
    84e0:	1c 41 02 00 	mov	2(r1),	r12	;
    84e4:	6c 4c       	mov.b	@r12,	r12	;
    84e6:	7d 40 09 00 	mov.b	#9,	r13	;
    84ea:	4d 9c       	cmp.b	r12,	r13	;
    84ec:	10 2c       	jc	$+34     	;abs 0x850e

000084ee <.Loc.172.1>:
            sample->y < SAMPLE_NOISE_FLOOR ||
    84ee:	1c 41 02 00 	mov	2(r1),	r12	;
    84f2:	5c 4c 01 00 	mov.b	1(r12),	r12	;

000084f6 <.Loc.171.1>:
    LOG("transform\r\n");

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        accelReading *sample = &window[i];

        if (sample->x < SAMPLE_NOISE_FLOOR ||
    84f6:	7d 40 09 00 	mov.b	#9,	r13	;
    84fa:	4d 9c       	cmp.b	r12,	r13	;
    84fc:	08 2c       	jc	$+18     	;abs 0x850e

000084fe <.Loc.173.1>:
            sample->y < SAMPLE_NOISE_FLOOR ||
            sample->z < SAMPLE_NOISE_FLOOR) {
    84fe:	1c 41 02 00 	mov	2(r1),	r12	;
    8502:	5c 4c 02 00 	mov.b	2(r12),	r12	;

00008506 <.Loc.172.1>:

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        accelReading *sample = &window[i];

        if (sample->x < SAMPLE_NOISE_FLOOR ||
            sample->y < SAMPLE_NOISE_FLOOR ||
    8506:	7d 40 09 00 	mov.b	#9,	r13	;
    850a:	4d 9c       	cmp.b	r12,	r13	;
    850c:	37 28       	jnc	$+112    	;abs 0x857c

0000850e <.L17>:
            sample->z < SAMPLE_NOISE_FLOOR) {

            LOG("transform: sample %u %u %u\r\n",
                sample->x, sample->y, sample->z);

            sample->x = (sample->x > SAMPLE_NOISE_FLOOR) ? sample->x : 0;
    850e:	1c 41 02 00 	mov	2(r1),	r12	;
    8512:	6c 4c       	mov.b	@r12,	r12	;
    8514:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8518:	4d 9c       	cmp.b	r12,	r13	;
    851a:	05 2c       	jc	$+12     	;abs 0x8526

0000851c <.Loc.178.1>:
    851c:	1c 41 02 00 	mov	2(r1),	r12	;
    8520:	6c 4c       	mov.b	@r12,	r12	;
    8522:	30 40 28 85 	br	#0x8528		;

00008526 <.L19>:
    8526:	4c 43       	clr.b	r12		;

00008528 <.L20>:
    8528:	1d 41 02 00 	mov	2(r1),	r13	;
    852c:	cd 4c 00 00 	mov.b	r12,	0(r13)	;

00008530 <.Loc.179.1>:
            sample->y = (sample->y > SAMPLE_NOISE_FLOOR) ? sample->y : 0;
    8530:	1c 41 02 00 	mov	2(r1),	r12	;
    8534:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8538:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    853c:	4d 9c       	cmp.b	r12,	r13	;
    853e:	06 2c       	jc	$+14     	;abs 0x854c

00008540 <.Loc.179.1>:
    8540:	1c 41 02 00 	mov	2(r1),	r12	;
    8544:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8548:	30 40 4e 85 	br	#0x854e		;

0000854c <.L21>:
    854c:	4c 43       	clr.b	r12		;

0000854e <.L22>:
    854e:	1d 41 02 00 	mov	2(r1),	r13	;
    8552:	cd 4c 01 00 	mov.b	r12,	1(r13)	;

00008556 <.Loc.180.1>:
            sample->z = (sample->z > SAMPLE_NOISE_FLOOR) ? sample->z : 0;
    8556:	1c 41 02 00 	mov	2(r1),	r12	;
    855a:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    855e:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8562:	4d 9c       	cmp.b	r12,	r13	;
    8564:	06 2c       	jc	$+14     	;abs 0x8572

00008566 <.Loc.180.1>:
    8566:	1c 41 02 00 	mov	2(r1),	r12	;
    856a:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    856e:	30 40 74 85 	br	#0x8574		;

00008572 <.L23>:
    8572:	4c 43       	clr.b	r12		;

00008574 <.L24>:
    8574:	1d 41 02 00 	mov	2(r1),	r13	;
    8578:	cd 4c 02 00 	mov.b	r12,	2(r13)	;

0000857c <.L18>:
{
    unsigned i = 0;

    LOG("transform\r\n");

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    857c:	91 53 04 00 	inc	4(r1)		;

00008580 <.L16>:
    8580:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8582:	1c 91 04 00 	cmp	4(r1),	r12	;
    8586:	a3 2f       	jc	$-184    	;abs 0x84ce

00008588 <.Loc.183.1>:
            sample->x = (sample->x > SAMPLE_NOISE_FLOOR) ? sample->x : 0;
            sample->y = (sample->y > SAMPLE_NOISE_FLOOR) ? sample->y : 0;
            sample->z = (sample->z > SAMPLE_NOISE_FLOOR) ? sample->z : 0;
        }
    }
}
    8588:	03 43       	nop			
    858a:	31 50 06 00 	add	#6,	r1	;
    858e:	30 41       	ret			

00008590 <featurize>:

void featurize(features_t *features, accelWindow aWin)
{
    8590:	0a 12       	push	r10		;

00008592 <.LCFI10>:
    8592:	09 12       	push	r9		;

00008594 <.LCFI11>:
    8594:	08 12       	push	r8		;

00008596 <.LCFI12>:
    8596:	07 12       	push	r7		;

00008598 <.LCFI13>:
    8598:	06 12       	push	r6		;

0000859a <.LCFI14>:
    859a:	31 80 10 00 	sub	#16,	r1	;#0x0010

0000859e <.LCFI15>:
    859e:	81 4c 02 00 	mov	r12,	2(r1)	;
    85a2:	81 4d 00 00 	mov	r13,	0(r1)	;

000085a6 <.Loc.192.1>:
    TASK_CHECKPOINT();

    accelReading mean;
    accelReading stddev;

    mean.x = mean.y = mean.z = 0;
    85a6:	c1 43 09 00 	mov.b	#0,	9(r1)	;r3 As==00
    85aa:	5c 41 09 00 	mov.b	9(r1),	r12	;
    85ae:	c1 4c 08 00 	mov.b	r12,	8(r1)	;
    85b2:	5c 41 08 00 	mov.b	8(r1),	r12	;
    85b6:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

000085ba <.Loc.193.1>:
    stddev.x = stddev.y = stddev.z = 0;
    85ba:	c1 43 06 00 	mov.b	#0,	6(r1)	;r3 As==00
    85be:	5c 41 06 00 	mov.b	6(r1),	r12	;
    85c2:	c1 4c 05 00 	mov.b	r12,	5(r1)	;
    85c6:	5c 41 05 00 	mov.b	5(r1),	r12	;
    85ca:	c1 4c 04 00 	mov.b	r12,	4(r1)	;

000085ce <.Loc.195.1>:
    int i;
    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    85ce:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    85d2:	30 40 32 86 	br	#0x8632		;

000085d6 <.L28>:
        mean.x += aWin[i].x;  // x
    85d6:	5e 41 07 00 	mov.b	7(r1),	r14	;
    85da:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    85de:	0c 4d       	mov	r13,	r12	;
    85e0:	0c 5c       	rla	r12		;
    85e2:	0c 5d       	add	r13,	r12	;
    85e4:	2c 51       	add	@r1,	r12	;
    85e6:	6c 4c       	mov.b	@r12,	r12	;
    85e8:	4c 5e       	add.b	r14,	r12	;
    85ea:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    85ee:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

000085f2 <.Loc.197.1>:
        mean.y += aWin[i].y;  // y
    85f2:	5e 41 08 00 	mov.b	8(r1),	r14	;
    85f6:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    85fa:	0c 4d       	mov	r13,	r12	;
    85fc:	0c 5c       	rla	r12		;
    85fe:	0c 5d       	add	r13,	r12	;
    8600:	2c 51       	add	@r1,	r12	;
    8602:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8606:	4c 5e       	add.b	r14,	r12	;
    8608:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    860c:	c1 4c 08 00 	mov.b	r12,	8(r1)	;

00008610 <.Loc.198.1>:
        mean.z += aWin[i].z;  // z
    8610:	5e 41 09 00 	mov.b	9(r1),	r14	;
    8614:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8618:	0c 4d       	mov	r13,	r12	;
    861a:	0c 5c       	rla	r12		;
    861c:	0c 5d       	add	r13,	r12	;
    861e:	2c 51       	add	@r1,	r12	;
    8620:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8624:	4c 5e       	add.b	r14,	r12	;
    8626:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    862a:	c1 4c 09 00 	mov.b	r12,	9(r1)	;

0000862e <.Loc.195.1>:
    accelReading stddev;

    mean.x = mean.y = mean.z = 0;
    stddev.x = stddev.y = stddev.z = 0;
    int i;
    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    862e:	91 53 0e 00 	inc	14(r1)		;

00008632 <.L27>:
    8632:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8634:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    8638:	ce 37       	jge	$-98     	;abs 0x85d6

0000863a <.Loc.205.1>:
    /*
       mean.x = mean.x / ACCEL_WINDOW_SIZE;
       mean.y = mean.y / ACCEL_WINDOW_SIZE;
       mean.z = mean.z / ACCEL_WINDOW_SIZE;
       */
    mean.x >>= 2;
    863a:	5c 41 07 00 	mov.b	7(r1),	r12	;
    863e:	b0 12 42 92 	call	#37442		;#0x9242
    8642:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8646:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

0000864a <.Loc.206.1>:
    mean.y >>= 2;
    864a:	5c 41 08 00 	mov.b	8(r1),	r12	;
    864e:	b0 12 42 92 	call	#37442		;#0x9242
    8652:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8656:	c1 4c 08 00 	mov.b	r12,	8(r1)	;

0000865a <.Loc.207.1>:
    mean.z >>= 2;
    865a:	5c 41 09 00 	mov.b	9(r1),	r12	;
    865e:	b0 12 42 92 	call	#37442		;#0x9242
    8662:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8666:	c1 4c 09 00 	mov.b	r12,	9(r1)	;

0000866a <.Loc.209.1>:

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    866a:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    866e:	30 40 84 87 	br	#0x8784		;

00008672 <.L36>:
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
    8672:	5e 41 04 00 	mov.b	4(r1),	r14	;
    8676:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    867a:	0c 4d       	mov	r13,	r12	;
    867c:	0c 5c       	rla	r12		;
    867e:	0c 5d       	add	r13,	r12	;
    8680:	2c 51       	add	@r1,	r12	;
    8682:	6c 4c       	mov.b	@r12,	r12	;
    8684:	5d 41 07 00 	mov.b	7(r1),	r13	;
    8688:	4d 9c       	cmp.b	r12,	r13	;
    868a:	0d 2c       	jc	$+28     	;abs 0x86a6

0000868c <.Loc.210.1>:
    868c:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8690:	0c 4d       	mov	r13,	r12	;
    8692:	0c 5c       	rla	r12		;
    8694:	0c 5d       	add	r13,	r12	;
    8696:	2c 51       	add	@r1,	r12	;
    8698:	6d 4c       	mov.b	@r12,	r13	;
    869a:	5c 41 07 00 	mov.b	7(r1),	r12	;
    869e:	4d 8c       	sub.b	r12,	r13	;
    86a0:	4c 4d       	mov.b	r13,	r12	;
    86a2:	30 40 be 86 	br	#0x86be		;

000086a6 <.L30>:
            : mean.x - aWin[i].x;  // x
    86a6:	5f 41 07 00 	mov.b	7(r1),	r15	;
    86aa:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    86ae:	0c 4d       	mov	r13,	r12	;
    86b0:	0c 5c       	rla	r12		;
    86b2:	0c 5d       	add	r13,	r12	;
    86b4:	2c 51       	add	@r1,	r12	;
    86b6:	6c 4c       	mov.b	@r12,	r12	;

000086b8 <.Loc.210.1>:
    mean.x >>= 2;
    mean.y >>= 2;
    mean.z >>= 2;

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
    86b8:	4d 4f       	mov.b	r15,	r13	;
    86ba:	4d 8c       	sub.b	r12,	r13	;
    86bc:	4c 4d       	mov.b	r13,	r12	;

000086be <.L31>:
    86be:	4c 5e       	add.b	r14,	r12	;
    86c0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86c4:	c1 4c 04 00 	mov.b	r12,	4(r1)	;

000086c8 <.Loc.212.1>:
            : mean.x - aWin[i].x;  // x
        stddev.y += aWin[i].y > mean.y ? aWin[i].y - mean.y
    86c8:	5e 41 05 00 	mov.b	5(r1),	r14	;
    86cc:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    86d0:	0c 4d       	mov	r13,	r12	;
    86d2:	0c 5c       	rla	r12		;
    86d4:	0c 5d       	add	r13,	r12	;
    86d6:	2c 51       	add	@r1,	r12	;
    86d8:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    86dc:	5d 41 08 00 	mov.b	8(r1),	r13	;
    86e0:	4d 9c       	cmp.b	r12,	r13	;
    86e2:	0e 2c       	jc	$+30     	;abs 0x8700

000086e4 <.Loc.212.1>:
    86e4:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    86e8:	0c 4d       	mov	r13,	r12	;
    86ea:	0c 5c       	rla	r12		;
    86ec:	0c 5d       	add	r13,	r12	;
    86ee:	2c 51       	add	@r1,	r12	;
    86f0:	5d 4c 01 00 	mov.b	1(r12),	r13	;
    86f4:	5c 41 08 00 	mov.b	8(r1),	r12	;
    86f8:	4d 8c       	sub.b	r12,	r13	;
    86fa:	4c 4d       	mov.b	r13,	r12	;
    86fc:	30 40 1a 87 	br	#0x871a		;

00008700 <.L32>:
            : mean.y - aWin[i].y;  // y
    8700:	5f 41 08 00 	mov.b	8(r1),	r15	;
    8704:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8708:	0c 4d       	mov	r13,	r12	;
    870a:	0c 5c       	rla	r12		;
    870c:	0c 5d       	add	r13,	r12	;
    870e:	2c 51       	add	@r1,	r12	;
    8710:	5c 4c 01 00 	mov.b	1(r12),	r12	;

00008714 <.Loc.212.1>:
    mean.z >>= 2;

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
            : mean.x - aWin[i].x;  // x
        stddev.y += aWin[i].y > mean.y ? aWin[i].y - mean.y
    8714:	4d 4f       	mov.b	r15,	r13	;
    8716:	4d 8c       	sub.b	r12,	r13	;
    8718:	4c 4d       	mov.b	r13,	r12	;

0000871a <.L33>:
    871a:	4c 5e       	add.b	r14,	r12	;
    871c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8720:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00008724 <.Loc.214.1>:
            : mean.y - aWin[i].y;  // y
        stddev.z += aWin[i].z > mean.z ? aWin[i].z - mean.z
    8724:	5e 41 06 00 	mov.b	6(r1),	r14	;
    8728:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    872c:	0c 4d       	mov	r13,	r12	;
    872e:	0c 5c       	rla	r12		;
    8730:	0c 5d       	add	r13,	r12	;
    8732:	2c 51       	add	@r1,	r12	;
    8734:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8738:	5d 41 09 00 	mov.b	9(r1),	r13	;
    873c:	4d 9c       	cmp.b	r12,	r13	;
    873e:	0e 2c       	jc	$+30     	;abs 0x875c

00008740 <.Loc.214.1>:
    8740:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8744:	0c 4d       	mov	r13,	r12	;
    8746:	0c 5c       	rla	r12		;
    8748:	0c 5d       	add	r13,	r12	;
    874a:	2c 51       	add	@r1,	r12	;
    874c:	5d 4c 02 00 	mov.b	2(r12),	r13	;
    8750:	5c 41 09 00 	mov.b	9(r1),	r12	;
    8754:	4d 8c       	sub.b	r12,	r13	;
    8756:	4c 4d       	mov.b	r13,	r12	;
    8758:	30 40 76 87 	br	#0x8776		;

0000875c <.L34>:
            : mean.z - aWin[i].z;  // z
    875c:	5f 41 09 00 	mov.b	9(r1),	r15	;
    8760:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8764:	0c 4d       	mov	r13,	r12	;
    8766:	0c 5c       	rla	r12		;
    8768:	0c 5d       	add	r13,	r12	;
    876a:	2c 51       	add	@r1,	r12	;
    876c:	5c 4c 02 00 	mov.b	2(r12),	r12	;

00008770 <.Loc.214.1>:
    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
            : mean.x - aWin[i].x;  // x
        stddev.y += aWin[i].y > mean.y ? aWin[i].y - mean.y
            : mean.y - aWin[i].y;  // y
        stddev.z += aWin[i].z > mean.z ? aWin[i].z - mean.z
    8770:	4d 4f       	mov.b	r15,	r13	;
    8772:	4d 8c       	sub.b	r12,	r13	;
    8774:	4c 4d       	mov.b	r13,	r12	;

00008776 <.L35>:
    8776:	4c 5e       	add.b	r14,	r12	;
    8778:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    877c:	c1 4c 06 00 	mov.b	r12,	6(r1)	;

00008780 <.Loc.209.1>:
       */
    mean.x >>= 2;
    mean.y >>= 2;
    mean.z >>= 2;

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    8780:	91 53 0e 00 	inc	14(r1)		;

00008784 <.L29>:
    8784:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8786:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    878a:	73 37       	jge	$-280    	;abs 0x8672

0000878c <.Loc.222.1>:
    /*
       stddev.x = stddev.x / (ACCEL_WINDOW_SIZE - 1);
       stddev.y = stddev.y / (ACCEL_WINDOW_SIZE - 1);
       stddev.z = stddev.z / (ACCEL_WINDOW_SIZE - 1);
       */
    stddev.x >>= 2;
    878c:	5c 41 04 00 	mov.b	4(r1),	r12	;
    8790:	b0 12 42 92 	call	#37442		;#0x9242
    8794:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8798:	c1 4c 04 00 	mov.b	r12,	4(r1)	;

0000879c <.Loc.223.1>:
    stddev.y >>= 2;
    879c:	5c 41 05 00 	mov.b	5(r1),	r12	;
    87a0:	b0 12 42 92 	call	#37442		;#0x9242
    87a4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    87a8:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

000087ac <.Loc.224.1>:
    stddev.z >>= 2;
    87ac:	5c 41 06 00 	mov.b	6(r1),	r12	;
    87b0:	b0 12 42 92 	call	#37442		;#0x9242
    87b4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    87b8:	c1 4c 06 00 	mov.b	r12,	6(r1)	;

000087bc <.Loc.226.1>:

    unsigned meanmag = mean.x*mean.x + mean.y*mean.y + mean.z*mean.z;
    87bc:	5c 41 07 00 	mov.b	7(r1),	r12	;
    87c0:	5d 41 07 00 	mov.b	7(r1),	r13	;
    87c4:	b0 12 c2 92 	call	#37570		;#0x92c2
    87c8:	06 4c       	mov	r12,	r6	;
    87ca:	5c 41 08 00 	mov.b	8(r1),	r12	;
    87ce:	5d 41 08 00 	mov.b	8(r1),	r13	;
    87d2:	b0 12 c2 92 	call	#37570		;#0x92c2
    87d6:	06 5c       	add	r12,	r6	;
    87d8:	5c 41 09 00 	mov.b	9(r1),	r12	;
    87dc:	5d 41 09 00 	mov.b	9(r1),	r13	;
    87e0:	b0 12 c2 92 	call	#37570		;#0x92c2
    87e4:	0c 56       	add	r6,	r12	;
    87e6:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

000087ea <.Loc.227.1>:
    unsigned stddevmag = stddev.x*stddev.x + stddev.y*stddev.y + stddev.z*stddev.z;
    87ea:	5c 41 04 00 	mov.b	4(r1),	r12	;
    87ee:	5d 41 04 00 	mov.b	4(r1),	r13	;
    87f2:	b0 12 c2 92 	call	#37570		;#0x92c2
    87f6:	06 4c       	mov	r12,	r6	;
    87f8:	5c 41 05 00 	mov.b	5(r1),	r12	;
    87fc:	5d 41 05 00 	mov.b	5(r1),	r13	;
    8800:	b0 12 c2 92 	call	#37570		;#0x92c2
    8804:	06 5c       	add	r12,	r6	;
    8806:	5c 41 06 00 	mov.b	6(r1),	r12	;
    880a:	5d 41 06 00 	mov.b	6(r1),	r13	;
    880e:	b0 12 c2 92 	call	#37570		;#0x92c2
    8812:	0c 56       	add	r6,	r12	;
    8814:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00008818 <.Loc.229.1>:

    features->meanmag   = sqrt16(meanmag);
    8818:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    881c:	07 4c       	mov	r12,	r7	;
    881e:	48 43       	clr.b	r8		;
    8820:	0c 47       	mov	r7,	r12	;
    8822:	0d 48       	mov	r8,	r13	;
    8824:	b0 12 e6 82 	call	#33510		;#0x82e6
    8828:	0d 4c       	mov	r12,	r13	;
    882a:	1c 41 02 00 	mov	2(r1),	r12	;
    882e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008832 <.Loc.230.1>:
    features->stddevmag = sqrt16(stddevmag);
    8832:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    8836:	09 4c       	mov	r12,	r9	;
    8838:	4a 43       	clr.b	r10		;
    883a:	0c 49       	mov	r9,	r12	;
    883c:	0d 4a       	mov	r10,	r13	;
    883e:	b0 12 e6 82 	call	#33510		;#0x82e6
    8842:	0d 4c       	mov	r12,	r13	;
    8844:	1c 41 02 00 	mov	2(r1),	r12	;
    8848:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000884c <.Loc.233.1>:

    LOG("featurize: mean %u sd %u\r\n", features->meanmag, features->stddevmag);
}
    884c:	03 43       	nop			
    884e:	31 50 10 00 	add	#16,	r1	;#0x0010
    8852:	30 40 02 92 	br	#0x9202		;

00008856 <classify>:

class_t classify(features_t *features, model_t *model)
{
    8856:	31 80 1e 00 	sub	#30,	r1	;#0x001e

0000885a <.LCFI16>:
    885a:	81 4c 02 00 	mov	r12,	2(r1)	;
    885e:	81 4d 00 00 	mov	r13,	0(r1)	;

00008862 <.Loc.237.1>:
    int move_less_error = 0;
    8862:	81 43 1c 00 	mov	#0,	28(r1)	;r3 As==00, 0x001c

00008866 <.Loc.238.1>:
    int stat_less_error = 0;
    8866:	81 43 1a 00 	mov	#0,	26(r1)	;r3 As==00, 0x001a

0000886a <.Loc.244.1>:
    features_t *model_features;
    int i;

    TASK_CHECKPOINT();

    for (i = 0; i < MODEL_SIZE; ++i) {
    886a:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018
    886e:	30 40 ea 89 	br	#0x89ea		;

00008872 <.L53>:
        model_features = &model->stationary[i];
    8872:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    8876:	0c 5c       	rla	r12		;
    8878:	0c 5c       	rla	r12		;
    887a:	2d 41       	mov	@r1,	r13	;
    887c:	0d 5c       	add	r12,	r13	;
    887e:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

00008882 <.Loc.247.1>:

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
    8882:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8886:	2d 4c       	mov	@r12,	r13	;
    8888:	1c 41 02 00 	mov	2(r1),	r12	;
    888c:	2c 4c       	mov	@r12,	r12	;

0000888e <.Loc.249.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);
    888e:	0c 9d       	cmp	r13,	r12	;
    8890:	0a 2c       	jc	$+22     	;abs 0x88a6

00008892 <.Loc.248.1>:

    for (i = 0; i < MODEL_SIZE; ++i) {
        model_features = &model->stationary[i];

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
    8892:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8896:	2e 4c       	mov	@r12,	r14	;
    8898:	1c 41 02 00 	mov	2(r1),	r12	;
    889c:	2d 4c       	mov	@r12,	r13	;

0000889e <.Loc.249.1>:
            : (features->meanmag - model_features->meanmag);
    889e:	0c 4e       	mov	r14,	r12	;
    88a0:	0c 8d       	sub	r13,	r12	;
    88a2:	30 40 b6 88 	br	#0x88b6		;

000088a6 <.L39>:
    88a6:	1c 41 02 00 	mov	2(r1),	r12	;
    88aa:	2e 4c       	mov	@r12,	r14	;
    88ac:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    88b0:	2d 4c       	mov	@r12,	r13	;
    88b2:	0c 4e       	mov	r14,	r12	;
    88b4:	0c 8d       	sub	r13,	r12	;

000088b6 <.L40>:
    TASK_CHECKPOINT();

    for (i = 0; i < MODEL_SIZE; ++i) {
        model_features = &model->stationary[i];

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
    88b6:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    88ba:	81 43 12 00 	mov	#0,	18(r1)	;r3 As==00, 0x0012

000088be <.Loc.251.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int stat_sd_err = (model_features->stddevmag > features->stddevmag)
    88be:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    88c2:	1d 4c 02 00 	mov	2(r12),	r13	;
    88c6:	1c 41 02 00 	mov	2(r1),	r12	;
    88ca:	1c 4c 02 00 	mov	2(r12),	r12	;

000088ce <.Loc.253.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);
    88ce:	0c 9d       	cmp	r13,	r12	;
    88d0:	0c 2c       	jc	$+26     	;abs 0x88ea

000088d2 <.Loc.252.1>:
        long int stat_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int stat_sd_err = (model_features->stddevmag > features->stddevmag)
            ? (model_features->stddevmag - features->stddevmag)
    88d2:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    88d6:	1e 4c 02 00 	mov	2(r12),	r14	;
    88da:	1c 41 02 00 	mov	2(r1),	r12	;
    88de:	1d 4c 02 00 	mov	2(r12),	r13	;

000088e2 <.Loc.253.1>:
            : (features->stddevmag - model_features->stddevmag);
    88e2:	0c 4e       	mov	r14,	r12	;
    88e4:	0c 8d       	sub	r13,	r12	;
    88e6:	30 40 fe 88 	br	#0x88fe		;

000088ea <.L41>:
    88ea:	1c 41 02 00 	mov	2(r1),	r12	;
    88ee:	1e 4c 02 00 	mov	2(r12),	r14	;
    88f2:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    88f6:	1d 4c 02 00 	mov	2(r12),	r13	;
    88fa:	0c 4e       	mov	r14,	r12	;
    88fc:	0c 8d       	sub	r13,	r12	;

000088fe <.L42>:

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int stat_sd_err = (model_features->stddevmag > features->stddevmag)
    88fe:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    8902:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e

00008906 <.Loc.255.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);

        model_features = &model->moving[i];
    8906:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    890a:	3c 50 10 00 	add	#16,	r12	;#0x0010
    890e:	0c 5c       	rla	r12		;
    8910:	0c 5c       	rla	r12		;
    8912:	2d 41       	mov	@r1,	r13	;
    8914:	0d 5c       	add	r12,	r13	;
    8916:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

0000891a <.Loc.257.1>:

        long int move_mean_err = (model_features->meanmag > features->meanmag)
    891a:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    891e:	2d 4c       	mov	@r12,	r13	;
    8920:	1c 41 02 00 	mov	2(r1),	r12	;
    8924:	2c 4c       	mov	@r12,	r12	;

00008926 <.Loc.259.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);
    8926:	0c 9d       	cmp	r13,	r12	;
    8928:	0a 2c       	jc	$+22     	;abs 0x893e

0000892a <.Loc.258.1>:
            : (features->stddevmag - model_features->stddevmag);

        model_features = &model->moving[i];

        long int move_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
    892a:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    892e:	2e 4c       	mov	@r12,	r14	;
    8930:	1c 41 02 00 	mov	2(r1),	r12	;
    8934:	2d 4c       	mov	@r12,	r13	;

00008936 <.Loc.259.1>:
            : (features->meanmag - model_features->meanmag);
    8936:	0c 4e       	mov	r14,	r12	;
    8938:	0c 8d       	sub	r13,	r12	;
    893a:	30 40 4e 89 	br	#0x894e		;

0000893e <.L43>:
    893e:	1c 41 02 00 	mov	2(r1),	r12	;
    8942:	2e 4c       	mov	@r12,	r14	;
    8944:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8948:	2d 4c       	mov	@r12,	r13	;
    894a:	0c 4e       	mov	r14,	r12	;
    894c:	0c 8d       	sub	r13,	r12	;

0000894e <.L44>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);

        model_features = &model->moving[i];

        long int move_mean_err = (model_features->meanmag > features->meanmag)
    894e:	81 4c 08 00 	mov	r12,	8(r1)	;
    8952:	81 43 0a 00 	mov	#0,	10(r1)	;r3 As==00, 0x000a

00008956 <.Loc.261.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int move_sd_err = (model_features->stddevmag > features->stddevmag)
    8956:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    895a:	1d 4c 02 00 	mov	2(r12),	r13	;
    895e:	1c 41 02 00 	mov	2(r1),	r12	;
    8962:	1c 4c 02 00 	mov	2(r12),	r12	;

00008966 <.Loc.263.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);
    8966:	0c 9d       	cmp	r13,	r12	;
    8968:	0c 2c       	jc	$+26     	;abs 0x8982

0000896a <.Loc.262.1>:
        long int move_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int move_sd_err = (model_features->stddevmag > features->stddevmag)
            ? (model_features->stddevmag - features->stddevmag)
    896a:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    896e:	1e 4c 02 00 	mov	2(r12),	r14	;
    8972:	1c 41 02 00 	mov	2(r1),	r12	;
    8976:	1d 4c 02 00 	mov	2(r12),	r13	;

0000897a <.Loc.263.1>:
            : (features->stddevmag - model_features->stddevmag);
    897a:	0c 4e       	mov	r14,	r12	;
    897c:	0c 8d       	sub	r13,	r12	;
    897e:	30 40 96 89 	br	#0x8996		;

00008982 <.L45>:
    8982:	1c 41 02 00 	mov	2(r1),	r12	;
    8986:	1e 4c 02 00 	mov	2(r12),	r14	;
    898a:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    898e:	1d 4c 02 00 	mov	2(r12),	r13	;
    8992:	0c 4e       	mov	r14,	r12	;
    8994:	0c 8d       	sub	r13,	r12	;

00008996 <.L46>:

        long int move_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int move_sd_err = (model_features->stddevmag > features->stddevmag)
    8996:	81 4c 04 00 	mov	r12,	4(r1)	;
    899a:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

0000899e <.Loc.265.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);

        if (move_mean_err < stat_mean_err) {
    899e:	91 91 12 00 	cmp	18(r1),	10(r1)	;0x00012, 0x000a
    89a2:	0a 00 
    89a4:	08 38       	jl	$+18     	;abs 0x89b6
    89a6:	91 91 0a 00 	cmp	10(r1),	18(r1)	;0x0000a, 0x0012
    89aa:	12 00 
    89ac:	08 20       	jnz	$+18     	;abs 0x89be
    89ae:	91 91 10 00 	cmp	16(r1),	8(r1)	;0x00010
    89b2:	08 00 
    89b4:	04 2c       	jc	$+10     	;abs 0x89be

000089b6 <.L56>:
            move_less_error++;
    89b6:	91 53 1c 00 	inc	28(r1)		;
    89ba:	30 40 c2 89 	br	#0x89c2		;

000089be <.L47>:
        } else {
            stat_less_error++;
    89be:	91 53 1a 00 	inc	26(r1)		;

000089c2 <.L49>:
        }

        if (move_sd_err < stat_sd_err) {
    89c2:	91 91 0e 00 	cmp	14(r1),	6(r1)	;0x0000e
    89c6:	06 00 
    89c8:	08 38       	jl	$+18     	;abs 0x89da
    89ca:	91 91 06 00 	cmp	6(r1),	14(r1)	; 0x000e
    89ce:	0e 00 
    89d0:	08 20       	jnz	$+18     	;abs 0x89e2
    89d2:	91 91 0c 00 	cmp	12(r1),	4(r1)	;0x0000c
    89d6:	04 00 
    89d8:	04 2c       	jc	$+10     	;abs 0x89e2

000089da <.L57>:
            move_less_error++;
    89da:	91 53 1c 00 	inc	28(r1)		;
    89de:	30 40 e6 89 	br	#0x89e6		;

000089e2 <.L50>:
        } else {
            stat_less_error++;
    89e2:	91 53 1a 00 	inc	26(r1)		;

000089e6 <.L52>:
    features_t *model_features;
    int i;

    TASK_CHECKPOINT();

    for (i = 0; i < MODEL_SIZE; ++i) {
    89e6:	91 53 18 00 	inc	24(r1)		;

000089ea <.L38>:
    89ea:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f
    89ee:	1c 91 18 00 	cmp	24(r1),	r12	;0x00018
    89f2:	3f 37       	jge	$-384    	;abs 0x8872

000089f4 <.Loc.279.1>:
            stat_less_error++;
        }
    }

    class_t class = move_less_error > stat_less_error ?
                        CLASS_MOVING : CLASS_STATIONARY;
    89f4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    89f6:	91 91 1c 00 	cmp	28(r1),	26(r1)	;0x0001c, 0x001a
    89fa:	1a 00 
    89fc:	01 38       	jl	$+4      	;abs 0x8a00
    89fe:	4c 43       	clr.b	r12		;

00008a00 <.L54>:
    8a00:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008a04 <.Loc.278.1>:
        } else {
            stat_less_error++;
        }
    }

    class_t class = move_less_error > stat_less_error ?
    8a04:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016

00008a08 <.Loc.282.1>:
                        CLASS_MOVING : CLASS_STATIONARY;
    LOG("classify: class %u\r\n", class);

    return class;
    8a08:	1c 41 16 00 	mov	22(r1),	r12	;0x00016

00008a0c <.Loc.283.1>:
}
    8a0c:	31 50 1e 00 	add	#30,	r1	;#0x001e
    8a10:	30 41       	ret			

00008a12 <record_stats>:

void record_stats(stats_t *stats, class_t class)
{
    8a12:	21 82       	sub	#4,	r1	;r2 As==10

00008a14 <.LCFI17>:
    8a14:	81 4c 02 00 	mov	r12,	2(r1)	;
    8a18:	81 4d 00 00 	mov	r13,	0(r1)	;

00008a1c <.Loc.292.1>:
    TASK_CHECKPOINT();

    /* stats->totalCount, stats->movingCount, and stats->stationaryCount have an
     * nv-internal consistency requirement.  This code should be atomic. */

    stats->totalCount++;
    8a1c:	1c 41 02 00 	mov	2(r1),	r12	;
    8a20:	2c 4c       	mov	@r12,	r12	;
    8a22:	0d 4c       	mov	r12,	r13	;
    8a24:	1d 53       	inc	r13		;
    8a26:	1c 41 02 00 	mov	2(r1),	r12	;
    8a2a:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008a2e <.Loc.294.1>:

    switch (class) {
    8a2e:	2c 41       	mov	@r1,	r12	;
    8a30:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a32:	10 24       	jz	$+34     	;abs 0x8a54
    8a34:	1c 93       	cmp	#1,	r12	;r3 As==01
    8a36:	02 24       	jz	$+6      	;abs 0x8a3c

00008a38 <.Loc.306.1>:
            break;
    }

    LOG("stats: s %u m %u t %u\r\n",
        stats->stationaryCount, stats->movingCount, stats->totalCount);
}
    8a38:	30 40 6a 8a 	br	#0x8a6a		;

00008a3c <.L61>:

    stats->totalCount++;

    switch (class) {
        case CLASS_MOVING:
            stats->movingCount++;
    8a3c:	1c 41 02 00 	mov	2(r1),	r12	;
    8a40:	1c 4c 02 00 	mov	2(r12),	r12	;
    8a44:	0d 4c       	mov	r12,	r13	;
    8a46:	1d 53       	inc	r13		;
    8a48:	1c 41 02 00 	mov	2(r1),	r12	;
    8a4c:	8c 4d 02 00 	mov	r13,	2(r12)	;

00008a50 <.Loc.297.1>:
            break;
    8a50:	30 40 6a 8a 	br	#0x8a6a		;

00008a54 <.L60>:

        case CLASS_STATIONARY:
            stats->stationaryCount++;
    8a54:	1c 41 02 00 	mov	2(r1),	r12	;
    8a58:	1c 4c 04 00 	mov	4(r12),	r12	;
    8a5c:	0d 4c       	mov	r12,	r13	;
    8a5e:	1d 53       	inc	r13		;
    8a60:	1c 41 02 00 	mov	2(r1),	r12	;
    8a64:	8c 4d 04 00 	mov	r13,	4(r12)	;

00008a68 <.Loc.301.1>:
            break;
    8a68:	03 43       	nop			

00008a6a <.L59>:
    }

    LOG("stats: s %u m %u t %u\r\n",
        stats->stationaryCount, stats->movingCount, stats->totalCount);
}
    8a6a:	03 43       	nop			
    8a6c:	21 52       	add	#4,	r1	;r2 As==10
    8a6e:	30 41       	ret			

00008a70 <print_stats>:
 unsigned resultStationaryPct;
 unsigned resultMovingPct;
 unsigned sum;

void print_stats(stats_t *stats)
{
    8a70:	21 83       	decd	r1		;

00008a72 <.LCFI18>:
    8a72:	81 4c 00 00 	mov	r12,	0(r1)	;

00008a76 <.Loc.318.1>:
   // unsigned resultStationaryPct = stats->stationaryCount * 100 / stats->totalCount;
   // unsigned resultMovingPct = stats->movingCount * 100 / stats->totalCount;
   // unsigned sum = stats->stationaryCount + stats->movingCount;

	resultStationaryPct = stats->stationaryCount * 100 / stats->totalCount;
    8a76:	2c 41       	mov	@r1,	r12	;
    8a78:	1c 4c 04 00 	mov	4(r12),	r12	;
    8a7c:	7d 40 64 00 	mov.b	#100,	r13	;#0x0064
    8a80:	b0 12 c2 92 	call	#37570		;#0x92c2
    8a84:	2d 41       	mov	@r1,	r13	;
    8a86:	2d 4d       	mov	@r13,	r13	;
    8a88:	b0 12 ee 91 	call	#37358		;#0x91ee
    8a8c:	82 4c 18 41 	mov	r12,	&0x4118	;

00008a90 <.Loc.319.1>:
	resultMovingPct = stats->movingCount * 100 / stats->totalCount;
    8a90:	2c 41       	mov	@r1,	r12	;
    8a92:	1c 4c 02 00 	mov	2(r12),	r12	;
    8a96:	7d 40 64 00 	mov.b	#100,	r13	;#0x0064
    8a9a:	b0 12 c2 92 	call	#37570		;#0x92c2
    8a9e:	2d 41       	mov	@r1,	r13	;
    8aa0:	2d 4d       	mov	@r13,	r13	;
    8aa2:	b0 12 ee 91 	call	#37358		;#0x91ee
    8aa6:	82 4c 1c 41 	mov	r12,	&0x411c	;

00008aaa <.Loc.320.1>:
	sum = stats->stationaryCount + stats->movingCount;
    8aaa:	2c 41       	mov	@r1,	r12	;
    8aac:	1d 4c 04 00 	mov	4(r12),	r13	;
    8ab0:	2c 41       	mov	@r1,	r12	;
    8ab2:	1c 4c 02 00 	mov	2(r12),	r12	;
    8ab6:	0c 5d       	add	r13,	r12	;
    8ab8:	82 4c 94 40 	mov	r12,	&0x4094	;

00008abc <.Loc.328.1>:
           stats->stationaryCount, resultStationaryPct,
           stats->movingCount, resultMovingPct,
           stats->totalCount, sum,
           sum == stats->totalCount && sum == SAMPLES_TO_COLLECT ? 'V' : 'X');
    //QWARK_CHECKPOINT();
	LED_CTRL = 0xEA;
    8abc:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8ac0:	fc 40 ea ff 	mov.b	#65514,	0(r12)	;#0xffea
    8ac4:	00 00 

00008ac6 <.Loc.330.1>:
    #ifdef UART_DBG
		UART_WriteString("stats: s ");
    8ac6:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    8aca:	b0 12 fc 90 	call	#37116		;#0x90fc

00008ace <.Loc.331.1>:
		UART_WriteNumber(stats->stationaryCount);
    8ace:	2c 41       	mov	@r1,	r12	;
    8ad0:	1c 4c 04 00 	mov	4(r12),	r12	;
    8ad4:	b0 12 4a 90 	call	#36938		;#0x904a

00008ad8 <.Loc.332.1>:
		UART_WriteString(" (");
    8ad8:	3c 40 0a 80 	mov	#32778,	r12	;#0x800a
    8adc:	b0 12 fc 90 	call	#37116		;#0x90fc

00008ae0 <.Loc.333.1>:
		UART_WriteNumber(resultStationaryPct);
    8ae0:	1c 42 18 41 	mov	&0x4118,r12	;0x4118
    8ae4:	b0 12 4a 90 	call	#36938		;#0x904a

00008ae8 <.Loc.334.1>:
		UART_WriteString("%) m ");
    8ae8:	3c 40 0d 80 	mov	#32781,	r12	;#0x800d
    8aec:	b0 12 fc 90 	call	#37116		;#0x90fc

00008af0 <.Loc.335.1>:
		UART_WriteNumber(stats->movingCount);
    8af0:	2c 41       	mov	@r1,	r12	;
    8af2:	1c 4c 02 00 	mov	2(r12),	r12	;
    8af6:	b0 12 4a 90 	call	#36938		;#0x904a

00008afa <.Loc.336.1>:
		UART_WriteString(" (");
    8afa:	3c 40 0a 80 	mov	#32778,	r12	;#0x800a
    8afe:	b0 12 fc 90 	call	#37116		;#0x90fc

00008b02 <.Loc.337.1>:
		UART_WriteNumber(resultMovingPct);
    8b02:	1c 42 1c 41 	mov	&0x411c,r12	;0x411c
    8b06:	b0 12 4a 90 	call	#36938		;#0x904a

00008b0a <.Loc.338.1>:
		UART_WriteString("%)");
    8b0a:	3c 40 13 80 	mov	#32787,	r12	;#0x8013
    8b0e:	b0 12 fc 90 	call	#37116		;#0x90fc

00008b12 <.Loc.339.1>:
		UART_WriteString(" sum/tot ");
    8b12:	3c 40 16 80 	mov	#32790,	r12	;#0x8016
    8b16:	b0 12 fc 90 	call	#37116		;#0x90fc

00008b1a <.Loc.340.1>:
		UART_WriteNumber(stats->totalCount);
    8b1a:	2c 41       	mov	@r1,	r12	;
    8b1c:	2c 4c       	mov	@r12,	r12	;
    8b1e:	b0 12 4a 90 	call	#36938		;#0x904a

00008b22 <.Loc.341.1>:
		UART_WriteString("/");
    8b22:	3c 40 20 80 	mov	#32800,	r12	;#0x8020
    8b26:	b0 12 fc 90 	call	#37116		;#0x90fc

00008b2a <.Loc.342.1>:
		UART_WriteNumber(sum);
    8b2a:	1c 42 94 40 	mov	&0x4094,r12	;0x4094
    8b2e:	b0 12 4a 90 	call	#36938		;#0x904a

00008b32 <.Loc.343.1>:
		if(sum == stats->totalCount && sum == SAMPLES_TO_COLLECT)
    8b32:	2c 41       	mov	@r1,	r12	;
    8b34:	2d 4c       	mov	@r12,	r13	;
    8b36:	1c 42 94 40 	mov	&0x4094,r12	;0x4094
    8b3a:	0d 9c       	cmp	r12,	r13	;
    8b3c:	0b 20       	jnz	$+24     	;abs 0x8b54

00008b3e <.Loc.343.1>:
    8b3e:	1c 42 94 40 	mov	&0x4094,r12	;0x4094
    8b42:	3c 90 80 00 	cmp	#128,	r12	;#0x0080
    8b46:	06 20       	jnz	$+14     	;abs 0x8b54

00008b48 <.Loc.344.1>:
		UART_WriteString(" V");
    8b48:	3c 40 22 80 	mov	#32802,	r12	;#0x8022
    8b4c:	b0 12 fc 90 	call	#37116		;#0x90fc
    8b50:	30 40 5c 8b 	br	#0x8b5c		;

00008b54 <.L64>:
		else
		UART_WriteString(" X");
    8b54:	3c 40 25 80 	mov	#32805,	r12	;#0x8025
    8b58:	b0 12 fc 90 	call	#37116		;#0x90fc

00008b5c <.L65>:
		//UART_WriteString("\r\n");
	#else

	#endif

}
    8b5c:	03 43       	nop			
    8b5e:	21 53       	incd	r1		;
    8b60:	30 41       	ret			

00008b62 <warmup_sensor>:

void warmup_sensor(void)
{
    8b62:	31 80 06 00 	sub	#6,	r1	;

00008b66 <.LCFI19>:
    unsigned discardedSamplesCount = 0;
    8b66:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00008b6a <.Loc.364.1>:

    TASK_CHECKPOINT();

    LOG("warmup\r\n");

    while (discardedSamplesCount++ < NUM_WARMUP_SAMPLES) {
    8b6a:	30 40 76 8b 	br	#0x8b76		;

00008b6e <.L68>:
        accel_sample(&sample);
    8b6e:	0c 41       	mov	r1,	r12	;
    8b70:	1c 53       	inc	r12		;
    8b72:	b0 12 fa 83 	call	#33786		;#0x83fa

00008b76 <.L67>:

    TASK_CHECKPOINT();

    LOG("warmup\r\n");

    while (discardedSamplesCount++ < NUM_WARMUP_SAMPLES) {
    8b76:	1c 41 04 00 	mov	4(r1),	r12	;
    8b7a:	0d 4c       	mov	r12,	r13	;
    8b7c:	1d 53       	inc	r13		;
    8b7e:	81 4d 04 00 	mov	r13,	4(r1)	;
    8b82:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8b84:	0d 9c       	cmp	r12,	r13	;
    8b86:	f3 2f       	jc	$-24     	;abs 0x8b6e

00008b88 <.Loc.367.1>:
        accel_sample(&sample);
    }
}
    8b88:	03 43       	nop			
    8b8a:	31 50 06 00 	add	#6,	r1	;
    8b8e:	30 41       	ret			

00008b90 <train>:

void train(features_t *classModel)
{
    8b90:	31 80 12 00 	sub	#18,	r1	;#0x0012

00008b94 <.LCFI20>:
    8b94:	81 4c 00 00 	mov	r12,	0(r1)	;

00008b98 <.Loc.375.1>:
    accelWindow sampleWindow;
    features_t features;
    unsigned i;

    warmup_sensor();
    8b98:	b0 12 62 8b 	call	#35682		;#0x8b62

00008b9c <.Loc.377.1>:

    for (i = 0; i < MODEL_SIZE; ++i) {
    8b9c:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010
    8ba0:	30 40 e0 8b 	br	#0x8be0		;

00008ba4 <.L71>:
        acquire_window(sampleWindow);
    8ba4:	0c 41       	mov	r1,	r12	;
    8ba6:	3c 50 07 00 	add	#7,	r12	;
    8baa:	b0 12 6e 84 	call	#33902		;#0x846e

00008bae <.Loc.379.1>:
        transform(sampleWindow);
    8bae:	0c 41       	mov	r1,	r12	;
    8bb0:	3c 50 07 00 	add	#7,	r12	;
    8bb4:	b0 12 ba 84 	call	#33978		;#0x84ba

00008bb8 <.Loc.380.1>:
        featurize(&features, sampleWindow);
    8bb8:	0d 41       	mov	r1,	r13	;
    8bba:	3d 50 07 00 	add	#7,	r13	;
    8bbe:	0c 41       	mov	r1,	r12	;
    8bc0:	2c 53       	incd	r12		;
    8bc2:	b0 12 90 85 	call	#34192		;#0x8590

00008bc6 <.Loc.384.1>:

        TASK_CHECKPOINT();

        classModel[i] = features;
    8bc6:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8bca:	0c 5c       	rla	r12		;
    8bcc:	0c 5c       	rla	r12		;
    8bce:	2c 51       	add	@r1,	r12	;
    8bd0:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    8bd4:	00 00 
    8bd6:	9c 41 04 00 	mov	4(r1),	2(r12)	;
    8bda:	02 00 

00008bdc <.Loc.377.1>:
    features_t features;
    unsigned i;

    warmup_sensor();

    for (i = 0; i < MODEL_SIZE; ++i) {
    8bdc:	91 53 10 00 	inc	16(r1)		;

00008be0 <.L70>:
    8be0:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f
    8be4:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8be8:	dd 2f       	jc	$-68     	;abs 0x8ba4

00008bea <.Loc.389.1>:
        classModel[i] = features;
    }

    PRINTF("train: done: mn %u sd %u\r\n",
           features.meanmag, features.stddevmag);
    LED_CTRL = 0xBE;
    8bea:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8bee:	fc 40 be ff 	mov.b	#65470,	0(r12)	;#0xffbe
    8bf2:	00 00 

00008bf4 <.Loc.391.1>:
#ifdef UART_DBG
    UART_WriteString("train: done: mn ");
    8bf4:	3c 40 28 80 	mov	#32808,	r12	;#0x8028
    8bf8:	b0 12 fc 90 	call	#37116		;#0x90fc

00008bfc <.Loc.392.1>:
    UART_WriteNumber(features.meanmag);
    8bfc:	1c 41 02 00 	mov	2(r1),	r12	;
    8c00:	b0 12 4a 90 	call	#36938		;#0x904a

00008c04 <.Loc.393.1>:
    UART_WriteString(" sd ");
    8c04:	3c 40 39 80 	mov	#32825,	r12	;#0x8039
    8c08:	b0 12 fc 90 	call	#37116		;#0x90fc

00008c0c <.Loc.394.1>:
    UART_WriteNumber(features.stddevmag);
    8c0c:	1c 41 04 00 	mov	4(r1),	r12	;
    8c10:	b0 12 4a 90 	call	#36938		;#0x904a

00008c14 <.Loc.395.1>:
    UART_WriteString("\r\n");
    8c14:	3c 40 3e 80 	mov	#32830,	r12	;#0x803e
    8c18:	b0 12 fc 90 	call	#37116		;#0x90fc

00008c1c <.Loc.400.1>:
#else

#endif

}
    8c1c:	03 43       	nop			
    8c1e:	31 50 12 00 	add	#18,	r1	;#0x0012
    8c22:	30 41       	ret			

00008c24 <recognize>:

void recognize(model_t *model)
{
    8c24:	31 80 1a 00 	sub	#26,	r1	;#0x001a

00008c28 <.LCFI21>:
    8c28:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c2c <.Loc.415.1>:
    accelWindow sampleWindow;
    features_t features;
    class_t class;
    unsigned i;

    stats.totalCount = 0;
    8c2c:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00008c30 <.Loc.416.1>:
    stats.stationaryCount = 0;
    8c30:	81 43 14 00 	mov	#0,	20(r1)	;r3 As==00, 0x0014

00008c34 <.Loc.417.1>:
    stats.movingCount = 0;
    8c34:	81 43 12 00 	mov	#0,	18(r1)	;r3 As==00, 0x0012

00008c38 <.Loc.419.1>:

    for (i = 0; i < 3/*SAMPLES_TO_COLLECT*/; ++i) {
    8c38:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018
    8c3c:	30 40 82 8c 	br	#0x8c82		;

00008c40 <.L74>:
        acquire_window(sampleWindow);
    8c40:	0c 41       	mov	r1,	r12	;
    8c42:	3c 50 07 00 	add	#7,	r12	;
    8c46:	b0 12 6e 84 	call	#33902		;#0x846e

00008c4a <.Loc.421.1>:
        transform(sampleWindow);
    8c4a:	0c 41       	mov	r1,	r12	;
    8c4c:	3c 50 07 00 	add	#7,	r12	;
    8c50:	b0 12 ba 84 	call	#33978		;#0x84ba

00008c54 <.Loc.422.1>:
        featurize(&features, sampleWindow);
    8c54:	0d 41       	mov	r1,	r13	;
    8c56:	3d 50 07 00 	add	#7,	r13	;
    8c5a:	0c 41       	mov	r1,	r12	;
    8c5c:	2c 53       	incd	r12		;
    8c5e:	b0 12 90 85 	call	#34192		;#0x8590

00008c62 <.Loc.423.1>:
        class = classify(&features, model);
    8c62:	0c 41       	mov	r1,	r12	;
    8c64:	2c 53       	incd	r12		;
    8c66:	2d 41       	mov	@r1,	r13	;
    8c68:	b0 12 56 88 	call	#34902		;#0x8856
    8c6c:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016

00008c70 <.Loc.424.1>:
        record_stats(&stats, class);
    8c70:	0c 41       	mov	r1,	r12	;
    8c72:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8c76:	1d 41 16 00 	mov	22(r1),	r13	;0x00016
    8c7a:	b0 12 12 8a 	call	#35346		;#0x8a12

00008c7e <.Loc.419.1>:

    stats.totalCount = 0;
    stats.stationaryCount = 0;
    stats.movingCount = 0;

    for (i = 0; i < 3/*SAMPLES_TO_COLLECT*/; ++i) {
    8c7e:	91 53 18 00 	inc	24(r1)		;

00008c82 <.L73>:
    8c82:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8c84:	1c 91 18 00 	cmp	24(r1),	r12	;0x00018
    8c88:	db 2f       	jc	$-72     	;abs 0x8c40

00008c8a <.Loc.426.1>:
        transform(sampleWindow);
        featurize(&features, sampleWindow);
        class = classify(&features, model);
        record_stats(&stats, class);
    }
    LED_CTRL = 0xFA;
    8c8a:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8c8e:	fc 40 fa ff 	mov.b	#65530,	0(r12)	;#0xfffa
    8c92:	00 00 

00008c94 <.Loc.427.1>:
    print_stats(&stats);
    8c94:	0c 41       	mov	r1,	r12	;
    8c96:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8c9a:	b0 12 70 8a 	call	#35440		;#0x8a70

00008c9e <.Loc.428.1>:
}
    8c9e:	03 43       	nop			
    8ca0:	31 50 1a 00 	add	#26,	r1	;#0x001a
    8ca4:	30 41       	ret			

00008ca6 <end_of_benchmark>:

void end_of_benchmark(void)
{
    LED_CTRL = 0x00;
    8ca6:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8caa:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

00008cae <.Loc.435.1>:
    PRINTF("This is the end of the AR benchmark\n");
#ifdef UART_DBG
    UART_WriteString("This is the end of the AR benchmark\n\r");
    8cae:	3c 40 41 80 	mov	#32833,	r12	;#0x8041
    8cb2:	b0 12 fc 90 	call	#37116		;#0x90fc

00008cb6 <.Loc.437.1>:
#endif
    exit(0);
    8cb6:	4c 43       	clr.b	r12		;
    8cb8:	b0 12 04 93 	call	#37636		;#0x9304

00008cbc <count_error>:
}

void count_error(void)
{
    PRINTF("An error occured during count, count = %d\n", count);
}
    8cbc:	03 43       	nop			
    8cbe:	30 41       	ret			

00008cc0 <select_mode>:


run_mode_t select_mode(uint8_t *prev_pin_state)
{
    8cc0:	21 82       	sub	#4,	r1	;r2 As==10

00008cc2 <.LCFI22>:
    8cc2:	81 4c 00 00 	mov	r12,	0(r1)	;

00008cc6 <.Loc.453.1>:
    uint8_t pin_state;

    TASK_CHECKPOINT();

    count = count + 1;
    8cc6:	1c 42 00 40 	mov	&0x4000,r12	;0x4000
    8cca:	1c 53       	inc	r12		;
    8ccc:	82 4c 00 40 	mov	r12,	&0x4000	;

00008cd0 <.Loc.462.1>:
     *      1,2 = MODE_TRAIN_MOVING
     *      3,4 = MODE_TRAIN_STATIONARY
     *      5,6 = MODE_RECOGNIZE
     *      7   = END OF BENCHMARK
     */
    switch(count) {
    8cd0:	1c 42 00 40 	mov	&0x4000,r12	;0x4000
    8cd4:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8cd6:	0d 9c       	cmp	r12,	r13	;
    8cd8:	07 28       	jnc	$+16     	;abs 0x8ce8
    8cda:	3c 90 03 00 	cmp	#3,	r12	;
    8cde:	11 2c       	jc	$+36     	;abs 0x8d02
    8ce0:	1c 93       	cmp	#1,	r12	;r3 As==01
    8ce2:	1b 28       	jnc	$+56     	;abs 0x8d1a
    8ce4:	30 40 fa 8c 	br	#0x8cfa		;

00008ce8 <.L79>:
    8ce8:	7d 40 06 00 	mov.b	#6,	r13	;
    8cec:	0d 9c       	cmp	r12,	r13	;
    8cee:	0d 2c       	jc	$+28     	;abs 0x8d0a
    8cf0:	3c 90 07 00 	cmp	#7,	r12	;
    8cf4:	0e 24       	jz	$+30     	;abs 0x8d12
    8cf6:	30 40 1a 8d 	br	#0x8d1a		;

00008cfa <.L89>:
        case 1:
        case 2:
            pin_state = MODE_TRAIN_MOVING;
    8cfa:	d1 43 03 00 	mov.b	#1,	3(r1)	;r3 As==01

00008cfe <.Loc.466.1>:
            break;
    8cfe:	30 40 24 8d 	br	#0x8d24		;

00008d02 <.L80>:
        case 3:
        case 4:
            pin_state = MODE_TRAIN_STATIONARY;
    8d02:	e1 43 03 00 	mov.b	#2,	3(r1)	;r3 As==10

00008d06 <.Loc.470.1>:
            break;
    8d06:	30 40 24 8d 	br	#0x8d24		;

00008d0a <.L82>:
        case 5:
        case 6:
            pin_state = MODE_RECOGNIZE;
    8d0a:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00008d0e <.Loc.474.1>:
            break;
    8d0e:	30 40 24 8d 	br	#0x8d24		;

00008d12 <.L83>:
        case 7:
            end_of_benchmark();
    8d12:	b0 12 a6 8c 	call	#36006		;#0x8ca6

00008d16 <.Loc.477.1>:
            break;
    8d16:	30 40 24 8d 	br	#0x8d24		;

00008d1a <.L78>:
        default:
            pin_state = MODE_IDLE;
    8d1a:	f1 40 03 00 	mov.b	#3,	3(r1)	;
    8d1e:	03 00 

00008d20 <.Loc.480.1>:
            count_error();
    8d20:	b0 12 bc 8c 	call	#36028		;#0x8cbc

00008d24 <.L84>:

    //pin_state = GPIO(PORT_AUX, IN) & (BIT(PIN_AUX_1) | BIT(PIN_AUX_2));

    // Don't re-launch training after finishing training
    // Vito: could have done this while assigning pin_state. But keep is the same as the original
    if ((pin_state == MODE_TRAIN_STATIONARY ||
    8d24:	e1 93 03 00 	cmp.b	#2,	3(r1)	;r3 As==10
    8d28:	03 24       	jz	$+8      	;abs 0x8d30

00008d2a <.Loc.487.1>:
    8d2a:	d1 93 03 00 	cmp.b	#1,	3(r1)	;r3 As==01
    8d2e:	0a 20       	jnz	$+22     	;abs 0x8d44

00008d30 <.L85>:
        pin_state == MODE_TRAIN_MOVING) &&
        pin_state == *prev_pin_state) {
    8d30:	2c 41       	mov	@r1,	r12	;
    8d32:	6c 4c       	mov.b	@r12,	r12	;

00008d34 <.Loc.488.1>:
    //pin_state = GPIO(PORT_AUX, IN) & (BIT(PIN_AUX_1) | BIT(PIN_AUX_2));

    // Don't re-launch training after finishing training
    // Vito: could have done this while assigning pin_state. But keep is the same as the original
    if ((pin_state == MODE_TRAIN_STATIONARY ||
        pin_state == MODE_TRAIN_MOVING) &&
    8d34:	c1 9c 03 00 	cmp.b	r12,	3(r1)	;
    8d38:	05 20       	jnz	$+12     	;abs 0x8d44

00008d3a <.Loc.490.1>:
        pin_state == *prev_pin_state) {
        pin_state = MODE_IDLE;
    8d3a:	f1 40 03 00 	mov.b	#3,	3(r1)	;
    8d3e:	03 00 
    8d40:	30 40 4c 8d 	br	#0x8d4c		;

00008d44 <.L86>:
    } else {
        *prev_pin_state = pin_state;
    8d44:	2c 41       	mov	@r1,	r12	;
    8d46:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    8d4a:	00 00 

00008d4c <.L87>:
    }

    LOG("selectMode: pins %04x\r\n", pin_state);

    return (run_mode_t)pin_state;
    8d4c:	5c 41 03 00 	mov.b	3(r1),	r12	;

00008d50 <.Loc.498.1>:
}
    8d50:	21 52       	add	#4,	r1	;r2 As==10
    8d52:	30 41       	ret			

00008d54 <init>:

void init()
{
    WDTCTL = WDTPW | WDTHOLD; // Stop WDT
    8d54:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    8d58:	bc 40 80 5a 	mov	#23168,	0(r12)	;#0x5a80
    8d5c:	00 00 

00008d5e <.Loc.503.1>:
 	 __asm__ __volatile__ ("nop");
    8d5e:	03 43       	nop			

00008d60 <.Loc.504.1>:
    eint();
    8d60:	32 d2       	eint			
    8d62:	03 43       	nop			

00008d64 <.Loc.505.1>:
	UART_BAUD = BAUD;                   // Init UART
    8d64:	7c 40 82 00 	mov.b	#130,	r12	;#0x0082
    8d68:	bc 42 00 00 	mov	#8,	0(r12)	;r2 As==11

00008d6c <.Loc.506.1>:
    UART_CTL  = UART_EN;
    8d6c:	7c 40 80 00 	mov.b	#128,	r12	;#0x0080
    8d70:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00008d74 <.Loc.508.1>:
    //Enable QWARK
    QWARK_CTL = QWARK_EN;
    8d74:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    8d78:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00008d7c <.Loc.516.1>:
    // init timer
#ifdef CHECKPOINT_TIMER
    checkpoint_timer_init();
#endif

}
    8d7c:	03 43       	nop			
    8d7e:	30 41       	ret			

00008d80 <dummy_function_one>:

unsigned char dummy = 3;

void dummy_function_one(void){
    8d80:	21 82       	sub	#4,	r1	;r2 As==10

00008d82 <.LCFI23>:


	unsigned char* ptr;
	unsigned char dummy;
	
	ptr = (unsigned char *)0x7FFB;
    8d82:	b1 40 fb 7f 	mov	#32763,	2(r1)	;#0x7ffb
    8d86:	02 00 

00008d88 <.Loc.527.1>:
	dummy = (unsigned char)*ptr;
    8d88:	1c 41 02 00 	mov	2(r1),	r12	;
    8d8c:	e1 4c 01 00 	mov.b	@r12,	1(r1)	;

00008d90 <.Loc.529.1>:
		
	*ptr = 0xBEBE;
    8d90:	1c 41 02 00 	mov	2(r1),	r12	;
    8d94:	fc 40 be ff 	mov.b	#65470,	0(r12)	;#0xffbe
    8d98:	00 00 

00008d9a <.Loc.530.1>:
}
    8d9a:	03 43       	nop			
    8d9c:	21 52       	add	#4,	r1	;r2 As==10
    8d9e:	30 41       	ret			

00008da0 <dummy_function_two>:


void dummy_function_two(void){
    8da0:	21 83       	decd	r1		;

00008da2 <.LCFI24>:

	unsigned var_16;

	var_16 = 0xCAFE;
    8da2:	b1 40 fe ca 	mov	#51966,	0(r1)	;#0xcafe
    8da6:	00 00 

00008da8 <.Loc.538.1>:
}
    8da8:	03 43       	nop			
    8daa:	21 53       	incd	r1		;
    8dac:	30 41       	ret			

00008dae <main>:
unsigned char* ptr2;
unsigned char* ptr3;
unsigned int var;
unsigned int count2;
int main()
{
    8dae:	21 82       	sub	#4,	r1	;r2 As==10

00008db0 <.LCFI25>:
 
     uint8_t prev_pin_state = MODE_IDLE;
    8db0:	f1 40 03 00 	mov.b	#3,	1(r1)	;
    8db4:	01 00 

00008db6 <.Loc.556.1>:
  //  ptr = (unsigned int*)0x7fd6;
   // ptr2 = (unsigned char*)0x7fd6;
  //  ptr3 = (unsigned char*)0x7fd7;

    
    init();
    8db6:	b0 12 54 8d 	call	#36180		;#0x8d54

00008dba <.Loc.559.1>:
    // ta_wait(9800);
    
    LED_CTRL = 0xF0;
    8dba:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8dbe:	fc 40 f0 ff 	mov.b	#65520,	0(r12)	;#0xfff0
    8dc2:	00 00 

00008dc4 <.Loc.560.1>:
    count=1;
    8dc4:	92 43 00 40 	mov	#1,	&0x4000	;r3 As==01

00008dc8 <.L99>:

    //while(1);

    while (1)
    {
        run_mode_t mode = select_mode(&prev_pin_state);
    8dc8:	0c 41       	mov	r1,	r12	;
    8dca:	1c 53       	inc	r12		;
    8dcc:	b0 12 c0 8c 	call	#36032		;#0x8cc0
    8dd0:	81 4c 02 00 	mov	r12,	2(r1)	;

00008dd4 <.Loc.570.1>:
        switch (mode) {
    8dd4:	1c 41 02 00 	mov	2(r1),	r12	;
    8dd8:	1c 93       	cmp	#1,	r12	;r3 As==01
    8dda:	0c 24       	jz	$+26     	;abs 0x8df4
    8ddc:	1c 93       	cmp	#1,	r12	;r3 As==01
    8dde:	10 28       	jnc	$+34     	;abs 0x8e00
    8de0:	2c 93       	cmp	#2,	r12	;r3 As==10
    8de2:	02 24       	jz	$+6      	;abs 0x8de8

00008de4 <.Loc.586.1>:
                LOG("mode: recognize\r\n");
                recognize(&model);
                break;
            default:
                LOG("mode: idle\r\n");
                break;
    8de4:	30 40 14 8e 	br	#0x8e14		;

00008de8 <.L97>:
    {
        run_mode_t mode = select_mode(&prev_pin_state);
        switch (mode) {
            case MODE_TRAIN_STATIONARY:
                LOG("mode: stationary\r\n");
                train(model.stationary);
    8de8:	3c 40 98 40 	mov	#16536,	r12	;#0x4098
    8dec:	b0 12 90 8b 	call	#35728		;#0x8b90

00008df0 <.Loc.574.1>:
                break;
    8df0:	30 40 14 8e 	br	#0x8e14		;

00008df4 <.L95>:
            case MODE_TRAIN_MOVING:
                LOG("mode: moving\r\n");
                train(model.moving);
    8df4:	3c 40 d8 40 	mov	#16600,	r12	;#0x40d8
    8df8:	b0 12 90 8b 	call	#35728		;#0x8b90

00008dfc <.Loc.578.1>:
                break;
    8dfc:	30 40 14 8e 	br	#0x8e14		;

00008e00 <.L96>:
            case MODE_RECOGNIZE:
    		LED_CTRL = 0xF1;
    8e00:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8e04:	fc 40 f1 ff 	mov.b	#65521,	0(r12)	;#0xfff1
    8e08:	00 00 

00008e0a <.Loc.582.1>:
                LOG("mode: recognize\r\n");
                recognize(&model);
    8e0a:	3c 40 98 40 	mov	#16536,	r12	;#0x4098
    8e0e:	b0 12 24 8c 	call	#35876		;#0x8c24

00008e12 <.Loc.583.1>:
                break;
    8e12:	03 43       	nop			

00008e14 <.L98>:
    

    //while(1);

    while (1)
    {
    8e14:	30 40 c8 8d 	br	#0x8dc8		;

00008e18 <INT_Qwark>:
	//---------------------------------------------------------------------------------------------------------------------------------//
	//    CHECKPOINT SETUP: Identify which of the 2 checkpoint buffers should be written, one should always be consistent		   //
	//	  W.C. 18 CYCLES  													   //	 
	//	  B.C. 10 CYCLES 													   //
	//---------------------------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov r13, &0x6070"); 		//temporal r13: 4 cycles
    8e18:	82 4d 70 60 	mov	r13,	&0x6070	;

00008e1c <.Loc.291.1>:
		__asm__ __volatile__ ("mov r12, &0x6072"); 		//temporal r12: 4 cycles
    8e1c:	82 4c 72 60 	mov	r12,	&0x6072	;

00008e20 <.Loc.293.1>:

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075"); 		//4 cycles
    8e20:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

00008e24 <.Loc.294.1>:
		__asm__ __volatile__ ("jz __second_buffer_init");	//2 cycles
    8e24:	06 24       	jz	$+14     	;abs 0x8e32

00008e26 <.Loc.296.1>:

		__asm__ __volatile__ ("mov #0x6010, r12"); 		//Load the base pointer of the first checkpoint buffer: 2 cycles
    8e26:	3c 40 10 60 	mov	#24592,	r12	;#0x6010

00008e2a <.Loc.297.1>:
		__asm__ __volatile__ ("mov.b #0x01,&0x6074");		//4 cycles
    8e2a:	d2 43 74 60 	mov.b	#1,	&0x6074	;r3 As==01

00008e2e <.Loc.298.1>:
		__asm__ __volatile__ ("br #__first_phase_commit");	//2 cycles
    8e2e:	30 40 36 8e 	br	#0x8e36		;

00008e32 <__second_buffer_init>:

		__asm__ __volatile__ ("__second_buffer_init:");

		__asm__ __volatile__ ("mov #0x6040, r12"); 		//Load the base pointer of the second checkpoint buffer: 2 cycles
    8e32:	3c 40 40 60 	mov	#24640,	r12	;#0x6040

00008e36 <__first_phase_commit>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 2(r1),@r12"); 	//PC/R0   6 cycles
    8e36:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    8e3a:	00 00 

00008e3c <.Loc.321.1>:
		__asm__ __volatile__ ("incd r12");		//	  1 cycle
    8e3c:	2c 53       	incd	r12		;

00008e3e <.Loc.327.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark  - 3 cycles
		//__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles	

		__asm__ __volatile__ ("mov r1,@r12");   	//SP/R1   4 cycles
    8e3e:	8c 41 00 00 	mov	r1,	0(r12)	;

00008e42 <.Loc.328.1>:
		__asm__ __volatile__ ("add #0x04,@r12");	//	  5 cycles
    8e42:	ac 52 00 00 	add	#4,	0(r12)	;r2 As==10

00008e46 <.Loc.329.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8e46:	2c 53       	incd	r12		;

00008e48 <.Loc.335.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 0(r1),@r12"); 	//SR/R2   6 cycles
    8e48:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008e4c <.Loc.336.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8e4c:	2c 53       	incd	r12		;

00008e4e <.Loc.338.1>:

		__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark and signal a buffer reset without modifying the data - 3 cycles
    8e4e:	1d 42 a0 02 	mov	&0x02a0,r13	;0x02a0

00008e52 <.Loc.339.1>:
		__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
    8e52:	3d f0 3e 00 	and	#62,	r13	;#0x003e

00008e56 <.Loc.340.1>:
		__asm__ __volatile__ ("bis #0x40,r13"); 	//	  2 cycles
    8e56:	3d d0 40 00 	bis	#64,	r13	;#0x0040

00008e5a <.Loc.341.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    8e5a:	82 4d a0 02 	mov	r13,	&0x02a0	;

00008e5e <.Loc.342.1>:
		__asm__ __volatile__ ("and #0xBF,r13"); 	//	  2 cycles
    8e5e:	3d f0 bf 00 	and	#191,	r13	;#0x00bf

00008e62 <.Loc.343.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    8e62:	82 4d a0 02 	mov	r13,	&0x02a0	;

00008e66 <.Loc.345.1>:

		__asm__ __volatile__ ("mov r4,@r12"); 		//R4	  4 cycles
    8e66:	8c 44 00 00 	mov	r4,	0(r12)	;

00008e6a <.Loc.346.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8e6a:	2c 53       	incd	r12		;

00008e6c <.Loc.348.1>:

		__asm__ __volatile__ ("mov r5,@r12"); 		//R5	  4 cycles
    8e6c:	8c 45 00 00 	mov	r5,	0(r12)	;

00008e70 <.Loc.349.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    8e70:	2c 53       	incd	r12		;

00008e72 <.Loc.351.1>:

		__asm__ __volatile__ ("mov r6,@r12"); 		//R6	  4 cycles
    8e72:	8c 46 00 00 	mov	r6,	0(r12)	;

00008e76 <.Loc.352.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    8e76:	2c 53       	incd	r12		;

00008e78 <.Loc.354.1>:

		__asm__ __volatile__ ("mov r7,@r12"); 		//R7	  4 cycles
    8e78:	8c 47 00 00 	mov	r7,	0(r12)	;

00008e7c <.Loc.355.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8e7c:	2c 53       	incd	r12		;

00008e7e <.Loc.357.1>:

		__asm__ __volatile__ ("mov r8,@r12"); 		//R8	  4 cycles
    8e7e:	8c 48 00 00 	mov	r8,	0(r12)	;

00008e82 <.Loc.358.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8e82:	2c 53       	incd	r12		;

00008e84 <.Loc.360.1>:

		__asm__ __volatile__ ("mov r9,@r12"); 		//R9	  4 cycles
    8e84:	8c 49 00 00 	mov	r9,	0(r12)	;

00008e88 <.Loc.361.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8e88:	2c 53       	incd	r12		;

00008e8a <.Loc.363.1>:

		__asm__ __volatile__ ("mov r10,@r12"); 		//R10	  4 cycles
    8e8a:	8c 4a 00 00 	mov	r10,	0(r12)	;

00008e8e <.Loc.364.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8e8e:	2c 53       	incd	r12		;

00008e90 <.Loc.366.1>:

		__asm__ __volatile__ ("mov r11,@r12"); 		//R11	  4 cycles
    8e90:	8c 4b 00 00 	mov	r11,	0(r12)	;

00008e94 <.Loc.367.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8e94:	2c 53       	incd	r12		;

00008e96 <.Loc.369.1>:

		__asm__ __volatile__ ("mov &0x6072,@r12"); 	//R12	  6 cycles
    8e96:	9c 42 72 60 	mov	&0x6072,0(r12)	;0x6072
    8e9a:	00 00 

00008e9c <.Loc.370.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8e9c:	2c 53       	incd	r12		;

00008e9e <.Loc.372.1>:

		__asm__ __volatile__ ("mov &0x6070,@r12"); 	//R13	  4 cycles
    8e9e:	9c 42 70 60 	mov	&0x6070,0(r12)	;0x6070
    8ea2:	00 00 

00008ea4 <.Loc.373.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8ea4:	2c 53       	incd	r12		;

00008ea6 <.Loc.375.1>:

		__asm__ __volatile__ ("mov r14,@r12"); 		//R14	  4 cycles
    8ea6:	8c 4e 00 00 	mov	r14,	0(r12)	;

00008eaa <.Loc.376.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8eaa:	2c 53       	incd	r12		;

00008eac <.Loc.378.1>:

		__asm__ __volatile__ ("mov r15,@r12"); 		//R15	  4 cycles
    8eac:	8c 4f 00 00 	mov	r15,	0(r12)	;

00008eb0 <.Loc.379.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8eb0:	2c 53       	incd	r12		;

00008eb2 <.Loc.387.1>:
		//    WAR VIOLATION INDEX CHECKPOINT: Get the index indicating the amount of violations stored 				   //
		//	  10 CYCLES																								   //
		//																											   //
		//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("mov &0x02A0, r14");	// 		  3 cycles
    8eb2:	1e 42 a0 02 	mov	&0x02a0,r14	;0x02a0

00008eb6 <.Loc.388.1>:
		__asm__ __volatile__ ("RRA r14");			// 		  1 cycle
    8eb6:	0e 11       	rra	r14		;

00008eb8 <.Loc.389.1>:
		__asm__ __volatile__ ("mov.b r14, @r12");	// 		  4 cycles
    8eb8:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00008ebc <.Loc.390.1>:
		__asm__ __volatile__ ("mov r14, r15 ");		// 		  1 cycle (save the index for later)
    8ebc:	0f 4e       	mov	r14,	r15	;

00008ebe <.Loc.391.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 Cycle
    8ebe:	2c 53       	incd	r12		;

00008ec0 <.Loc.401.1>:
		//	  B.C.	 5 CYCLES FOR EMPTY TLB																			   //
		//-------------------------------------------------------------------------------------------------------------//

		/* Setup registers for copy*/

		__asm__ __volatile__ ("tst r14 ");     	    // 		  1 cycle
    8ec0:	0e 93       	cmp	#0,	r14	;r3 As==00

00008ec2 <.Loc.402.1>:
		__asm__ __volatile__ ("jz  __second_phase_start");	// 		  2 cycles
    8ec2:	08 24       	jz	$+18     	;abs 0x8ed4

00008ec4 <.Loc.404.1>:

		__asm__ __volatile__ ("mov #0x02A2, r13");	// 		  2 cycles
    8ec4:	3d 40 a2 02 	mov	#674,	r13	;#0x02a2

00008ec8 <_scratchpad_addr_cpy>:

		__asm__ __volatile__ ("_scratchpad_addr_cpy:");   // Each iteration takes 10 cycles - Worst case 70 cycles

		__asm__ __volatile__ ("mov @r13+2, @r12");  // 		  5 cycles
    8ec8:	bc 4d 00 00 	mov	@r13+,	0(r12)	;

00008ecc <.Loc.409.1>:
		__asm__ __volatile__ ("incd r12");  		// 		  1 cycle
    8ecc:	2c 53       	incd	r12		;

00008ece <.Loc.410.1>:
		__asm__ __volatile__ ("dec r14 ");      	// 		  1 cycle
    8ece:	1e 83       	dec	r14		;

00008ed0 <.Loc.411.1>:
		__asm__ __volatile__ ("tst r14 ");     		// 		  1 cycle
    8ed0:	0e 93       	cmp	#0,	r14	;r3 As==00

00008ed2 <.Loc.412.1>:
		__asm__ __volatile__ ("jnz  _scratchpad_addr_cpy");// 2 cycles
    8ed2:	fa 23       	jnz	$-10     	;abs 0x8ec8

00008ed4 <__second_phase_start>:
	//    END OF THE FIRST PHASE: Atomic Flag Handling for halfway through checkpoint							   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("__second_phase_start:");

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075");		 // 4 cycles
    8ed4:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

00008ed8 <.Loc.460.1>:
		__asm__ __volatile__ ("jz  __set_flag_2nd ");		 // 2 cycles
    8ed8:	04 24       	jz	$+10     	;abs 0x8ee2

00008eda <.Loc.462.1>:

		__asm__ __volatile__ ("add.b #0x01, &0x6074 "); 	 //4 cycles
    8eda:	d2 53 74 60 	inc.b	&0x6074		;

00008ede <.Loc.463.1>:
		__asm__ __volatile__ ("br  #_second_phase_commit "); //4 cycles
    8ede:	30 40 e6 8e 	br	#0x8ee6		;

00008ee2 <__set_flag_2nd>:

		__asm__ __volatile__ ("__set_flag_2nd:");
		__asm__ __volatile__ ("add.b #0x01, &0x6075 "); 	 // 4 cycles		/* after setting this bit, THE RESTORE ROUTINE CAN FINALIZE THIS HALFWAY CHECKPOINT  */
    8ee2:	d2 53 75 60 	inc.b	&0x6075		;

00008ee6 <_second_phase_commit>:
	//	  ASSUMMING ONLY WORD ADDRESSING. 																		   //
	//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("_second_phase_commit:");

		__asm__ __volatile__ ("tst r15 ");     		         // 1 cycle
    8ee6:	0f 93       	cmp	#0,	r15	;r3 As==00

00008ee8 <.Loc.477.1>:
		__asm__ __volatile__ ("jz  _chkpt_finished");		 // 2 cycles
    8ee8:	25 24       	jz	$+76     	;abs 0x8f34

00008eea <.Loc.479.1>:

		__asm__ __volatile__ ("mov #0x6000,  r14 ");		 // 2 cycles
    8eea:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008eee <.Loc.481.1>:

		__asm__ __volatile__ ("mov #0x6060,  r12 ");		 // 2 cycles
    8eee:	3c 40 60 60 	mov	#24672,	r12	;#0x6060

00008ef2 <.Loc.482.1>:
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");		 // 4 cycles
    8ef2:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008ef6 <.Loc.483.1>:
		__asm__ __volatile__ ("jz _second_phase_commit_strt");   // 2 cycles
    8ef6:	02 24       	jz	$+6      	;abs 0x8efc

00008ef8 <.Loc.485.1>:

		__asm__ __volatile__ ("mov #0x6030,  r12 ");		 // 2 cycles
    8ef8:	3c 40 30 60 	mov	#24624,	r12	;#0x6030

00008efc <_second_phase_commit_strt>:


		__asm__ __volatile__ ("_second_phase_commit_strt:"); 	 // Worst case

		__asm__ __volatile__ ("mov @r12+2,  r13 ");   		 // 3 cycles
    8efc:	3d 4c       	mov	@r12+,	r13	;

00008efe <.Loc.492.1>:

		__asm__ __volatile__ ("mov r13,  r11 ");   		 // 1 cycle
    8efe:	0b 4d       	mov	r13,	r11	;

00008f00 <.Loc.494.1>:

		__asm__ __volatile__ ("and #0x8000,  r11 ");   		 // 2 cycles
    8f00:	3b f0 00 80 	and	#32768,	r11	;#0x8000

00008f04 <.Loc.495.1>:
		__asm__ __volatile__ ("cmp #0x8000,  r11 ");   		 // 2 cycles
    8f04:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

00008f08 <.Loc.496.1>:
		__asm__ __volatile__ ("jeq _byte_copy ");   		 // 2 cycles
    8f08:	08 24       	jz	$+18     	;abs 0x8f1a

00008f0a <.Loc.507.1>:
	
		//__asm__ __volatile__ ("incd r10 	  ");    	 // 1 cycle
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		 // 1 cycle - verify that the redirected value corresponds to the current PC return value
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	 // 2 cycles
  
		__asm__ __volatile__ ("mov @r14, @r13 ");    		 // 5 cycles
    8f0a:	ad 4e 00 00 	mov	@r14,	0(r13)	;

00008f0e <_pre_end_copy>:

		__asm__ __volatile__ ("_pre_end_copy:");
		__asm__ __volatile__ ("incd r14");    			 // 1 cycle
    8f0e:	2e 53       	incd	r14		;

00008f10 <.Loc.511.1>:
		__asm__ __volatile__ ("dec r15");    			 // 1 cycle
    8f10:	1f 83       	dec	r15		;

00008f12 <.Loc.512.1>:
		__asm__ __volatile__ ("tst r15");    			 // 1 cycle
    8f12:	0f 93       	cmp	#0,	r15	;r3 As==00

00008f14 <.Loc.514.1>:

		__asm__ __volatile__ ("jnz  _second_phase_commit_strt"); // 2 cycles
    8f14:	f3 23       	jnz	$-24     	;abs 0x8efc

00008f16 <.Loc.515.1>:
		__asm__ __volatile__ ("br #_chkpt_finished");		 // 2 cycles
    8f16:	30 40 34 8f 	br	#0x8f34		;

00008f1a <_byte_copy>:

		__asm__ __volatile__ ("_byte_copy:");
		__asm__ __volatile__ ("and #0x7FFF,  r13 ");   		// mask the highest bit - 2 cycles
    8f1a:	3d f0 ff 7f 	and	#32767,	r13	;#0x7fff

00008f1e <.Loc.519.1>:
		__asm__ __volatile__ ("mov r13,      r11 ");   		// 1 cycle
    8f1e:	0b 4d       	mov	r13,	r11	;

00008f20 <.Loc.520.1>:
		__asm__ __volatile__ ("and #0x01,    r11 ");   		// detect if its a byte write - 1 cycle
    8f20:	1b f3       	and	#1,	r11	;r3 As==01

00008f22 <.Loc.521.1>:
		__asm__ __volatile__ ("bis  r11,     r14 ");   		// detect if its a byte write - 1 cycle
    8f22:	0e db       	bis	r11,	r14	;

00008f24 <.Loc.533.1>:
		//__asm__ __volatile__ ("incd r10 	  ");    	// 1 cycle							
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		// 1 cycle - verify that the PC will not be overwritten by a previous violation (Discard it)
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	// 2 cycles


		__asm__ __volatile__ ("mov.b @r14, @r13 ");    				// 5 cycles
    8f24:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00008f28 <.Loc.535.1>:

		__asm__ __volatile__ ("and #0xFFFE, r14");    				 	// 2 cycles
    8f28:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

00008f2c <.Loc.537.1>:

		__asm__ __volatile__ ("incd r14");    				 		// 1 cycle
    8f2c:	2e 53       	incd	r14		;

00008f2e <.Loc.538.1>:
		__asm__ __volatile__ ("dec r15");    						// 1 cycles
    8f2e:	1f 83       	dec	r15		;

00008f30 <.Loc.539.1>:
		__asm__ __volatile__ ("tst r15");    						// 1 cycles
    8f30:	0f 93       	cmp	#0,	r15	;r3 As==00

00008f32 <.Loc.540.1>:
		__asm__ __volatile__ ("jnz  _second_phase_commit_strt");	// 2 cycles
    8f32:	e4 23       	jnz	$-54     	;abs 0x8efc

00008f34 <_chkpt_finished>:
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("_chkpt_finished:");


	    /* Set second phase complete Bit - Atomic Flag*/
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");			//4 cycles
    8f34:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008f38 <.Loc.551.1>:
		__asm__ __volatile__ ("jeq  __pre_finish_2nd_buffer "); //2 cycles
    8f38:	11 24       	jz	$+36     	;abs 0x8f5c

00008f3a <.Loc.553.1>:

		__asm__ __volatile__ ("mov #0x0103, &0x6074 "); //5 cycles	/* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 1ST CHECKPOINT COMPLETELY  */
    8f3a:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    8f3e:	74 60 

00008f40 <.Loc.559.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//																											   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6022,r10"); 		//3 cycles
    8f40:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

00008f44 <.Loc.560.1>:
		__asm__ __volatile__ ("mov &0x6024,r11"); 		//3 cycles
    8f44:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

00008f48 <.Loc.561.1>:
		__asm__ __volatile__ ("mov &0x6026,r12"); 		//3 cycles
    8f48:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

00008f4c <.Loc.562.1>:
		__asm__ __volatile__ ("mov &0x6028,r13"); 	    //3 cycles
    8f4c:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00008f50 <.Loc.563.1>:
		__asm__ __volatile__ ("mov &0x602A,r14"); 	    //3 cycles
    8f50:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

00008f54 <.Loc.564.1>:
		__asm__ __volatile__ ("mov &0x602C,r15"); 	    //3 cycles
    8f54:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

00008f58 <.Loc.566.1>:

		__asm__ __volatile__ ("br #_finish"); 	   		//3 cycles
    8f58:	30 40 7a 8f 	br	#0x8f7a		;

00008f5c <__pre_finish_2nd_buffer>:

		__asm__ __volatile__ ("__pre_finish_2nd_buffer:");

		__asm__ __volatile__ ("mov #0x0301, &0x6074 "); //4 cycles /* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 2ND CHECKPOINT COMPLETELY  */
    8f5c:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    8f60:	74 60 

00008f62 <.Loc.575.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6052,r10"); 	    //3 cycles		
    8f62:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

00008f66 <.Loc.576.1>:
		__asm__ __volatile__ ("mov &0x6054,r11"); 	    //3 cycles
    8f66:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

00008f6a <.Loc.577.1>:
		__asm__ __volatile__ ("mov &0x6056,r12"); 	    //3 cycles
    8f6a:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

00008f6e <.Loc.578.1>:
		__asm__ __volatile__ ("mov &0x6058,r13"); 	    //3 cycles
    8f6e:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

00008f72 <.Loc.579.1>:
		__asm__ __volatile__ ("mov &0x605A,r14"); 	    //3 cycles
    8f72:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

00008f76 <.Loc.580.1>:
		__asm__ __volatile__ ("mov &0x605C,r15"); 	    //3 cycles
    8f76:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

00008f7a <_finish>:

		__asm__ __volatile__ ("_finish:");
		/* Clear the counters, and re-enable Idempotency tracking*/
		__asm__ __volatile__ ("mov #0x0000, &0x6000");	//4 cycles
    8f7a:	82 43 00 60 	mov	#0,	&0x6000	;r3 As==00

00008f7e <.Loc.585.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6002");	//4 cycles
    8f7e:	82 43 02 60 	mov	#0,	&0x6002	;r3 As==00

00008f82 <.Loc.586.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6004");	//4 cycles
    8f82:	82 43 04 60 	mov	#0,	&0x6004	;r3 As==00

00008f86 <.Loc.587.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6006");	//4 cycles
    8f86:	82 43 06 60 	mov	#0,	&0x6006	;r3 As==00

00008f8a <.Loc.588.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6008");	//4 cycles
    8f8a:	82 43 08 60 	mov	#0,	&0x6008	;r3 As==00

00008f8e <.Loc.589.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600A");	//4 cycles
    8f8e:	82 43 0a 60 	mov	#0,	&0x600a	;r3 As==00

00008f92 <.Loc.590.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600C");	//4 cycles
    8f92:	82 43 0c 60 	mov	#0,	&0x600c	;r3 As==00

00008f96 <.Loc.591.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600E");	//4 cycles
    8f96:	82 43 0e 60 	mov	#0,	&0x600e	;r3 As==00

00008f9a <.Loc.593.1>:

		__asm__ __volatile__ ("mov #0x0000, &0x02A2");	//4 cycles
    8f9a:	82 43 a2 02 	mov	#0,	&0x02a2	;r3 As==00

00008f9e <.Loc.594.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A4");	//4 cycles
    8f9e:	82 43 a4 02 	mov	#0,	&0x02a4	;r3 As==00

00008fa2 <.Loc.595.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A6");	//4 cycles
    8fa2:	82 43 a6 02 	mov	#0,	&0x02a6	;r3 As==00

00008fa6 <.Loc.596.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A8");	//4 cycles
    8fa6:	82 43 a8 02 	mov	#0,	&0x02a8	;r3 As==00

00008faa <.Loc.597.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AA");	//4 cycles
    8faa:	82 43 aa 02 	mov	#0,	&0x02aa	;r3 As==00

00008fae <.Loc.598.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AC");	//4 cycles
    8fae:	82 43 ac 02 	mov	#0,	&0x02ac	;r3 As==00

00008fb2 <.Loc.599.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AE");	//4 cycles
    8fb2:	82 43 ae 02 	mov	#0,	&0x02ae	;r3 As==00

00008fb6 <.Loc.600.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02B0");	//4 cycles
    8fb6:	82 43 b0 02 	mov	#0,	&0x02b0	;r3 As==00

00008fba <.Loc.606.1>:

		//Test software to measure the amount of checkpoints

		//__asm__ __volatile__ ("add #0x01, &0x6076");	//4 cycles

		__asm__ __volatile__ ("mov #0x0001, &0x02A0");	//4 cycles
    8fba:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008fbe <.Loc.610.1>:



}
    8fbe:	03 43       	nop			
    8fc0:	00 13       	reti			

00008fc2 <ta_wait_no_lpm>:
//    TA_WAIT_NO_LPM                                 //
// ( the function implements a wait by continously ) //
// ( polling the TAR register                      ) //
//                                                   //
//---------------------------------------------------//
void ta_wait_no_lpm(unsigned int time_cnt) {
    8fc2:	21 83       	decd	r1		;

00008fc4 <.LCFI0>:
    8fc4:	81 4c 00 00 	mov	r12,	0(r1)	;

00008fc8 <.Loc.14.1>:

  // Start and re-initialize TimerA
  TACTL = TASSEL0 | TACLR | MC_2;
    8fc8:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    8fcc:	bc 40 24 01 	mov	#292,	0(r12)	;#0x0124
    8fd0:	00 00 

00008fd2 <.Loc.17.1>:

  // Wait until time is over
  while(TAR < time_cnt);
    8fd2:	03 43       	nop			

00008fd4 <.L2>:
    8fd4:	3c 40 70 01 	mov	#368,	r12	;#0x0170
    8fd8:	2c 4c       	mov	@r12,	r12	;
    8fda:	2c 91       	cmp	@r1,	r12	;
    8fdc:	fb 2b       	jnc	$-8      	;abs 0x8fd4

00008fde <.Loc.19.1>:

}
    8fde:	03 43       	nop			
    8fe0:	21 53       	incd	r1		;
    8fe2:	30 41       	ret			

00008fe4 <ta_wait>:
// ( the function brings the core to LPM0 state )   //
// ( the timerA IRQ will exit the LPM0 state    )   //
//                                                  //
//--------------------------------------------------//
unsigned int periodic_val;
void ta_wait(unsigned int time_cnt) {
    8fe4:	21 83       	decd	r1		;

00008fe6 <.LCFI1>:
    8fe6:	81 4c 00 00 	mov	r12,	0(r1)	;

00008fea <.Loc.31.1>:

  // Set time limit for IRQ generation
  TACCR0 = time_cnt;
    8fea:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    8fee:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008ff2 <.Loc.32.1>:
  periodic_val = time_cnt;
    8ff2:	a2 41 20 41 	mov	@r1,	&0x4120	;

00008ff6 <.Loc.34.1>:
  // Start and re-initialize TimerA
  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    8ff6:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    8ffa:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    8ffe:	00 00 

00009000 <.Loc.39.1>:

  // Go to Low-Power-Mode 0
  //LPM0;

}
    9000:	03 43       	nop			
    9002:	21 53       	incd	r1		;
    9004:	30 41       	ret			

00009006 <INT_timerA1>:

//--------------------------------------------------//
//    TIMER A INTERRUPT                             //
//--------------------------------------------------//
wakeup interrupt (TIMERA1_VECTOR) INT_timerA1(void) {
    9006:	0c 12       	push	r12		;

00009008 <.LCFI2>:


      //Force Reset
	  WDTCTL = 0;
    9008:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    900c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00009010 <.Loc.60.1>:
	  //TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;

	  //QWARK_CHECKPOINT();


}
    9010:	03 43       	nop			
    9012:	b1 c0 f0 00 	bic	#240,	2(r1)	;#0x00f0
    9016:	02 00 
    9018:	3c 41       	pop	r12		;
    901a:	00 13       	reti			

0000901c <UART_WriteChar>:

//--------------------------------------------------//
//                 tty_putc function                 //
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {
    901c:	21 83       	decd	r1		;

0000901e <.LCFI0>:
    901e:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00009022 <.Loc.19.1>:

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    9022:	03 43       	nop			

00009024 <.L2>:
    9024:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081
    9028:	6c 4c       	mov.b	@r12,	r12	;
    902a:	7c f2       	and.b	#8,	r12	;r2 As==11
    902c:	0c 93       	cmp	#0,	r12	;r3 As==00
    902e:	fa 23       	jnz	$-10     	;abs 0x9024

00009030 <.Loc.20.1>:
  LED_CTRL = 0xEE;
    9030:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    9034:	fc 40 ee ff 	mov.b	#65518,	0(r12)	;#0xffee
    9038:	00 00 

0000903a <.Loc.22.1>:
  // Write the output character
  UART_TXD = txdata;
    903a:	7c 40 84 00 	mov.b	#132,	r12	;#0x0084
    903e:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    9042:	00 00 

00009044 <.Loc.24.1>:

  return 0;
    9044:	4c 43       	clr.b	r12		;

00009046 <.Loc.25.1>:
}
    9046:	21 53       	incd	r1		;
    9048:	30 41       	ret			

0000904a <UART_WriteNumber>:


void UART_WriteNumber (int n)
{
    904a:	31 80 18 00 	sub	#24,	r1	;#0x0018

0000904e <.LCFI1>:
    904e:	81 4c 00 00 	mov	r12,	0(r1)	;

00009052 <.Loc.31.1>:
  char buf[20];
  int i = 0;
    9052:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00009056 <.Loc.32.1>:
  if (n < 0)
    9056:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    905a:	25 34       	jge	$+76     	;abs 0x90a6

0000905c <.Loc.34.1>:
    {
	  UART_WriteChar ('-');
    905c:	7c 40 2d 00 	mov.b	#45,	r12	;#0x002d
    9060:	b0 12 1c 90 	call	#36892		;#0x901c

00009064 <.Loc.35.1>:
      n = -n;
    9064:	4c 43       	clr.b	r12		;
    9066:	2c 81       	sub	@r1,	r12	;
    9068:	81 4c 00 00 	mov	r12,	0(r1)	;

0000906c <.Loc.37.1>:
    }
  while (n > 9)
    906c:	30 40 a6 90 	br	#0x90a6		;

00009070 <.L7>:
    {
      buf[i++] = (n%10) + '0';
    9070:	2c 41       	mov	@r1,	r12	;
    9072:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9076:	b0 12 bc 91 	call	#37308		;#0x91bc
    907a:	4d 4c       	mov.b	r12,	r13	;
    907c:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9080:	0e 4c       	mov	r12,	r14	;
    9082:	1e 53       	inc	r14		;
    9084:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    9088:	7d 50 30 00 	add.b	#48,	r13	;#0x0030
    908c:	4e 4d       	mov.b	r13,	r14	;
    908e:	0d 41       	mov	r1,	r13	;
    9090:	2d 53       	incd	r13		;
    9092:	0c 5d       	add	r13,	r12	;
    9094:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00009098 <.Loc.40.1>:
      n /= 10;
    9098:	2c 41       	mov	@r1,	r12	;
    909a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    909e:	b0 12 70 91 	call	#37232		;#0x9170
    90a2:	81 4c 00 00 	mov	r12,	0(r1)	;

000090a6 <.L6>:
  if (n < 0)
    {
	  UART_WriteChar ('-');
      n = -n;
    }
  while (n > 9)
    90a6:	7c 40 09 00 	mov.b	#9,	r12	;
    90aa:	2c 91       	cmp	@r1,	r12	;
    90ac:	e1 3b       	jl	$-60     	;abs 0x9070

000090ae <.Loc.42.1>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
    90ae:	2c 41       	mov	@r1,	r12	;
    90b0:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    90b4:	b0 12 bc 91 	call	#37308		;#0x91bc
    90b8:	4d 4c       	mov.b	r12,	r13	;
    90ba:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    90be:	0e 4c       	mov	r12,	r14	;
    90c0:	1e 53       	inc	r14		;
    90c2:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    90c6:	7d 50 30 00 	add.b	#48,	r13	;#0x0030
    90ca:	4e 4d       	mov.b	r13,	r14	;
    90cc:	0d 41       	mov	r1,	r13	;
    90ce:	2d 53       	incd	r13		;
    90d0:	0c 5d       	add	r13,	r12	;
    90d2:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

000090d6 <.Loc.43.1>:
  while (i > 0)
    90d6:	30 40 ec 90 	br	#0x90ec		;

000090da <.L9>:
	  UART_WriteChar (buf[--i]);
    90da:	b1 53 16 00 	add	#-1,	22(r1)	;r3 As==11, 0x0016
    90de:	0c 41       	mov	r1,	r12	;
    90e0:	2c 53       	incd	r12		;
    90e2:	1c 51 16 00 	add	22(r1),	r12	;0x00016
    90e6:	6c 4c       	mov.b	@r12,	r12	;
    90e8:	b0 12 1c 90 	call	#36892		;#0x901c

000090ec <.L8>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
  while (i > 0)
    90ec:	4c 43       	clr.b	r12		;
    90ee:	1c 91 16 00 	cmp	22(r1),	r12	;0x00016
    90f2:	f3 3b       	jl	$-24     	;abs 0x90da

000090f4 <.Loc.45.1>:
	  UART_WriteChar (buf[--i]);
}
    90f4:	03 43       	nop			
    90f6:	31 50 18 00 	add	#24,	r1	;#0x0018
    90fa:	30 41       	ret			

000090fc <UART_WriteString>:
/* This function prints a string of characters on the UART. The usage of this function is mostly    */
/* for debugging purposes.                                                                          */
/* Parameter(s)                                                                                     */
/* string      string of characters that will be printed through the UART                           */

void UART_WriteString(char* string){
    90fc:	21 82       	sub	#4,	r1	;r2 As==10

000090fe <.LCFI2>:
    90fe:	81 4c 00 00 	mov	r12,	0(r1)	;

00009102 <.Loc.54.1>:

    char i = 0;
    9102:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00009106 <.Loc.57.1>:

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    9106:	30 40 1e 91 	br	#0x911e		;

0000910a <.L12>:
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);
    910a:	5c 41 03 00 	mov.b	3(r1),	r12	;
    910e:	4d 4c       	mov.b	r12,	r13	;
    9110:	5d 53       	inc.b	r13		;
    9112:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    9116:	2c 51       	add	@r1,	r12	;
    9118:	6c 4c       	mov.b	@r12,	r12	;
    911a:	b0 12 1c 90 	call	#36892		;#0x901c

0000911e <.L11>:
void UART_WriteString(char* string){

    char i = 0;

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    911e:	5c 41 03 00 	mov.b	3(r1),	r12	;
    9122:	2c 51       	add	@r1,	r12	;
    9124:	6c 4c       	mov.b	@r12,	r12	;
    9126:	0c 93       	cmp	#0,	r12	;r3 As==00
    9128:	f0 23       	jnz	$-30     	;abs 0x910a

0000912a <.Loc.63.1>:
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);

    }
 }
    912a:	03 43       	nop			
    912c:	21 52       	add	#4,	r1	;r2 As==10
    912e:	30 41       	ret			

00009130 <udivmodhi4>:
    9130:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011

00009134 <.Loc.35.1>:
    9134:	5b 43       	mov.b	#1,	r11	;r3 As==01

00009136 <.L2>:
    9136:	0d 9c       	cmp	r12,	r13	;
    9138:	08 28       	jnc	$+18     	;abs 0x914a

0000913a <.L15>:
    913a:	4f 43       	clr.b	r15		;

0000913c <.L4>:
    913c:	0b 93       	cmp	#0,	r11	;r3 As==00
    913e:	0e 20       	jnz	$+30     	;abs 0x915c

00009140 <.L5>:
    9140:	0e 93       	cmp	#0,	r14	;r3 As==00
    9142:	01 24       	jz	$+4      	;abs 0x9146
    9144:	0f 4c       	mov	r12,	r15	;

00009146 <.L1>:
    9146:	0c 4f       	mov	r15,	r12	;
    9148:	30 41       	ret			

0000914a <.L3>:
    914a:	3f 53       	add	#-1,	r15	;r3 As==11

0000914c <.Loc.38.1>:
    914c:	0f 93       	cmp	#0,	r15	;r3 As==00
    914e:	f8 27       	jz	$-14     	;abs 0x9140

00009150 <.Loc.38.1>:
    9150:	0d 93       	cmp	#0,	r13	;r3 As==00
    9152:	f3 3b       	jl	$-24     	;abs 0x913a

00009154 <.Loc.40.1>:
    9154:	0d 5d       	rla	r13		;

00009156 <.Loc.41.1>:
    9156:	0b 5b       	rla	r11		;
    9158:	30 40 36 91 	br	#0x9136		;

0000915c <.L9>:
    915c:	0c 9d       	cmp	r13,	r12	;
    915e:	02 28       	jnc	$+6      	;abs 0x9164

00009160 <.Loc.47.1>:
    9160:	0c 8d       	sub	r13,	r12	;

00009162 <.Loc.48.1>:
    9162:	0f db       	bis	r11,	r15	;

00009164 <.L8>:
    9164:	12 c3       	clrc			
    9166:	0b 10       	rrc	r11		;

00009168 <.Loc.51.1>:
    9168:	12 c3       	clrc			
    916a:	0d 10       	rrc	r13		;
    916c:	30 40 3c 91 	br	#0x913c		;

00009170 <__mspabi_divi>:
    9170:	0a 12       	push	r10		;

00009172 <.LCFI0>:
    9172:	0f 4c       	mov	r12,	r15	;
    9174:	0e 4d       	mov	r13,	r14	;

00009176 <.LVL14>:
    9176:	3b 40 30 91 	mov	#37168,	r11	;#0x9130

0000917a <.Loc.64.1>:
    917a:	0c 93       	cmp	#0,	r12	;r3 As==00
    917c:	1a 34       	jge	$+54     	;abs 0x91b2

0000917e <.Loc.66.1>:
    917e:	4c 43       	clr.b	r12		;

00009180 <.LVL15>:
    9180:	0c 8f       	sub	r15,	r12	;
    9182:	0f 4c       	mov	r12,	r15	;

00009184 <.LVL16>:
    9184:	0d 93       	cmp	#0,	r13	;r3 As==00
    9186:	0d 34       	jge	$+28     	;abs 0x91a2

00009188 <.Loc.67.1>:
    9188:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000918a <.L21>:
    918a:	0d 43       	clr	r13		;
    918c:	0d 8e       	sub	r14,	r13	;

0000918e <.LVL18>:
    918e:	4e 43       	clr.b	r14		;

00009190 <.LVL19>:
    9190:	0c 4f       	mov	r15,	r12	;

00009192 <.LVL20>:
    9192:	8b 12       	call	r11		;

00009194 <.LVL21>:
    9194:	1a 93       	cmp	#1,	r10	;r3 As==01
    9196:	03 24       	jz	$+8      	;abs 0x919e

00009198 <.L20>:
    9198:	4d 43       	clr.b	r13		;
    919a:	0d 8c       	sub	r12,	r13	;
    919c:	0c 4d       	mov	r13,	r12	;

0000919e <.L16>:
    919e:	3a 41       	pop	r10		;
    91a0:	30 41       	ret			

000091a2 <.L18>:
    91a2:	4e 43       	clr.b	r14		;
    91a4:	8b 12       	call	r11		;

000091a6 <.LVL25>:
    91a6:	30 40 98 91 	br	#0x9198		;

000091aa <.L27>:
    91aa:	4e 43       	clr.b	r14		;
    91ac:	8b 12       	call	r11		;

000091ae <.LVL27>:
    91ae:	30 40 9e 91 	br	#0x919e		;

000091b2 <.L17>:
    91b2:	0d 93       	cmp	#0,	r13	;r3 As==00
    91b4:	fa 37       	jge	$-10     	;abs 0x91aa

000091b6 <.Loc.61.1>:
    91b6:	4a 43       	clr.b	r10		;
    91b8:	30 40 8a 91 	br	#0x918a		;

000091bc <__mspabi_remi>:
    91bc:	0a 12       	push	r10		;

000091be <.LCFI1>:
    91be:	0c 93       	cmp	#0,	r12	;r3 As==00
    91c0:	13 34       	jge	$+40     	;abs 0x91e8

000091c2 <.Loc.92.1>:
    91c2:	4e 43       	clr.b	r14		;
    91c4:	0e 8c       	sub	r12,	r14	;
    91c6:	0c 4e       	mov	r14,	r12	;

000091c8 <.LVL31>:
    91c8:	5a 43       	mov.b	#1,	r10	;r3 As==01

000091ca <.L29>:
    91ca:	0d 93       	cmp	#0,	r13	;r3 As==00
    91cc:	03 34       	jge	$+8      	;abs 0x91d4
    91ce:	4e 43       	clr.b	r14		;
    91d0:	0e 8d       	sub	r13,	r14	;
    91d2:	0d 4e       	mov	r14,	r13	;

000091d4 <.L30>:
    91d4:	5e 43       	mov.b	#1,	r14	;r3 As==01
    91d6:	b0 12 30 91 	call	#37168		;#0x9130

000091da <.LVL34>:
    91da:	0a 93       	cmp	#0,	r10	;r3 As==00
    91dc:	03 24       	jz	$+8      	;abs 0x91e4

000091de <.LVL35>:
    91de:	4d 43       	clr.b	r13		;
    91e0:	0d 8c       	sub	r12,	r13	;
    91e2:	0c 4d       	mov	r13,	r12	;

000091e4 <.L28>:
    91e4:	3a 41       	pop	r10		;
    91e6:	30 41       	ret			

000091e8 <.L32>:
    91e8:	4a 43       	clr.b	r10		;
    91ea:	30 40 ca 91 	br	#0x91ca		;

000091ee <__mspabi_divu>:
    91ee:	4e 43       	clr.b	r14		;
    91f0:	b0 12 30 91 	call	#37168		;#0x9130

000091f4 <.LVL39>:
    91f4:	30 41       	ret			

000091f6 <__mspabi_remu>:
    91f6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    91f8:	b0 12 30 91 	call	#37168		;#0x9130

000091fc <.LVL41>:
    91fc:	30 41       	ret			

000091fe <__mspabi_func_epilog_7>:
    91fe:	34 41       	pop	r4		;

00009200 <__mspabi_func_epilog_6>:
    9200:	35 41       	pop	r5		;

00009202 <__mspabi_func_epilog_5>:
    9202:	36 41       	pop	r6		;

00009204 <__mspabi_func_epilog_4>:
    9204:	37 41       	pop	r7		;

00009206 <__mspabi_func_epilog_3>:
    9206:	38 41       	pop	r8		;

00009208 <__mspabi_func_epilog_2>:
    9208:	39 41       	pop	r9		;

0000920a <__mspabi_func_epilog_1>:
    920a:	3a 41       	pop	r10		;
    920c:	30 41       	ret			

0000920e <__mspabi_srli_15>:
    920e:	12 c3       	clrc			
    9210:	0c 10       	rrc	r12		;

00009212 <__mspabi_srli_14>:
    9212:	12 c3       	clrc			
    9214:	0c 10       	rrc	r12		;

00009216 <__mspabi_srli_13>:
    9216:	12 c3       	clrc			
    9218:	0c 10       	rrc	r12		;

0000921a <__mspabi_srli_12>:
    921a:	12 c3       	clrc			
    921c:	0c 10       	rrc	r12		;

0000921e <__mspabi_srli_11>:
    921e:	12 c3       	clrc			
    9220:	0c 10       	rrc	r12		;

00009222 <__mspabi_srli_10>:
    9222:	12 c3       	clrc			
    9224:	0c 10       	rrc	r12		;

00009226 <__mspabi_srli_9>:
    9226:	12 c3       	clrc			
    9228:	0c 10       	rrc	r12		;

0000922a <__mspabi_srli_8>:
    922a:	12 c3       	clrc			
    922c:	0c 10       	rrc	r12		;

0000922e <__mspabi_srli_7>:
    922e:	12 c3       	clrc			
    9230:	0c 10       	rrc	r12		;

00009232 <__mspabi_srli_6>:
    9232:	12 c3       	clrc			
    9234:	0c 10       	rrc	r12		;

00009236 <__mspabi_srli_5>:
    9236:	12 c3       	clrc			
    9238:	0c 10       	rrc	r12		;

0000923a <__mspabi_srli_4>:
    923a:	12 c3       	clrc			
    923c:	0c 10       	rrc	r12		;

0000923e <__mspabi_srli_3>:
    923e:	12 c3       	clrc			
    9240:	0c 10       	rrc	r12		;

00009242 <__mspabi_srli_2>:
    9242:	12 c3       	clrc			
    9244:	0c 10       	rrc	r12		;

00009246 <__mspabi_srli_1>:
    9246:	12 c3       	clrc			
    9248:	0c 10       	rrc	r12		;
    924a:	30 41       	ret			

0000924c <.L11>:
    924c:	3d 53       	add	#-1,	r13	;r3 As==11
    924e:	12 c3       	clrc			
    9250:	0c 10       	rrc	r12		;

00009252 <__mspabi_srli>:
    9252:	0d 93       	cmp	#0,	r13	;r3 As==00
    9254:	fb 23       	jnz	$-8      	;abs 0x924c
    9256:	30 41       	ret			

00009258 <__mspabi_srll_15>:
    9258:	12 c3       	clrc			
    925a:	0d 10       	rrc	r13		;
    925c:	0c 10       	rrc	r12		;

0000925e <__mspabi_srll_14>:
    925e:	12 c3       	clrc			
    9260:	0d 10       	rrc	r13		;
    9262:	0c 10       	rrc	r12		;

00009264 <__mspabi_srll_13>:
    9264:	12 c3       	clrc			
    9266:	0d 10       	rrc	r13		;
    9268:	0c 10       	rrc	r12		;

0000926a <__mspabi_srll_12>:
    926a:	12 c3       	clrc			
    926c:	0d 10       	rrc	r13		;
    926e:	0c 10       	rrc	r12		;

00009270 <__mspabi_srll_11>:
    9270:	12 c3       	clrc			
    9272:	0d 10       	rrc	r13		;
    9274:	0c 10       	rrc	r12		;

00009276 <__mspabi_srll_10>:
    9276:	12 c3       	clrc			
    9278:	0d 10       	rrc	r13		;
    927a:	0c 10       	rrc	r12		;

0000927c <__mspabi_srll_9>:
    927c:	12 c3       	clrc			
    927e:	0d 10       	rrc	r13		;
    9280:	0c 10       	rrc	r12		;

00009282 <__mspabi_srll_8>:
    9282:	12 c3       	clrc			
    9284:	0d 10       	rrc	r13		;
    9286:	0c 10       	rrc	r12		;

00009288 <__mspabi_srll_7>:
    9288:	12 c3       	clrc			
    928a:	0d 10       	rrc	r13		;
    928c:	0c 10       	rrc	r12		;

0000928e <__mspabi_srll_6>:
    928e:	12 c3       	clrc			
    9290:	0d 10       	rrc	r13		;
    9292:	0c 10       	rrc	r12		;

00009294 <__mspabi_srll_5>:
    9294:	12 c3       	clrc			
    9296:	0d 10       	rrc	r13		;
    9298:	0c 10       	rrc	r12		;

0000929a <__mspabi_srll_4>:
    929a:	12 c3       	clrc			
    929c:	0d 10       	rrc	r13		;
    929e:	0c 10       	rrc	r12		;

000092a0 <__mspabi_srll_3>:
    92a0:	12 c3       	clrc			
    92a2:	0d 10       	rrc	r13		;
    92a4:	0c 10       	rrc	r12		;

000092a6 <__mspabi_srll_2>:
    92a6:	12 c3       	clrc			
    92a8:	0d 10       	rrc	r13		;
    92aa:	0c 10       	rrc	r12		;

000092ac <__mspabi_srll_1>:
    92ac:	12 c3       	clrc			
    92ae:	0d 10       	rrc	r13		;
    92b0:	0c 10       	rrc	r12		;
    92b2:	30 41       	ret			

000092b4 <.L12>:
    92b4:	3e 53       	add	#-1,	r14	;r3 As==11
    92b6:	12 c3       	clrc			
    92b8:	0d 10       	rrc	r13		;
    92ba:	0c 10       	rrc	r12		;

000092bc <__mspabi_srll>:
    92bc:	0e 93       	cmp	#0,	r14	;r3 As==00
    92be:	fa 23       	jnz	$-10     	;abs 0x92b4
    92c0:	30 41       	ret			

000092c2 <__mspabi_mpyi>:
    92c2:	02 12       	push	r2		;
    92c4:	32 c2       	dint			
    92c6:	03 43       	nop			
    92c8:	82 4c 30 01 	mov	r12,	&0x0130	;
    92cc:	82 4d 38 01 	mov	r13,	&0x0138	;
    92d0:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    92d4:	00 13       	reti			

000092d6 <__mspabi_mpyl>:
    92d6:	02 12       	push	r2		;
    92d8:	32 c2       	dint			
    92da:	03 43       	nop			
    92dc:	82 4c 30 01 	mov	r12,	&0x0130	;
    92e0:	82 4e 38 01 	mov	r14,	&0x0138	;
    92e4:	82 4c 34 01 	mov	r12,	&0x0134	;
    92e8:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    92ec:	92 42 3c 01 	mov	&0x013c,&0x013a	;0x013c
    92f0:	3a 01 
    92f2:	82 4f 38 01 	mov	r15,	&0x0138	;
    92f6:	82 4d 34 01 	mov	r13,	&0x0134	;
    92fa:	82 4e 38 01 	mov	r14,	&0x0138	;
    92fe:	1d 42 3a 01 	mov	&0x013a,r13	;0x013a
    9302:	00 13       	reti			

00009304 <exit>:
    9304:	0a 12       	push	r10		;

00009306 <.LCFI0>:
    9306:	0a 4c       	mov	r12,	r10	;

00009308 <.Loc.66.1>:
    9308:	4d 43       	clr.b	r13		;
    930a:	b0 12 22 93 	call	#37666		;#0x9322

0000930e <.LVL1>:
    930e:	1c 42 68 80 	mov	&0x8068,r12	;0x8068
    9312:	1d 4c 14 00 	mov	20(r12),r13	;0x00014
    9316:	0d 93       	cmp	#0,	r13	;r3 As==00
    9318:	01 24       	jz	$+4      	;abs 0x931c

0000931a <.Loc.69.1>:
    931a:	8d 12       	call	r13		;

0000931c <.L2>:
    931c:	0c 4a       	mov	r10,	r12	;
    931e:	b0 12 d0 94 	call	#38096		;#0x94d0

00009322 <__call_exitprocs>:
    9322:	0a 12       	push	r10		;

00009324 <.LCFI0>:
    9324:	09 12       	push	r9		;

00009326 <.LCFI1>:
    9326:	08 12       	push	r8		;

00009328 <.LCFI2>:
    9328:	07 12       	push	r7		;

0000932a <.LCFI3>:
    932a:	06 12       	push	r6		;

0000932c <.LCFI4>:
    932c:	05 12       	push	r5		;

0000932e <.LCFI5>:
    932e:	04 12       	push	r4		;

00009330 <.LCFI6>:
    9330:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00009334 <.LCFI7>:
    9334:	81 4c 08 00 	mov	r12,	8(r1)	;
    9338:	05 4d       	mov	r13,	r5	;

0000933a <.Loc.84.1>:
    933a:	1e 42 68 80 	mov	&0x8068,r14	;0x8068
    933e:	3e 50 24 00 	add	#36,	r14	;#0x0024
    9342:	81 4e 0a 00 	mov	r14,	10(r1)	; 0x000a

00009346 <.L31>:
    9346:	1e 42 68 80 	mov	&0x8068,r14	;0x8068
    934a:	1a 4e 24 00 	mov	36(r14),r10	;0x00024

0000934e <.LVL2>:
    934e:	17 41 0a 00 	mov	10(r1),	r7	;0x0000a

00009352 <.LVL3>:
    9352:	36 40 00 00 	mov	#0,	r6	;

00009356 <.L2>:
    9356:	0a 93       	cmp	#0,	r10	;r3 As==00
    9358:	04 20       	jnz	$+10     	;abs 0x9362

0000935a <.L1>:
    935a:	31 50 0c 00 	add	#12,	r1	;#0x000c
    935e:	30 40 fe 91 	br	#0x91fe		;

00009362 <.L19>:
    9362:	14 4a 44 00 	mov	68(r10),r4	;0x00044

00009366 <.Loc.92.1>:
    9366:	19 4a 02 00 	mov	2(r10),	r9	;
    936a:	08 49       	mov	r9,	r8	;
    936c:	38 53       	add	#-1,	r8	;r3 As==11
    936e:	09 59       	rla	r9		;

00009370 <.L3>:
    9370:	08 93       	cmp	#0,	r8	;r3 As==00
    9372:	14 34       	jge	$+42     	;abs 0x939c

00009374 <.Loc.136.1>:
    9374:	06 93       	cmp	#0,	r6	;r3 As==00
    9376:	f1 27       	jz	$-28     	;abs 0x935a
    9378:	2c 4a       	mov	@r10,	r12	;

0000937a <.Loc.141.1>:
    937a:	8a 93 02 00 	cmp	#0,	2(r10)	;r3 As==00
    937e:	6b 20       	jnz	$+216    	;abs 0x9456

00009380 <.Loc.141.1>:
    9380:	0c 93       	cmp	#0,	r12	;r3 As==00
    9382:	69 24       	jz	$+212    	;abs 0x9456

00009384 <.Loc.144.1>:
    9384:	87 4c 00 00 	mov	r12,	0(r7)	;

00009388 <.Loc.146.1>:
    9388:	04 93       	cmp	#0,	r4	;r3 As==00
    938a:	02 24       	jz	$+6      	;abs 0x9390

0000938c <.Loc.147.1>:
    938c:	0c 44       	mov	r4,	r12	;
    938e:	86 12       	call	r6		;

00009390 <.L17>:
    9390:	0c 4a       	mov	r10,	r12	;
    9392:	86 12       	call	r6		;

00009394 <.LVL8>:
    9394:	2c 47       	mov	@r7,	r12	;

00009396 <.L18>:
    9396:	0a 4c       	mov	r12,	r10	;
    9398:	30 40 56 93 	br	#0x9356		;

0000939c <.L14>:
    939c:	05 93       	cmp	#0,	r5	;r3 As==00
    939e:	0c 24       	jz	$+26     	;abs 0x93b8

000093a0 <.Loc.99.1>:
    93a0:	04 93       	cmp	#0,	r4	;r3 As==00
    93a2:	05 20       	jnz	$+12     	;abs 0x93ae

000093a4 <.L6>:
    93a4:	38 53       	add	#-1,	r8	;r3 As==11

000093a6 <.LVL11>:
    93a6:	39 50 fe ff 	add	#65534,	r9	;#0xfffe
    93aa:	30 40 70 93 	br	#0x9370		;

000093ae <.L5>:
    93ae:	0c 44       	mov	r4,	r12	;
    93b0:	0c 59       	add	r9,	r12	;
    93b2:	8c 95 3e 00 	cmp	r5,	62(r12)	; 0x003e
    93b6:	f6 23       	jnz	$-18     	;abs 0x93a4

000093b8 <.L4>:
    93b8:	0c 4a       	mov	r10,	r12	;
    93ba:	0c 59       	add	r9,	r12	;

000093bc <.Loc.104.1>:
    93bc:	1f 4c 02 00 	mov	2(r12),	r15	;

000093c0 <.LVL13>:
    93c0:	1d 4a 02 00 	mov	2(r10),	r13	;
    93c4:	3d 53       	add	#-1,	r13	;r3 As==11
    93c6:	0d 98       	cmp	r8,	r13	;
    93c8:	2c 20       	jnz	$+90     	;abs 0x9422

000093ca <.Loc.106.1>:
    93ca:	8a 48 02 00 	mov	r8,	2(r10)	;

000093ce <.L8>:
    93ce:	0f 93       	cmp	#0,	r15	;r3 As==00
    93d0:	e9 27       	jz	$-44     	;abs 0x93a4

000093d2 <.Loc.114.1>:
    93d2:	91 4a 02 00 	mov	2(r10),	6(r1)	;
    93d6:	06 00 

000093d8 <.LVL14>:
    93d8:	04 93       	cmp	#0,	r4	;r3 As==00
    93da:	19 24       	jz	$+52     	;abs 0x940e

000093dc <.Loc.96.1>:
    93dc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    93de:	0d 48       	mov	r8,	r13	;
    93e0:	81 4f 00 00 	mov	r15,	0(r1)	;
    93e4:	b0 12 80 94 	call	#38016		;#0x9480

000093e8 <.LVL15>:
    93e8:	0d 4c       	mov	r12,	r13	;
    93ea:	3d b0 00 80 	bit	#32768,	r13	;#0x8000
    93ee:	0e 7e       	subc	r14,	r14	;
    93f0:	3e e3       	inv	r14		;
    93f2:	81 4d 02 00 	mov	r13,	2(r1)	;
    93f6:	81 4e 04 00 	mov	r14,	4(r1)	;
    93fa:	1b 44 80 00 	mov	128(r4),r11	;0x00080
    93fe:	0b fc       	and	r12,	r11	;
    9400:	1d 44 82 00 	mov	130(r4),r13	;0x00082
    9404:	0d fe       	and	r14,	r13	;
    9406:	0d db       	bis	r11,	r13	;
    9408:	2f 41       	mov	@r1,	r15	;

0000940a <.LVL16>:
    940a:	0d 93       	cmp	#0,	r13	;r3 As==00
    940c:	0e 20       	jnz	$+30     	;abs 0x942a

0000940e <.L9>:
    940e:	8f 12       	call	r15		;

00009410 <.L11>:
    9410:	9a 91 06 00 	cmp	6(r1),	2(r10)	;
    9414:	02 00 
    9416:	97 23       	jnz	$-208    	;abs 0x9346

00009418 <.Loc.127.1>:
    9418:	87 9a 00 00 	cmp	r10,	0(r7)	;
    941c:	c3 27       	jz	$-120    	;abs 0x93a4
    941e:	30 40 46 93 	br	#0x9346		;

00009422 <.L7>:
    9422:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    9426:	30 40 ce 93 	br	#0x93ce		;

0000942a <.L10>:
    942a:	0d 44       	mov	r4,	r13	;
    942c:	0d 59       	add	r9,	r13	;
    942e:	1d 4d fe ff 	mov	-2(r13),r13	;

00009432 <.Loc.119.1>:
    9432:	1c f4 84 00 	and	132(r4),r12	;0x00084
    9436:	1b 44 86 00 	mov	134(r4),r11	;0x00086
    943a:	1b f1 04 00 	and	4(r1),	r11	;
    943e:	0c db       	bis	r11,	r12	;
    9440:	0c 93       	cmp	#0,	r12	;r3 As==00
    9442:	05 20       	jnz	$+12     	;abs 0x944e

00009444 <.Loc.120.1>:
    9444:	1c 41 08 00 	mov	8(r1),	r12	;
    9448:	8f 12       	call	r15		;

0000944a <.LVL20>:
    944a:	30 40 10 94 	br	#0x9410		;

0000944e <.L12>:
    944e:	0c 4d       	mov	r13,	r12	;
    9450:	8f 12       	call	r15		;

00009452 <.LVL22>:
    9452:	30 40 10 94 	br	#0x9410		;

00009456 <.L16>:
    9456:	07 4a       	mov	r10,	r7	;

00009458 <.LVL24>:
    9458:	30 40 96 93 	br	#0x9396		;

0000945c <__mspabi_slli_15>:
    945c:	0c 5c       	rla	r12		;

0000945e <__mspabi_slli_14>:
    945e:	0c 5c       	rla	r12		;

00009460 <__mspabi_slli_13>:
    9460:	0c 5c       	rla	r12		;

00009462 <__mspabi_slli_12>:
    9462:	0c 5c       	rla	r12		;

00009464 <__mspabi_slli_11>:
    9464:	0c 5c       	rla	r12		;

00009466 <__mspabi_slli_10>:
    9466:	0c 5c       	rla	r12		;

00009468 <__mspabi_slli_9>:
    9468:	0c 5c       	rla	r12		;

0000946a <__mspabi_slli_8>:
    946a:	0c 5c       	rla	r12		;

0000946c <__mspabi_slli_7>:
    946c:	0c 5c       	rla	r12		;

0000946e <__mspabi_slli_6>:
    946e:	0c 5c       	rla	r12		;

00009470 <__mspabi_slli_5>:
    9470:	0c 5c       	rla	r12		;

00009472 <__mspabi_slli_4>:
    9472:	0c 5c       	rla	r12		;

00009474 <__mspabi_slli_3>:
    9474:	0c 5c       	rla	r12		;

00009476 <__mspabi_slli_2>:
    9476:	0c 5c       	rla	r12		;

00009478 <__mspabi_slli_1>:
    9478:	0c 5c       	rla	r12		;
    947a:	30 41       	ret			

0000947c <.L11>:
    947c:	3d 53       	add	#-1,	r13	;r3 As==11
    947e:	0c 5c       	rla	r12		;

00009480 <__mspabi_slli>:
    9480:	0d 93       	cmp	#0,	r13	;r3 As==00
    9482:	fc 23       	jnz	$-6      	;abs 0x947c
    9484:	30 41       	ret			

00009486 <__mspabi_slll_15>:
    9486:	0c 5c       	rla	r12		;
    9488:	0d 6d       	rlc	r13		;

0000948a <__mspabi_slll_14>:
    948a:	0c 5c       	rla	r12		;
    948c:	0d 6d       	rlc	r13		;

0000948e <__mspabi_slll_13>:
    948e:	0c 5c       	rla	r12		;
    9490:	0d 6d       	rlc	r13		;

00009492 <__mspabi_slll_12>:
    9492:	0c 5c       	rla	r12		;
    9494:	0d 6d       	rlc	r13		;

00009496 <__mspabi_slll_11>:
    9496:	0c 5c       	rla	r12		;
    9498:	0d 6d       	rlc	r13		;

0000949a <__mspabi_slll_10>:
    949a:	0c 5c       	rla	r12		;
    949c:	0d 6d       	rlc	r13		;

0000949e <__mspabi_slll_9>:
    949e:	0c 5c       	rla	r12		;
    94a0:	0d 6d       	rlc	r13		;

000094a2 <__mspabi_slll_8>:
    94a2:	0c 5c       	rla	r12		;
    94a4:	0d 6d       	rlc	r13		;

000094a6 <__mspabi_slll_7>:
    94a6:	0c 5c       	rla	r12		;
    94a8:	0d 6d       	rlc	r13		;

000094aa <__mspabi_slll_6>:
    94aa:	0c 5c       	rla	r12		;
    94ac:	0d 6d       	rlc	r13		;

000094ae <__mspabi_slll_5>:
    94ae:	0c 5c       	rla	r12		;
    94b0:	0d 6d       	rlc	r13		;

000094b2 <__mspabi_slll_4>:
    94b2:	0c 5c       	rla	r12		;
    94b4:	0d 6d       	rlc	r13		;

000094b6 <__mspabi_slll_3>:
    94b6:	0c 5c       	rla	r12		;
    94b8:	0d 6d       	rlc	r13		;

000094ba <__mspabi_slll_2>:
    94ba:	0c 5c       	rla	r12		;
    94bc:	0d 6d       	rlc	r13		;

000094be <__mspabi_slll_1>:
    94be:	0c 5c       	rla	r12		;
    94c0:	0d 6d       	rlc	r13		;
    94c2:	30 41       	ret			

000094c4 <.L12>:
    94c4:	3e 53       	add	#-1,	r14	;r3 As==11
    94c6:	0c 5c       	rla	r12		;
    94c8:	0d 6d       	rlc	r13		;

000094ca <__mspabi_slll>:
    94ca:	0e 93       	cmp	#0,	r14	;r3 As==00
    94cc:	fb 23       	jnz	$-8      	;abs 0x94c4
    94ce:	30 41       	ret			

000094d0 <_exit>:
    94d0:	30 40 d0 94 	br	#0x94d0		;

000094d4 <memmove>:
    94d4:	0d 9c       	cmp	r12,	r13	;
    94d6:	0a 28       	jnc	$+22     	;abs 0x94ec

000094d8 <.L5>:
    94d8:	0f 4c       	mov	r12,	r15	;
    94da:	0e 5c       	add	r12,	r14	;

000094dc <.L3>:
    94dc:	0e 9f       	cmp	r15,	r14	;
    94de:	0d 24       	jz	$+28     	;abs 0x94fa

000094e0 <.LVL3>:
    94e0:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    94e4:	1f 53       	inc	r15		;

000094e6 <.LVL4>:
    94e6:	1d 53       	inc	r13		;
    94e8:	30 40 dc 94 	br	#0x94dc		;

000094ec <.L2>:
    94ec:	0f 4d       	mov	r13,	r15	;
    94ee:	0f 5e       	add	r14,	r15	;
    94f0:	0c 9f       	cmp	r15,	r12	;
    94f2:	f2 2f       	jc	$-26     	;abs 0x94d8

000094f4 <.L4>:
    94f4:	3e 53       	add	#-1,	r14	;r3 As==11

000094f6 <.LVL7>:
    94f6:	3e 93       	cmp	#-1,	r14	;r3 As==11
    94f8:	01 20       	jnz	$+4      	;abs 0x94fc

000094fa <.L10>:
    94fa:	30 41       	ret			

000094fc <.L6>:
    94fc:	0b 4c       	mov	r12,	r11	;
    94fe:	0b 5e       	add	r14,	r11	;
    9500:	0f 4d       	mov	r13,	r15	;
    9502:	0f 5e       	add	r14,	r15	;
    9504:	eb 4f 00 00 	mov.b	@r15,	0(r11)	;
    9508:	30 40 f4 94 	br	#0x94f4		;

0000950c <memset>:
    950c:	0f 4c       	mov	r12,	r15	;
    950e:	0e 5c       	add	r12,	r14	;

00009510 <.L2>:
    9510:	0f 9e       	cmp	r14,	r15	;
    9512:	01 20       	jnz	$+4      	;abs 0x9516

00009514 <.Loc.104.1>:
    9514:	30 41       	ret			

00009516 <.L3>:
    9516:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    951a:	1f 53       	inc	r15		;

0000951c <.LVL4>:
    951c:	30 40 10 95 	br	#0x9510		;

00009520 <__do_global_ctors_aux>:
    9520:	0a 12       	push	r10		;
    9522:	3a 40 74 80 	mov	#32884,	r10	;#0x8074

00009526 <.L2>:
    9526:	2c 4a       	mov	@r10,	r12	;
    9528:	3c 93       	cmp	#-1,	r12	;r3 As==11
    952a:	02 20       	jnz	$+6      	;abs 0x9530
    952c:	3a 41       	pop	r10		;
    952e:	30 41       	ret			

00009530 <.L3>:
    9530:	8c 12       	call	r12		;
    9532:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    9536:	30 40 26 95 	br	#0x9526		;

0000953a <__msp430_init>:
    953a:	b0 12 ce 82 	call	#33486		;#0x82ce
    953e:	b0 12 20 95 	call	#38176		;#0x9520

00009542 <L0>:
    9542:	b0 12 0a 82 	call	#33290		;#0x820a

00009546 <.Loc.19.1>:
    9546:	b0 12 fc 81 	call	#33276		;#0x81fc

0000954a <.Loc.20.1>:
    954a:	30 41       	ret			

0000954c <__msp430_fini>:
    954c:	b0 12 18 82 	call	#33304		;#0x8218

00009550 <L0>:
    9550:	b0 12 80 82 	call	#33408		;#0x8280

00009554 <L0>:
    9554:	30 41       	ret			

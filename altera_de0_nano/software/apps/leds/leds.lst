
leds.elf:     file format elf32-msp430

SYMBOL TABLE:
0000ffe8 l    d  __interrupt_vector_5	00000000 __interrupt_vector_5
0000fff0 l    d  __interrupt_vector_9	00000000 __interrupt_vector_9
0000fffe l    d  __reset_vector	00000000 __reset_vector
00008000 l    d  .rodata	00000000 .rodata
0000802c l    d  .text	00000000 .text
00004000 l    d  .data	00000000 .data
00004100 l    d  .bss	00000000 .bss
00004122 l    d  .noinit	00000000 .noinit
00000000 l    d  .MP430.attributes	00000000 .MP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 qwark.c
00008068 l       .text	00000000 __qwark_retry_1st_setup
0000805c l       .text	00000000 __qwark_restore_2nd_setup
0000807c l       .text	00000000 __qwark_retry_2nd_setup
00008050 l       .text	00000000 __qwark_restore_1st_setup
000080e0 l       .text	00000000 __system_restore
0000808c l       .text	00000000 __second_stage_retry
00008094 l       .text	00000000 _retry_second_phase_commit_strt
000080b0 l       .text	00000000 _retry_byte_copy
000080ca l       .text	00000000 __retry_complete
000080da l       .text	00000000 __set_flag_complete
00008156 l       .text	00000000 __Second_buffer_restore_stack
00008116 l       .text	00000000 __First_buffer_restore_stack
0000883a l       .text	00000000 __second_buffer_init
0000883e l       .text	00000000 __first_phase_commit
000088dc l       .text	00000000 __second_phase_start
000088d0 l       .text	00000000 _scratchpad_addr_cpy
000088ea l       .text	00000000 __set_flag_2nd
000088ee l       .text	00000000 _second_phase_commit
0000893c l       .text	00000000 _chkpt_finished
00008904 l       .text	00000000 _second_phase_commit_strt
00008922 l       .text	00000000 _byte_copy
00008916 l       .text	00000000 _pre_end_copy
00008964 l       .text	00000000 __pre_finish_2nd_buffer
00008982 l       .text	00000000 _finish
00000000 l    df *ABS*	00000000 timerA.c
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
000081ee l       .text	00000000 _msp430_run_array
000081fc l       .text	00000000 _msp430_run_done
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtbegin.o
00008024 l     O .rodata	00000000 __CTOR_LIST__
00008028 l     O .rodata	00000000 __DTOR_LIST__
0000801c l     O .rodata	00000000 __EH_FRAME_BEGIN__
00008d34 l     O .text	00000000 __TMC_LIST__
000081fe l     F .text	00000000 deregister_tm_clones
00008218 l     F .text	00000000 register_tm_clones
00008246 l     F .text	00000000 __do_global_dtors_aux
00004100 l     O .bss	00000000 completed.3056
00004102 l     O .bss	00000000 dtor_idx.3058
00008294 l     F .text	00000000 frame_dummy
00004104 l     O .bss	00000000 object.3071
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtend.o
00008026 l     O .rodata	00000000 __CTOR_END__
0000801c l     O .rodata	00000000 __FRAME_END__
00008cfe l     F .text	00000000 __do_global_ctors_aux
00000000 l    df *ABS*	00000000 crt_bss.o
00000000 l    df *ABS*	00000000 crt_movedata.o
00000000 l    df *ABS*	00000000 crt_main.o
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 lib2divHI.o
00000000 l    df *ABS*	00000000 srli.o
00000000 l    df *ABS*	00000000 lib_a-memmove.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crtn.o
00000000 l    df *ABS*	00000000 lib2hw_mul_16.o
00000130 l       *ABS*	00000000 MPY_OP1
00000132 l       *ABS*	00000000 MPY_OP1_S
00000134 l       *ABS*	00000000 MAC_OP1
00000138 l       *ABS*	00000000 MPY_OP2
00000138 l       *ABS*	00000000 MAC_OP2
0000013a l       *ABS*	00000000 RESULT_LO
0000013c l       *ABS*	00000000 RESULT_HI
00000000 l    df *ABS*	00000000 
0000802c l       .text	00000000 _start
00008c16 g       .text	00000000 .hidden __mspabi_srli_9
00008c66 g       .text	00000000 .hidden __mspabi_srll_10
00008c12 g       .text	00000000 .hidden __mspabi_srli_10
000083ae g     F .text	000000a4 ntbl_bitcount
00008bfe g       .text	00000000 .hidden __mspabi_srli_15
00008cb2 g     F .text	00000038 memmove
00008c2a g       .text	00000000 .hidden __mspabi_srli_4
00008b30 g     F .text	00000040 .hidden udivmodhi4
00008c1e g       .text	00000000 .hidden __mspabi_srli_7
00008c78 g       .text	00000000 .hidden __mspabi_srll_7
00008c90 g       .text	00000000 .hidden __mspabi_srll_3
00008bf0 g       .text	00000000 .hidden __mspabi_func_epilog_6
00008d34 g     O .text	00000000 .hidden __TMC_END__
00008c54 g       .text	00000000 .hidden __mspabi_srll_13
0000802a g     O .rodata	00000000 .hidden __DTOR_END__
00008020 g       .rodata	00000000 __fini_array_end
00008c0a g       .text	00000000 .hidden __mspabi_srli_12
0000802c g     F .text	00000004 __crt0_start
00008196 g     F .text	0000000e __crt0_init_bss
00004000 g     O .data	00000100 bits
00000022 g       *ABS*	00000000 __bsssize
00008bbc g     F .text	00000032 .hidden __mspabi_remi
000081b8 g     F .text	0000000a __crt0_call_init_then_main
00008bfa g       .text	00000000 .hidden __mspabi_func_epilog_1
00008bf6 g       .text	00000000 .hidden __mspabi_func_epilog_3
00008c84 g       .text	00000000 .hidden __mspabi_srll_5
00008c42 g       .text	00000000 .hidden __mspabi_srli
00004112 g     O .bss	00000002 n_6
00008c60 g       .text	00000000 .hidden __mspabi_srll_11
00008c26 g       .text	00000000 .hidden __mspabi_srli_5
00008452 g     F .text	0000003e BW_btbl_bitcount
00008a2c g     F .text	000000d2 UART_WriteNumber
00000000  w      *UND*	00000000 __deregister_frame_info
00004122 g       .noinit	00000000 end
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
00008c7e g       .text	00000000 .hidden __mspabi_srll_6
000081de g     F .text	00000000 _msp430_run_fini_array
00008a10 g     F .text	0000001c UART_WriteChar
00008c36 g       .text	00000000 .hidden __mspabi_srli_1
00008c4e g       .text	00000000 .hidden __mspabi_srll_14
0000830c g     F .text	000000a2 bitcount
00008030 g     F .text	00000166 qwark_restore
00008c02 g       .text	00000000 .hidden __mspabi_srli_14
00000100 g       *ABS*	00000000 __romdatacopysize
00004114 g     O .bss	00000002 n_5
0000850e g     F .text	0000001a init
00008c0e g       .text	00000000 .hidden __mspabi_srli_11
00004120 g     O .bss	00000002 periodic_val
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
00008020 g       .rodata	00000000 __fini_array_start
00008b70 g     F .text	0000004c .hidden __mspabi_divi
00000000  w      *ABS*	00000000 __rom_highdatacopysize
000084cc g     F .text	00000042 ntbl_bitcnt
00008d18 g       .text	00000000 __msp430_init
00008cea g     F .text	00000014 memset
00008528 g     F .text	000002f8 main
00004116 g     O .bss	00000002 n_0
000089da g     F .text	00000010 ta_wait
00008c8a g       .text	00000000 .hidden __mspabi_srll_4
00008020 g       .rodata	00000000 __init_array_end
00008c32 g       .text	00000000 .hidden __mspabi_srli_2
00000000  w      *ABS*	00000000 __high_bsssize
000082e6 g     F .text	00000026 bit_count
00000000  w      *ABS*	00000000 __rom_highdatastart
000089ea g     F .text	00000026 INT_timerA1
00008d34 g       .text	00000000 __msp430_fini_end
00008c5a g       .text	00000000 .hidden __mspabi_srll_12
00008d34 g       *ABS*	00000000 __romdatastart
00008afe g     F .text	00000032 UART_WriteString
000081c2 g     F .text	00000000 _msp430_run_init_array
000089c8 g     F .text	00000012 ta_wait_no_lpm
00008c22 g       .text	00000000 .hidden __mspabi_srli_6
00004118 g     O .bss	00000002 n_1
00008020 g       .rodata	00000000 __preinit_array_end
00008c2e g       .text	00000000 .hidden __mspabi_srli_3
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
00004100 g       .bss	00000000 __bssstart
00008bf2 g       .text	00000000 .hidden __mspabi_func_epilog_5
000082ac g     F .text	0000003a btbl_bitcnt
00008000 g       .noinit	00000000 __stack
00008820 g     F .text	000001a8 INT_Qwark
00008c6c g       .text	00000000 .hidden __mspabi_srll_9
00004100 g       .data	00000000 _edata
00008d2a g       .text	00000000 __msp430_init_end
00008cac g       .text	00000000 .hidden __mspabi_srll
00000000  w      *ABS*	00000000 __high_bssstart
00008c48 g       .text	00000000 .hidden __mspabi_srll_15
0000411a g     O .bss	00000002 n_4
0000411c g     O .bss	00000002 n_2
00008020 g       .rodata	00000000 __init_array_start
00008490 g     F .text	0000003c AR_btbl_bitcount
0000411e g     O .bss	00000002 n_3
00008c06 g       .text	00000000 .hidden __mspabi_srli_13
00004000 g       .data	00000000 __datastart
00008c72 g       .text	00000000 .hidden __mspabi_srll_8
00008c9c g       .text	00000000 .hidden __mspabi_srll_1
00008020 g       .rodata	00000000 __preinit_array_start
000081a4 g     F .text	00000014 __crt0_movedata
00008bf8 g       .text	00000000 .hidden __mspabi_func_epilog_2
00000000  w      *UND*	00000000 __register_frame_info
000081d0 g     F .text	00000000 _msp430_run_preinit_array
00008bee g       .text	00000000 .hidden __mspabi_func_epilog_7
00008bf4 g       .text	00000000 .hidden __mspabi_func_epilog_4
00008c96 g       .text	00000000 .hidden __mspabi_srll_2
00008d2a g       .text	00000000 __msp430_fini
00008c1a g       .text	00000000 .hidden __mspabi_srli_8



Disassembly of section __interrupt_vector_5:

0000ffe8 <__interrupt_vector_5>:
    ffe8:	20 88       	interrupt service routine at 0x8820

Disassembly of section __interrupt_vector_9:

0000fff0 <__interrupt_vector_9>:
    fff0:	ea 89       	interrupt service routine at 0x89ea

Disassembly of section .text:

0000802c <__crt0_start>:
    802c:	31 40 00 80 	mov	#32768,	r1	;#0x8000

00008030 <qwark_restore>:
	//    RESTORE HANDLING LOGIC																  				   //
	//	  W.C 30 CYCLES																							   //
	//-------------------------------------------------------------------------------------------------------------//

	/* Disable Qwark */
	__asm__ __volatile__ ("mov #0x0000, &0x02A0");				// 4 cycles
    8030:	82 43 a0 02 	mov	#0,	&0x02a0	;r3 As==00

00008034 <.Loc.29.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");				// 2 cycles
    8034:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

00008038 <.Loc.30.1>:
	__asm__ __volatile__ ("jz __qwark_retry_1st_setup");		// 2 cycles
    8038:	17 24       	jz	$+48     	;abs 0x8068

0000803a <.Loc.32.1>:

	__asm__ __volatile__ ("cmp.b #0x03, &0x6075");				// 3 cycles
    803a:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    803e:	75 60 

00008040 <.Loc.33.1>:
	__asm__ __volatile__ ("jz __qwark_restore_2nd_setup");		// 2 cycles
    8040:	0d 24       	jz	$+28     	;abs 0x805c

00008042 <.Loc.34.1>:
	__asm__ __volatile__ ("cmp.b #0x03, &0x6074");				// 3 cycles
    8042:	f2 90 03 00 	cmp.b	#3,	&0x6074	;
    8046:	74 60 

00008048 <.Loc.35.1>:
	__asm__ __volatile__ ("jnz __crt0_init_bss");				// 2 cycles
    8048:	a6 20       	jnz	$+334    	;abs 0x8196

0000804a <.Loc.37.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6075");				// 2 cycles
    804a:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

0000804e <.Loc.38.1>:
	__asm__ __volatile__ ("jz  __qwark_retry_2nd_setup");		// 2 cycles
    804e:	16 24       	jz	$+46     	;abs 0x807c

00008050 <__qwark_restore_1st_setup>:

	__asm__ __volatile__ ("__qwark_restore_1st_setup:");

	__asm__ __volatile__ ("mov &0X6012,   r12 ");				// 3 cycles
    8050:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008054 <.Loc.43.1>:
    __asm__ __volatile__ ("mov #0x6FFE,   r13 ");				// 2 cycles
    8054:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

00008058 <.Loc.44.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    8058:	30 40 e0 80 	br	#0x80e0		;

0000805c <__qwark_restore_2nd_setup>:

	__asm__ __volatile__ ("__qwark_restore_2nd_setup:");

	__asm__ __volatile__ ("mov &0X6042, r12   ");				// 3 cycles
    805c:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008060 <.Loc.49.1>:
    __asm__ __volatile__ ("mov #0x6BFE, r13   ");				// 2 cycles
    8060:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

00008064 <.Loc.50.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    8064:	30 40 e0 80 	br	#0x80e0		;

00008068 <__qwark_retry_1st_setup>:

	__asm__ __volatile__ ("__qwark_retry_1st_setup:");

	__asm__ __volatile__ ("mov  #0x6030,   r10 ");				// 2 cycles
    8068:	3a 40 30 60 	mov	#24624,	r10	;#0x6030

0000806c <.Loc.55.1>:
	__asm__ __volatile__ ("mov  &0X6012,   r12 ");				// 3 cycles
    806c:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008070 <.Loc.56.1>:
    __asm__ __volatile__ ("mov  #0x6FFE,   r13 ");				// 2 cycles
    8070:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

00008074 <.Loc.57.1>:
	__asm__ __volatile__ ("mov  &0x602E,   r15 ");				// 3 cycles
    8074:	1f 42 2e 60 	mov	&0x602e,r15	;0x602e

00008078 <.Loc.58.1>:
	__asm__ __volatile__ ("br  #__second_stage_retry");			// 2 cycles
    8078:	30 40 8c 80 	br	#0x808c		;

0000807c <__qwark_retry_2nd_setup>:

	__asm__ __volatile__ ("__qwark_retry_2nd_setup:");

	__asm__ __volatile__ ("mov #0x6060,   r10 ");				// 2 cycles
    807c:	3a 40 60 60 	mov	#24672,	r10	;#0x6060

00008080 <.Loc.63.1>:
	__asm__ __volatile__ ("mov &0X6042,   r12 ");				// 3 cycles
    8080:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008084 <.Loc.64.1>:
    __asm__ __volatile__ ("mov #0x6BFE,   r13 ");				// 2 cycles
    8084:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

00008088 <.Loc.65.1>:
	__asm__ __volatile__ ("mov &0x605E,   r15 ");				// 3 cycles
    8088:	1f 42 5e 60 	mov	&0x605e,r15	;0x605e

0000808c <__second_stage_retry>:
	//-------------------------------------------------------------------------------------------------------------//
	//    RETRY SECOND PHASE OF THE COMMIT PROCESS	: 148 cycles												   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__second_stage_retry:");

	__asm__ __volatile__ ("tst r15 ");     		            // 1 cycles
    808c:	0f 93       	cmp	#0,	r15	;r3 As==00

0000808e <.Loc.73.1>:
	__asm__ __volatile__ ("jz  __system_restore");		    // 2 cycles
    808e:	28 24       	jz	$+82     	;abs 0x80e0

00008090 <.Loc.75.1>:

	__asm__ __volatile__ ("mov #0x6000,  r14");			    // 2 cycles
    8090:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008094 <_retry_second_phase_commit_strt>:

	__asm__ __volatile__ ("_retry_second_phase_commit_strt:");  // Worst case

	__asm__ __volatile__ ("mov @r10+2,  r9 ");   			// 2 cycles
    8094:	39 4a       	mov	@r10+,	r9	;

00008096 <.Loc.81.1>:

	__asm__ __volatile__ ("mov r9,  r11 ");   			    // 1 cycle
    8096:	0b 49       	mov	r9,	r11	;

00008098 <.Loc.83.1>:

	__asm__ __volatile__ ("and #0x8000,  r11 ");   			// 2 cycles
    8098:	3b f0 00 80 	and	#32768,	r11	;#0x8000

0000809c <.Loc.84.1>:
	__asm__ __volatile__ ("cmp #0x8000,  r11 ");   			// 2 cycles
    809c:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

000080a0 <.Loc.85.1>:
	__asm__ __volatile__ ("jeq _retry_byte_copy ");   		// 2 cycles
    80a0:	07 24       	jz	$+16     	;abs 0x80b0

000080a2 <.Loc.87.1>:

	__asm__ __volatile__ ("mov @r14+2, @r9 ");    			// 5 cycles
    80a2:	b9 4e 00 00 	mov	@r14+,	0(r9)	;

000080a6 <.Loc.89.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    80a6:	1f 83       	dec	r15		;

000080a8 <.Loc.90.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    80a8:	0f 93       	cmp	#0,	r15	;r3 As==00

000080aa <.Loc.92.1>:

	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80aa:	f4 23       	jnz	$-22     	;abs 0x8094

000080ac <.Loc.93.1>:
	__asm__ __volatile__ ("br #__retry_complete");		    // 2 cycle
    80ac:	30 40 ca 80 	br	#0x80ca		;

000080b0 <_retry_byte_copy>:

	__asm__ __volatile__ ("_retry_byte_copy: ");
	__asm__ __volatile__ ("and #0x7FFF,  r9  ");   			// mask the highest bit 2 cycles
    80b0:	39 f0 ff 7f 	and	#32767,	r9	;#0x7fff

000080b4 <.Loc.97.1>:
	__asm__ __volatile__ ("mov r9,      r11  ");   			// 1 cycle
    80b4:	0b 49       	mov	r9,	r11	;

000080b6 <.Loc.98.1>:
	__asm__ __volatile__ ("and #0x01,    r11 ");   			// detect if its a byte write - 2 cycles
    80b6:	1b f3       	and	#1,	r11	;r3 As==01

000080b8 <.Loc.99.1>:
	__asm__ __volatile__ ("bis  r11,     r14 ");   			// detect if its a byte write - 2 cycles
    80b8:	0e db       	bis	r11,	r14	;

000080ba <.Loc.101.1>:

	__asm__ __volatile__ ("mov.b @r14, @r9  ");    			// 5 cycles
    80ba:	e9 4e 00 00 	mov.b	@r14,	0(r9)	;

000080be <.Loc.102.1>:
	__asm__ __volatile__ ("and #0xFFFE, r14 ");    			// 1 cycle
    80be:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

000080c2 <.Loc.103.1>:
	__asm__ __volatile__ ("incd r14 ");    					// 1 cycle
    80c2:	2e 53       	incd	r14		;

000080c4 <.Loc.105.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    80c4:	1f 83       	dec	r15		;

000080c6 <.Loc.106.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    80c6:	0f 93       	cmp	#0,	r15	;r3 As==00

000080c8 <.Loc.107.1>:
	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80c8:	e5 23       	jnz	$-52     	;abs 0x8094

000080ca <__retry_complete>:

	//-------------------------------------------------------------------------------------------------------------//
	//    END OF THE RETRY-SECOND PHASE	: Atomic Flag Set														   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");		// 4 cycles
    80ca:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

000080ce <.Loc.116.1>:
	__asm__ __volatile__ ("jz __set_flag_complete");	// 2 cycles
    80ce:	05 24       	jz	$+12     	;abs 0x80da

000080d0 <.Loc.118.1>:

	__asm__ __volatile__ ("mov #0x0301, &0x6074 ");		// 5 cycles
    80d0:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    80d4:	74 60 

000080d6 <.Loc.119.1>:
	__asm__ __volatile__ ("br #__system_restore:");		// 2 cycles
    80d6:	30 40 e0 80 	br	#0x80e0		;

000080da <__set_flag_complete>:

	__asm__ __volatile__ ("__set_flag_complete:");
	__asm__ __volatile__ ("mov #0x0103, &0x6074 ");		// 5 cycles
    80da:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    80de:	74 60 

000080e0 <__system_restore>:
	//	 12 CYCLES																								   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__system_restore:");

	/* Disable The Watchdog */
	__asm__ __volatile__ ("mov #288, r8");		// 2 cycles
    80e0:	38 40 20 01 	mov	#288,	r8	;#0x0120

000080e4 <.Loc.132.1>:
	__asm__ __volatile__ ("mov #23168, 0(r8)");	// 2 cycles
    80e4:	b8 40 80 5a 	mov	#23168,	0(r8)	;#0x5a80
    80e8:	00 00 

000080ea <.Loc.135.1>:

	/* Enable and Configure the UART */
	__asm__ __volatile__ ("mov.b #130, r8");	// 2 cycles
    80ea:	78 40 82 00 	mov.b	#130,	r8	;#0x0082

000080ee <.Loc.136.1>:
	__asm__ __volatile__ ("mov   #8, 0(r8)");	// 2 cycles
    80ee:	b8 42 00 00 	mov	#8,	0(r8)	;r2 As==11

000080f2 <.Loc.138.1>:

	__asm__ __volatile__ ("mov.b #128, r8");	// 2 cycles
    80f2:	78 40 80 00 	mov.b	#128,	r8	;#0x0080

000080f6 <.Loc.139.1>:
	__asm__ __volatile__ ("mov.b   #1, 0(r8)"); // 2 cycles
    80f6:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01

000080fa <.Loc.145.1>:

	/* Configure the timer */


#ifdef TIMER_TEST
	__asm__ __volatile__ ("mov  #370, r8");		    // 2 cycles
    80fa:	38 40 72 01 	mov	#370,	r8	;#0x0172

000080fe <.Loc.146.1>:
	__asm__ __volatile__ ("mov  #9980, 0(r8)");	// 2 cycles
    80fe:	b8 40 fc 26 	mov	#9980,	0(r8)	;#0x26fc
    8102:	00 00 

00008104 <.Loc.148.1>:

	__asm__ __volatile__ ("mov  #352, r8");		    // 2 cycles
    8104:	38 40 60 01 	mov	#352,	r8	;#0x0160

00008108 <.Loc.149.1>:
	__asm__ __volatile__ ("mov  #534, 0(r8)");	    // 2 cycles
    8108:	b8 40 16 02 	mov	#534,	0(r8)	;#0x0216
    810c:	00 00 

0000810e <.Loc.205.1>:
	//-------------------------------------------------------------------------------------------------------------//
	//   REGISTERS RESTORE: VERIFY WHICH REGISTERS SHOULD BE RESTORED					   						   //
	//	 																										   //
	//-------------------------------------------------------------------------------------------------------------//

	__asm__ __volatile__ ("cmp.b #0x03,&0x6075");				// 5 cycles
    810e:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    8112:	75 60 

00008114 <.Loc.206.1>:
	__asm__ __volatile__ ("jeq __Second_buffer_restore_stack"); // 2 cycles
    8114:	20 24       	jz	$+66     	;abs 0x8156

00008116 <__First_buffer_restore_stack>:
	/* EDE -> Rm  : 3 cycles each 											  				  			  */
	/* EDE -> PC  : 4 cycles (1 extra cycle penalty) for openMSP430 		  				  			  */
	/* Register time: 14x3 = 42 cycles + 4 cycles (PC) = 49 Cycles + 4(Qwark enable) = 53 cycles 		  */
	__asm__ __volatile__ ("__First_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6016,r4"); 		//R4
    8116:	14 42 16 60 	mov	&0x6016,r4	;0x6016

0000811a <.Loc.216.1>:
	__asm__ __volatile__ ("mov &0x6018,r5"); 		//R5
    811a:	15 42 18 60 	mov	&0x6018,r5	;0x6018

0000811e <.Loc.217.1>:
	__asm__ __volatile__ ("mov &0x601A,r6"); 		//R6
    811e:	16 42 1a 60 	mov	&0x601a,r6	;0x601a

00008122 <.Loc.218.1>:
	__asm__ __volatile__ ("mov &0x601C,r7"); 		//R7
    8122:	17 42 1c 60 	mov	&0x601c,r7	;0x601c

00008126 <.Loc.219.1>:
	__asm__ __volatile__ ("mov &0x601E,r8"); 		//R8
    8126:	18 42 1e 60 	mov	&0x601e,r8	;0x601e

0000812a <.Loc.220.1>:
	__asm__ __volatile__ ("mov &0x6020,r9"); 		//R9
    812a:	19 42 20 60 	mov	&0x6020,r9	;0x6020

0000812e <.Loc.221.1>:
	__asm__ __volatile__ ("mov &0x6022,r10"); 		//R10
    812e:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

00008132 <.Loc.222.1>:
	__asm__ __volatile__ ("mov &0x6024,r11"); 		//R11
    8132:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

00008136 <.Loc.223.1>:
	__asm__ __volatile__ ("mov &0x6026,r12"); 		//R12
    8136:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

0000813a <.Loc.224.1>:
	__asm__ __volatile__ ("mov &0x6028,r13"); 	    //R13
    813a:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

0000813e <.Loc.225.1>:
	__asm__ __volatile__ ("mov &0x602A,r14"); 		//R14
    813e:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

00008142 <.Loc.226.1>:
	__asm__ __volatile__ ("mov &0x602C,r15"); 		//R15
    8142:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

00008146 <.Loc.227.1>:
	__asm__ __volatile__ ("mov &0x6012,r1");   		//SP/R1
    8146:	11 42 12 60 	mov	&0x6012,r1	;0x6012

0000814a <.Loc.228.1>:
	__asm__ __volatile__ ("mov &0x6014,r2"); 	    //SR/R2
    814a:	12 42 14 60 	mov	&0x6014,r2	;0x6014

0000814e <.Loc.231.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    814e:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008152 <.Loc.234.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6010, pc"); 	    //PC/R0
    8152:	10 42 10 60 	br	&0x6010		;

00008156 <__Second_buffer_restore_stack>:

	__asm__ __volatile__ ("__Second_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6046,r4"); 		//R4
    8156:	14 42 46 60 	mov	&0x6046,r4	;0x6046

0000815a <.Loc.239.1>:
	__asm__ __volatile__ ("mov &0x6048,r5"); 		//R5
    815a:	15 42 48 60 	mov	&0x6048,r5	;0x6048

0000815e <.Loc.240.1>:
	__asm__ __volatile__ ("mov &0x604A,r6"); 		//R6
    815e:	16 42 4a 60 	mov	&0x604a,r6	;0x604a

00008162 <.Loc.241.1>:
	__asm__ __volatile__ ("mov &0x604C,r7"); 		//R7
    8162:	17 42 4c 60 	mov	&0x604c,r7	;0x604c

00008166 <.Loc.242.1>:
	__asm__ __volatile__ ("mov &0x604E,r8"); 		//R8
    8166:	18 42 4e 60 	mov	&0x604e,r8	;0x604e

0000816a <.Loc.243.1>:
	__asm__ __volatile__ ("mov &0x6050,r9"); 		//R9
    816a:	19 42 50 60 	mov	&0x6050,r9	;0x6050

0000816e <.Loc.244.1>:
	__asm__ __volatile__ ("mov &0x6052,r10"); 		//R10
    816e:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

00008172 <.Loc.245.1>:
	__asm__ __volatile__ ("mov &0x6054,r11"); 		//R11
    8172:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

00008176 <.Loc.246.1>:
	__asm__ __volatile__ ("mov &0x6056,r12"); 		//R12
    8176:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

0000817a <.Loc.247.1>:
	__asm__ __volatile__ ("mov &0x6058,r13"); 	    //R13
    817a:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

0000817e <.Loc.248.1>:
	__asm__ __volatile__ ("mov &0x605A,r14"); 		//R14
    817e:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

00008182 <.Loc.249.1>:
	__asm__ __volatile__ ("mov &0x605C,r15"); 		//R15
    8182:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

00008186 <.Loc.250.1>:
	__asm__ __volatile__ ("mov &0x6042,r1");   		//SP/R1
    8186:	11 42 42 60 	mov	&0x6042,r1	;0x6042

0000818a <.Loc.251.1>:
	__asm__ __volatile__ ("mov &0x6044,r2"); 	    //SR/R2
    818a:	12 42 44 60 	mov	&0x6044,r2	;0x6044

0000818e <.Loc.254.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    818e:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008192 <.Loc.257.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6040, pc"); 	    //PC/R0
    8192:	10 42 40 60 	br	&0x6040		;

00008196 <__crt0_init_bss>:
    8196:	3c 40 00 41 	mov	#16640,	r12	;#0x4100

0000819a <.Loc.74.1>:
    819a:	0d 43       	clr	r13		;

0000819c <.Loc.75.1>:
    819c:	3e 40 22 00 	mov	#34,	r14	;#0x0022

000081a0 <.Loc.79.1>:
    81a0:	b0 12 ea 8c 	call	#36074		;#0x8cea

000081a4 <__crt0_movedata>:
    81a4:	3c 40 00 40 	mov	#16384,	r12	;#0x4000

000081a8 <.Loc.116.1>:
    81a8:	3d 40 34 8d 	mov	#36148,	r13	;#0x8d34

000081ac <.Loc.119.1>:
    81ac:	0d 9c       	cmp	r12,	r13	;

000081ae <.Loc.120.1>:
    81ae:	04 24       	jz	$+10     	;abs 0x81b8

000081b0 <.Loc.122.1>:
    81b0:	3e 40 00 01 	mov	#256,	r14	;#0x0100

000081b4 <.Loc.124.1>:
    81b4:	b0 12 b2 8c 	call	#36018		;#0x8cb2

000081b8 <__crt0_call_init_then_main>:
    81b8:	b0 12 18 8d 	call	#36120		;#0x8d18

000081bc <.Loc.196.1>:
    81bc:	0c 43       	clr	r12		;

000081be <.Loc.197.1>:
    81be:	b0 12 28 85 	call	#34088		;#0x8528

000081c2 <_msp430_run_init_array>:
    81c2:	34 40 20 80 	mov	#32800,	r4	;#0x8020

000081c6 <.Loc.224.1>:
    81c6:	35 40 20 80 	mov	#32800,	r5	;#0x8020

000081ca <.Loc.225.1>:
    81ca:	26 43       	mov	#2,	r6	;r3 As==10

000081cc <.Loc.226.1>:
    81cc:	30 40 ee 81 	br	#0x81ee		;

000081d0 <_msp430_run_preinit_array>:
    81d0:	34 40 20 80 	mov	#32800,	r4	;#0x8020

000081d4 <.Loc.232.1>:
    81d4:	35 40 20 80 	mov	#32800,	r5	;#0x8020

000081d8 <.Loc.233.1>:
    81d8:	26 43       	mov	#2,	r6	;r3 As==10

000081da <.Loc.234.1>:
    81da:	30 40 ee 81 	br	#0x81ee		;

000081de <_msp430_run_fini_array>:
    81de:	34 40 20 80 	mov	#32800,	r4	;#0x8020

000081e2 <.Loc.240.1>:
    81e2:	35 40 20 80 	mov	#32800,	r5	;#0x8020

000081e6 <.Loc.241.1>:
    81e6:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe

000081ea <.Loc.242.1>:
    81ea:	30 40 ee 81 	br	#0x81ee		;

000081ee <_msp430_run_array>:
    81ee:	05 94       	cmp	r4,	r5	;

000081f0 <.Loc.246.1>:
    81f0:	05 24       	jz	$+12     	;abs 0x81fc

000081f2 <.Loc.247.1>:
    81f2:	27 44       	mov	@r4,	r7	;

000081f4 <.Loc.248.1>:
    81f4:	04 56       	add	r6,	r4	;

000081f6 <.Loc.249.1>:
    81f6:	a7 12       	call	@r7		;

000081f8 <.Loc.250.1>:
    81f8:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x81ee

000081fc <_msp430_run_done>:
    81fc:	30 41       	ret			

000081fe <deregister_tm_clones>:
    81fe:	3c 40 34 8d 	mov	#36148,	r12	;#0x8d34
    8202:	3c 90 34 8d 	cmp	#36148,	r12	;#0x8d34
    8206:	07 24       	jz	$+16     	;abs 0x8216
    8208:	3d 40 00 00 	mov	#0,	r13	;
    820c:	0d 93       	cmp	#0,	r13	;r3 As==00
    820e:	03 24       	jz	$+8      	;abs 0x8216
    8210:	3c 40 34 8d 	mov	#36148,	r12	;#0x8d34
    8214:	8d 12       	call	r13		;

00008216 <.L1>:
    8216:	30 41       	ret			

00008218 <register_tm_clones>:
    8218:	0a 12       	push	r10		;
    821a:	3a 40 34 8d 	mov	#36148,	r10	;#0x8d34
    821e:	3a 80 34 8d 	sub	#36148,	r10	;#0x8d34
    8222:	0a 11       	rra	r10		;
    8224:	0c 4a       	mov	r10,	r12	;
    8226:	b0 12 fe 8b 	call	#35838		;#0x8bfe
    822a:	0c 5a       	add	r10,	r12	;
    822c:	0d 4c       	mov	r12,	r13	;
    822e:	0d 11       	rra	r13		;
    8230:	0d 93       	cmp	#0,	r13	;r3 As==00
    8232:	07 24       	jz	$+16     	;abs 0x8242
    8234:	3e 40 00 00 	mov	#0,	r14	;
    8238:	0e 93       	cmp	#0,	r14	;r3 As==00
    823a:	03 24       	jz	$+8      	;abs 0x8242
    823c:	3c 40 34 8d 	mov	#36148,	r12	;#0x8d34
    8240:	8e 12       	call	r14		;

00008242 <.L9>:
    8242:	3a 41       	pop	r10		;
    8244:	30 41       	ret			

00008246 <__do_global_dtors_aux>:
    8246:	0a 12       	push	r10		;
    8248:	09 12       	push	r9		;
    824a:	c2 93 00 41 	cmp.b	#0,	&0x4100	;r3 As==00
    824e:	17 20       	jnz	$+48     	;abs 0x827e
    8250:	3a 40 2a 80 	mov	#32810,	r10	;#0x802a
    8254:	3a 80 28 80 	sub	#32808,	r10	;#0x8028
    8258:	0a 11       	rra	r10		;
    825a:	3a 53       	add	#-1,	r10	;r3 As==11
    825c:	39 40 28 80 	mov	#32808,	r9	;#0x8028

00008260 <.L19>:
    8260:	1c 42 02 41 	mov	&0x4102,r12	;0x4102
    8264:	0c 9a       	cmp	r10,	r12	;
    8266:	0d 28       	jnc	$+28     	;abs 0x8282
    8268:	b0 12 fe 81 	call	#33278		;#0x81fe
    826c:	3d 40 00 00 	mov	#0,	r13	;
    8270:	0d 93       	cmp	#0,	r13	;r3 As==00
    8272:	03 24       	jz	$+8      	;abs 0x827a
    8274:	3c 40 1c 80 	mov	#32796,	r12	;#0x801c
    8278:	8d 12       	call	r13		;

0000827a <.L21>:
    827a:	d2 43 00 41 	mov.b	#1,	&0x4100	;r3 As==01

0000827e <.L17>:
    827e:	30 40 f8 8b 	br	#0x8bf8		;

00008282 <.L20>:
    8282:	1c 53       	inc	r12		;
    8284:	82 4c 02 41 	mov	r12,	&0x4102	;
    8288:	0c 5c       	rla	r12		;
    828a:	0c 59       	add	r9,	r12	;
    828c:	2c 4c       	mov	@r12,	r12	;
    828e:	8c 12       	call	r12		;
    8290:	30 40 60 82 	br	#0x8260		;

00008294 <frame_dummy>:
    8294:	3e 40 00 00 	mov	#0,	r14	;
    8298:	0e 93       	cmp	#0,	r14	;r3 As==00
    829a:	05 24       	jz	$+12     	;abs 0x82a6
    829c:	3d 40 04 41 	mov	#16644,	r13	;#0x4104
    82a0:	3c 40 1c 80 	mov	#32796,	r12	;#0x801c
    82a4:	8e 12       	call	r14		;

000082a6 <.L27>:
    82a6:	b0 12 18 82 	call	#33304		;#0x8218
    82aa:	30 41       	ret			

000082ac <btbl_bitcnt>:
      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8   /* 240 - 255 */
};


int btbl_bitcnt(uint32_t x)
{
    82ac:	0a 12       	push	r10		;

000082ae <.LCFI0>:
    82ae:	09 12       	push	r9		;

000082b0 <.LCFI1>:
    82b0:	08 12       	push	r8		;

000082b2 <.LCFI2>:
      int cnt = bits[ ((char *)&x)[0] & 0xFF ];
    82b2:	39 40 00 40 	mov	#16384,	r9	;#0x4000
    82b6:	4e 4c       	mov.b	r12,	r14	;
    82b8:	0e 59       	add	r9,	r14	;
    82ba:	68 4e       	mov.b	@r14,	r8	;

000082bc <.Loc.44.1>:

      if (0L != (x >>= 8))
    82bc:	b0 12 72 8c 	call	#35954		;#0x8c72

000082c0 <.LVL2>:
    82c0:	0a 4c       	mov	r12,	r10	;
    82c2:	0a dd       	bis	r13,	r10	;
    82c4:	0a 93       	cmp	#0,	r10	;r3 As==00
    82c6:	0b 24       	jz	$+24     	;abs 0x82de
    82c8:	4a 43       	clr.b	r10		;

000082ca <.L4>:
    82ca:	0a 58       	add	r8,	r10	;

000082cc <.Loc.42.1>:
};


int btbl_bitcnt(uint32_t x)
{
      int cnt = bits[ ((char *)&x)[0] & 0xFF ];
    82cc:	4e 4c       	mov.b	r12,	r14	;
    82ce:	0e 59       	add	r9,	r14	;
    82d0:	68 4e       	mov.b	@r14,	r8	;

000082d2 <.Loc.44.1>:

      if (0L != (x >>= 8))
    82d2:	b0 12 72 8c 	call	#35954		;#0x8c72

000082d6 <.LVL5>:
    82d6:	0e 4c       	mov	r12,	r14	;
    82d8:	0e dd       	bis	r13,	r14	;
    82da:	0e 93       	cmp	#0,	r14	;r3 As==00
    82dc:	f6 23       	jnz	$-18     	;abs 0x82ca

000082de <.L2>:
            cnt += btbl_bitcnt(x);
      return cnt;
}
    82de:	0c 48       	mov	r8,	r12	;
    82e0:	0c 5a       	add	r10,	r12	;
    82e2:	30 40 f6 8b 	br	#0x8bf6		;

000082e6 <bit_count>:
int bit_count(uint32_t x)
{
    82e6:	0e 4c       	mov	r12,	r14	;

000082e8 <.Loc.52.1>:
        int n = 0;

        if (x) do
    82e8:	0c dd       	bis	r13,	r12	;

000082ea <.LVL9>:
    82ea:	0c 93       	cmp	#0,	r12	;r3 As==00
    82ec:	0e 24       	jz	$+30     	;abs 0x830a

000082ee <.LBB16>:
            cnt += btbl_bitcnt(x);
      return cnt;
}
int bit_count(uint32_t x)
{
        int n = 0;
    82ee:	4c 43       	clr.b	r12		;

000082f0 <.L11>:

        if (x) do
              n++;
    82f0:	1c 53       	inc	r12		;

000082f2 <.Loc.54.1>:
        while (0 != (x = x&(x-1))) ;
    82f2:	0b 4e       	mov	r14,	r11	;
    82f4:	3b 53       	add	#-1,	r11	;r3 As==11
    82f6:	0f 4d       	mov	r13,	r15	;
    82f8:	3f 63       	addc	#-1,	r15	;r3 As==11
    82fa:	0b fe       	and	r14,	r11	;
    82fc:	0f fd       	and	r13,	r15	;
    82fe:	0e 4b       	mov	r11,	r14	;

00008300 <.LVL12>:
    8300:	0d 4f       	mov	r15,	r13	;

00008302 <.LVL13>:
    8302:	0f 4b       	mov	r11,	r15	;
    8304:	0f dd       	bis	r13,	r15	;
    8306:	0f 93       	cmp	#0,	r15	;r3 As==00
    8308:	f3 23       	jnz	$-24     	;abs 0x82f0

0000830a <.L8>:
        return(n);
}
    830a:	30 41       	ret			

0000830c <bitcount>:
int bitcount(uint32_t i)
{
    830c:	0a 12       	push	r10		;

0000830e <.LCFI3>:
    830e:	09 12       	push	r9		;

00008310 <.LCFI4>:
    8310:	08 12       	push	r8		;

00008312 <.LCFI5>:
    8312:	07 12       	push	r7		;

00008314 <.LCFI6>:
      i = ((i & 0xAAAAAAAAL) >>  1) + (i & 0x55555555L);
    8314:	0a 4c       	mov	r12,	r10	;
    8316:	0b 4d       	mov	r13,	r11	;
    8318:	12 c3       	clrc			
    831a:	0b 10       	rrc	r11		;
    831c:	0a 10       	rrc	r10		;
    831e:	0e 4a       	mov	r10,	r14	;
    8320:	3e f0 55 55 	and	#21845,	r14	;#0x5555
    8324:	08 4b       	mov	r11,	r8	;
    8326:	38 f0 55 55 	and	#21845,	r8	;#0x5555
    832a:	09 4c       	mov	r12,	r9	;
    832c:	39 f0 55 55 	and	#21845,	r9	;#0x5555
    8330:	0f 4d       	mov	r13,	r15	;
    8332:	3f f0 55 55 	and	#21845,	r15	;#0x5555
    8336:	09 5e       	add	r14,	r9	;
    8338:	08 6f       	addc	r15,	r8	;

0000833a <.LVL16>:
      i = ((i & 0xCCCCCCCCL) >>  2) + (i & 0x33333333L);
    833a:	0c 49       	mov	r9,	r12	;
    833c:	0d 48       	mov	r8,	r13	;
    833e:	b0 12 96 8c 	call	#35990		;#0x8c96
    8342:	0e 4c       	mov	r12,	r14	;
    8344:	3e f0 33 33 	and	#13107,	r14	;#0x3333
    8348:	07 4d       	mov	r13,	r7	;
    834a:	37 f0 33 33 	and	#13107,	r7	;#0x3333
    834e:	0a 49       	mov	r9,	r10	;
    8350:	3a f0 33 33 	and	#13107,	r10	;#0x3333
    8354:	0c 48       	mov	r8,	r12	;
    8356:	3c f0 33 33 	and	#13107,	r12	;#0x3333
    835a:	0a 5e       	add	r14,	r10	;
    835c:	07 6c       	addc	r12,	r7	;

0000835e <.LVL18>:
      i = ((i & 0xF0F0F0F0L) >>  4) + (i & 0x0F0F0F0FL);
    835e:	0c 4a       	mov	r10,	r12	;
    8360:	0d 47       	mov	r7,	r13	;
    8362:	b0 12 8a 8c 	call	#35978		;#0x8c8a
    8366:	0e 4c       	mov	r12,	r14	;
    8368:	3e f0 0f 0f 	and	#3855,	r14	;#0x0f0f
    836c:	08 4d       	mov	r13,	r8	;
    836e:	38 f0 0f 0f 	and	#3855,	r8	;#0x0f0f
    8372:	09 4a       	mov	r10,	r9	;
    8374:	39 f0 0f 0f 	and	#3855,	r9	;#0x0f0f
    8378:	0c 47       	mov	r7,	r12	;
    837a:	3c f0 0f 0f 	and	#3855,	r12	;#0x0f0f
    837e:	09 5e       	add	r14,	r9	;
    8380:	08 6c       	addc	r12,	r8	;

00008382 <.LVL20>:
      i = ((i & 0xFF00FF00L) >>  8) + (i & 0x00FF00FFL);
    8382:	0c 49       	mov	r9,	r12	;
    8384:	0d 48       	mov	r8,	r13	;
    8386:	b0 12 72 8c 	call	#35954		;#0x8c72
    838a:	4e 4c       	mov.b	r12,	r14	;
    838c:	4f 4d       	mov.b	r13,	r15	;
    838e:	0a 49       	mov	r9,	r10	;
    8390:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff
    8394:	0d 48       	mov	r8,	r13	;
    8396:	7d f0 ff 00 	and.b	#255,	r13	;#0x00ff
    839a:	0a 5e       	add	r14,	r10	;
    839c:	0d 6f       	addc	r15,	r13	;

0000839e <.LVL22>:
      i = ((i & 0xFFFF0000L) >> 16) + (i & 0x0000FFFFL);
    839e:	0c 4a       	mov	r10,	r12	;
    83a0:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    83a4:	b0 12 ac 8c 	call	#36012		;#0x8cac

000083a8 <.LVL23>:
      return (int)i;
}
    83a8:	0c 5a       	add	r10,	r12	;
    83aa:	30 40 f4 8b 	br	#0x8bf4		;

000083ae <ntbl_bitcount>:
int ntbl_bitcount(uint32_t x)
{
    83ae:	0a 12       	push	r10		;

000083b0 <.LCFI7>:
    83b0:	09 12       	push	r9		;

000083b2 <.LCFI8>:
    83b2:	08 12       	push	r8		;

000083b4 <.LCFI9>:
    83b4:	07 12       	push	r7		;

000083b6 <.LCFI10>:
    83b6:	08 4c       	mov	r12,	r8	;
    83b8:	07 4d       	mov	r13,	r7	;

000083ba <.Loc.70.1>:
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
    83ba:	39 40 00 40 	mov	#16384,	r9	;#0x4000
    83be:	b0 12 8a 8c 	call	#35978		;#0x8c8a

000083c2 <.LVL25>:
    83c2:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    83c6:	0c 59       	add	r9,	r12	;

000083c8 <.Loc.69.1>:
      return (int)i;
}
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
    83c8:	0d 48       	mov	r8,	r13	;
    83ca:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    83ce:	0d 59       	add	r9,	r13	;
    83d0:	6a 4d       	mov.b	@r13,	r10	;
    83d2:	6c 4c       	mov.b	@r12,	r12	;
    83d4:	0a 5c       	add	r12,	r10	;

000083d6 <.Loc.71.1>:
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
    83d6:	0c 48       	mov	r8,	r12	;
    83d8:	0d 47       	mov	r7,	r13	;
    83da:	b0 12 72 8c 	call	#35954		;#0x8c72
    83de:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    83e2:	0c 59       	add	r9,	r12	;

000083e4 <.Loc.70.1>:
}
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
    83e4:	6c 4c       	mov.b	@r12,	r12	;
    83e6:	0a 5c       	add	r12,	r10	;

000083e8 <.Loc.72.1>:
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
    83e8:	0c 48       	mov	r8,	r12	;
    83ea:	0d 47       	mov	r7,	r13	;
    83ec:	b0 12 5a 8c 	call	#35930		;#0x8c5a
    83f0:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    83f4:	0c 59       	add	r9,	r12	;

000083f6 <.Loc.71.1>:
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
    83f6:	6c 4c       	mov.b	@r12,	r12	;
    83f8:	0a 5c       	add	r12,	r10	;

000083fa <.Loc.73.1>:
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
    83fa:	0c 48       	mov	r8,	r12	;
    83fc:	0d 47       	mov	r7,	r13	;
    83fe:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8402:	b0 12 ac 8c 	call	#36012		;#0x8cac
    8406:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    840a:	0c 59       	add	r9,	r12	;

0000840c <.Loc.72.1>:
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
    840c:	6c 4c       	mov.b	@r12,	r12	;
    840e:	0a 5c       	add	r12,	r10	;

00008410 <.Loc.74.1>:
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
    8410:	0c 48       	mov	r8,	r12	;
    8412:	0d 47       	mov	r7,	r13	;
    8414:	7e 40 14 00 	mov.b	#20,	r14	;#0x0014
    8418:	b0 12 ac 8c 	call	#36012		;#0x8cac
    841c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    8420:	0c 59       	add	r9,	r12	;

00008422 <.Loc.73.1>:
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
    8422:	6c 4c       	mov.b	@r12,	r12	;
    8424:	0a 5c       	add	r12,	r10	;

00008426 <.Loc.75.1>:
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
    8426:	0c 48       	mov	r8,	r12	;
    8428:	0d 47       	mov	r7,	r13	;
    842a:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    842e:	b0 12 ac 8c 	call	#36012		;#0x8cac
    8432:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    8436:	0c 59       	add	r9,	r12	;

00008438 <.Loc.74.1>:
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
    8438:	6c 4c       	mov.b	@r12,	r12	;
    843a:	0a 5c       	add	r12,	r10	;

0000843c <.Loc.76.1>:
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
            bits[ (int)((x & 0xF0000000UL) >> 28)];
    843c:	0c 48       	mov	r8,	r12	;
    843e:	0d 47       	mov	r7,	r13	;
    8440:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    8444:	b0 12 ac 8c 	call	#36012		;#0x8cac
    8448:	0c 59       	add	r9,	r12	;

0000844a <.Loc.77.1>:
}
    844a:	6c 4c       	mov.b	@r12,	r12	;
    844c:	0c 5a       	add	r10,	r12	;
    844e:	30 40 f4 8b 	br	#0x8bf4		;

00008452 <BW_btbl_bitcount>:
int BW_btbl_bitcount(uint32_t x)
{
    8452:	0a 12       	push	r10		;

00008454 <.LCFI11>:
    8454:	09 12       	push	r9		;

00008456 <.LCFI12>:
    8456:	08 12       	push	r8		;

00008458 <.LCFI13>:
    8458:	08 4d       	mov	r13,	r8	;

0000845a <.Loc.88.1>:
            long y;
      } U;

      U.y = x;

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    845a:	3a 40 00 40 	mov	#16384,	r10	;#0x4000
    845e:	4d 4c       	mov.b	r12,	r13	;
    8460:	0d 5a       	add	r10,	r13	;
    8462:	69 4d       	mov.b	@r13,	r9	;
    8464:	b0 12 1a 8c 	call	#35866		;#0x8c1a

00008468 <.LVL33>:
    8468:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    846c:	0c 5a       	add	r10,	r12	;
    846e:	6c 4c       	mov.b	@r12,	r12	;
    8470:	09 5c       	add	r12,	r9	;

00008472 <.Loc.89.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    8472:	0c 48       	mov	r8,	r12	;
    8474:	b0 12 1a 8c 	call	#35866		;#0x8c1a
    8478:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    847c:	0c 5a       	add	r10,	r12	;

0000847e <.Loc.88.1>:
            long y;
      } U;

      U.y = x;

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    847e:	6c 4c       	mov.b	@r12,	r12	;
    8480:	0c 59       	add	r9,	r12	;

00008482 <.Loc.89.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    8482:	38 f0 ff 00 	and	#255,	r8	;#0x00ff
    8486:	0a 58       	add	r8,	r10	;

00008488 <.Loc.90.1>:
}
    8488:	6a 4a       	mov.b	@r10,	r10	;
    848a:	0c 5a       	add	r10,	r12	;
    848c:	30 40 f6 8b 	br	#0x8bf6		;

00008490 <AR_btbl_bitcount>:
int AR_btbl_bitcount(uint32_t x)
{
    8490:	0a 12       	push	r10		;

00008492 <.LCFI14>:
    8492:	09 12       	push	r9		;

00008494 <.LCFI15>:
    8494:	08 12       	push	r8		;

00008496 <.LCFI16>:
    8496:	08 4d       	mov	r13,	r8	;

00008498 <.Loc.96.1>:
      unsigned char * Ptr = (unsigned char *) &x ;
      int Accu ;

      Accu  = bits[ *Ptr++ ];
    8498:	3a 40 00 40 	mov	#16384,	r10	;#0x4000
    849c:	4e 4c       	mov.b	r12,	r14	;
    849e:	0e 5a       	add	r10,	r14	;
    84a0:	69 4e       	mov.b	@r14,	r9	;

000084a2 <.LVL37>:
      Accu += bits[ *Ptr++ ];
    84a2:	b0 12 1a 8c 	call	#35866		;#0x8c1a

000084a6 <.LVL38>:
    84a6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    84aa:	0c 5a       	add	r10,	r12	;
    84ac:	6c 4c       	mov.b	@r12,	r12	;
    84ae:	09 5c       	add	r12,	r9	;

000084b0 <.Loc.98.1>:
      Accu += bits[ *Ptr++ ];
    84b0:	4c 48       	mov.b	r8,	r12	;
    84b2:	0c 5a       	add	r10,	r12	;
    84b4:	6c 4c       	mov.b	@r12,	r12	;
    84b6:	09 5c       	add	r12,	r9	;

000084b8 <.LVL40>:
      Accu += bits[ *Ptr ];
    84b8:	0c 48       	mov	r8,	r12	;
    84ba:	b0 12 1a 8c 	call	#35866		;#0x8c1a
    84be:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    84c2:	0a 5c       	add	r12,	r10	;

000084c4 <.Loc.101.1>:
      return Accu;
}
    84c4:	6c 4a       	mov.b	@r10,	r12	;
    84c6:	0c 59       	add	r9,	r12	;
    84c8:	30 40 f6 8b 	br	#0x8bf6		;

000084cc <ntbl_bitcnt>:
int ntbl_bitcnt(uint32_t x)
{
    84cc:	0a 12       	push	r10		;

000084ce <.LCFI17>:
    84ce:	09 12       	push	r9		;

000084d0 <.LCFI18>:
    84d0:	08 12       	push	r8		;

000084d2 <.LCFI19>:
      int cnt = bits[(int)(x & 0x0000000FL)];
    84d2:	39 40 00 40 	mov	#16384,	r9	;#0x4000
    84d6:	0e 4c       	mov	r12,	r14	;
    84d8:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    84dc:	0e 59       	add	r9,	r14	;
    84de:	68 4e       	mov.b	@r14,	r8	;

000084e0 <.Loc.106.1>:

      if (0L != (x >>= 4))
    84e0:	b0 12 8a 8c 	call	#35978		;#0x8c8a

000084e4 <.LVL44>:
    84e4:	0a 4c       	mov	r12,	r10	;
    84e6:	0a dd       	bis	r13,	r10	;
    84e8:	0a 93       	cmp	#0,	r10	;r3 As==00
    84ea:	0d 24       	jz	$+28     	;abs 0x8506
    84ec:	4a 43       	clr.b	r10		;

000084ee <.L21>:
    84ee:	0a 58       	add	r8,	r10	;

000084f0 <.Loc.104.1>:
      Accu += bits[ *Ptr ];
      return Accu;
}
int ntbl_bitcnt(uint32_t x)
{
      int cnt = bits[(int)(x & 0x0000000FL)];
    84f0:	0e 4c       	mov	r12,	r14	;
    84f2:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    84f6:	0e 59       	add	r9,	r14	;
    84f8:	68 4e       	mov.b	@r14,	r8	;

000084fa <.Loc.106.1>:

      if (0L != (x >>= 4))
    84fa:	b0 12 8a 8c 	call	#35978		;#0x8c8a

000084fe <.LVL47>:
    84fe:	0e 4c       	mov	r12,	r14	;
    8500:	0e dd       	bis	r13,	r14	;
    8502:	0e 93       	cmp	#0,	r14	;r3 As==00
    8504:	f4 23       	jnz	$-22     	;abs 0x84ee

00008506 <.L19>:
            cnt += ntbl_bitcnt(x);

      return cnt;
}
    8506:	0c 48       	mov	r8,	r12	;
    8508:	0c 5a       	add	r10,	r12	;
    850a:	30 40 f6 8b 	br	#0x8bf6		;

0000850e <init>:
}


void init()
{
     WDTCTL = WDTPW | WDTHOLD; // Stop WDT
    850e:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    8512:	20 01 

00008514 <.Loc.124.1>:
  	 __asm__ __volatile__ ("nop");
    8514:	03 43       	nop			

00008516 <.Loc.125.1>:
     eint();
    8516:	32 d2       	eint			
    8518:	03 43       	nop			

0000851a <.Loc.126.1>:
 	 UART_BAUD = BAUD;                   // Init UART
    851a:	b2 42 82 00 	mov	#8,	&0x0082	;r2 As==11

0000851e <.Loc.127.1>:
     UART_CTL  = UART_EN;
    851e:	d2 43 80 00 	mov.b	#1,	&0x0080	;r3 As==01

00008522 <.Loc.129.1>:
     //Enable QWARK
     QWARK_CTL = QWARK_EN;
    8522:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008526 <.Loc.130.1>:
}
    8526:	30 41       	ret			

00008528 <main>:



int main()
{
    8528:	0a 12       	push	r10		;

0000852a <.LCFI20>:
    852a:	09 12       	push	r9		;

0000852c <.LCFI21>:
    852c:	08 12       	push	r8		;

0000852e <.LCFI22>:
    852e:	07 12       	push	r7		;

00008530 <.LCFI23>:
    8530:	06 12       	push	r6		;

00008532 <.LCFI24>:
    8532:	05 12       	push	r5		;

00008534 <.LCFI25>:
    8534:	04 12       	push	r4		;

00008536 <.LCFI26>:
    8536:	31 80 0e 00 	sub	#14,	r1	;#0x000e

0000853a <.LBB32>:
}


void init()
{
     WDTCTL = WDTPW | WDTHOLD; // Stop WDT
    853a:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    853e:	20 01 

00008540 <.Loc.124.1>:
  	 __asm__ __volatile__ ("nop");
    8540:	03 43       	nop			

00008542 <.Loc.125.1>:
     eint();
    8542:	32 d2       	eint			
    8544:	03 43       	nop			

00008546 <.Loc.126.1>:
 	 UART_BAUD = BAUD;                   // Init UART
    8546:	b2 42 82 00 	mov	#8,	&0x0082	;r2 As==11

0000854a <.Loc.127.1>:
     UART_CTL  = UART_EN;
    854a:	d2 43 80 00 	mov.b	#1,	&0x0080	;r3 As==01

0000854e <.Loc.129.1>:
     //Enable QWARK
     QWARK_CTL = QWARK_EN;
    854e:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008552 <.LBE32>:


int main()
{
	init();
    	ta_wait(9980); //10ms
    8552:	3c 40 fc 26 	mov	#9980,	r12	;#0x26fc
    8556:	b0 12 da 89 	call	#35290		;#0x89da
    855a:	39 40 00 40 	mov	#16384,	r9	;#0x4000
    855e:	34 40 fe 8a 	mov	#35582,	r4	;#0x8afe
    8562:	35 40 2c 8a 	mov	#35372,	r5	;#0x8a2c

00008566 <.L48>:

	/* Iterate through the 7 func statements 0 - 7*/
	/* Each statement executes a different bitcount routine, with a different seed value, a 100 times*/
	while(1){

	LED_CTRL ^= 0x0F;
    8566:	f2 e0 0f 00 	xor.b	#15,	&0x0090	;#0x000f
    856a:	90 00 

0000856c <.Loc.152.1>:

	//Initialize the variables upon every loop

	n_0=0;
    856c:	82 43 16 41 	mov	#0,	&0x4116	;r3 As==00

00008570 <.Loc.153.1>:
	n_1=0;
    8570:	82 43 18 41 	mov	#0,	&0x4118	;r3 As==00

00008574 <.Loc.154.1>:
	n_2=0;
    8574:	82 43 1c 41 	mov	#0,	&0x411c	;r3 As==00

00008578 <.Loc.155.1>:
	n_3=0;
    8578:	82 43 1e 41 	mov	#0,	&0x411e	;r3 As==00

0000857c <.Loc.156.1>:
	n_4=0;
    857c:	82 43 1a 41 	mov	#0,	&0x411a	;r3 As==00

00008580 <.Loc.157.1>:
	n_5=0;
    8580:	82 43 14 41 	mov	#0,	&0x4114	;r3 As==00

00008584 <.Loc.158.1>:
	n_6=0;
    8584:	82 43 12 41 	mov	#0,	&0x4112	;r3 As==00

00008588 <.LBB34>:
      Accu += bits[ *Ptr ];
      return Accu;
}
int ntbl_bitcnt(uint32_t x)
{
      int cnt = bits[(int)(x & 0x0000000FL)];
    8588:	5c 49 04 00 	mov.b	4(r9),	r12	;
    858c:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    8590:	91 43 0a 00 	mov	#1,	10(r1)	;r3 As==01, 0x000a
    8594:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00008598 <.LBE34>:
	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
		if(func == 0){
    8598:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    859c:	3c 24       	jz	$+122    	;abs 0x8616

0000859e <.L27>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_0 += bit_count(seed);
			}
		}
		else if(func == 1){
    859e:	91 93 04 00 	cmp	#1,	4(r1)	;r3 As==01
    85a2:	2c 25       	jz	$+602    	;abs 0x87fc

000085a4 <.Loc.177.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_1 += bitcount(seed);
			}
		}
		else if(func == 2){
    85a4:	a1 93 04 00 	cmp	#2,	4(r1)	;r3 As==10
    85a8:	f5 24       	jz	$+492    	;abs 0x8794

000085aa <.Loc.183.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_2 += ntbl_bitcnt(seed);
			}
		}
		else if(func == 3){
    85aa:	b1 90 03 00 	cmp	#3,	4(r1)	;
    85ae:	04 00 
    85b0:	df 24       	jz	$+448    	;abs 0x8770

000085b2 <.Loc.189.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_3 += ntbl_bitcount(seed);
			}
		}
		else if(func == 4){
    85b2:	a1 92 04 00 	cmp	#4,	4(r1)	;r2 As==10
    85b6:	a9 24       	jz	$+340    	;abs 0x870a

000085b8 <.Loc.195.1>:
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_4 += BW_btbl_bitcount(seed);
			}
		}
		else if(func == 5){
    85b8:	b1 90 05 00 	cmp	#5,	4(r1)	;
    85bc:	04 00 
    85be:	78 24       	jz	$+242    	;abs 0x86b0

000085c0 <.Loc.164.1>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
    85c0:	6e 42       	mov.b	#4,	r14	;r2 As==10
    85c2:	4f 43       	clr.b	r15		;

000085c4 <.L40>:
    85c4:	0c 4e       	mov	r14,	r12	;
    85c6:	0d 4f       	mov	r15,	r13	;
    85c8:	78 40 20 00 	mov.b	#32,	r8	;#0x0020

000085cc <.LBB38>:
}

static int bit_shifter(uint32_t x)
{
  int i, n;
  for (i = n = 0; x && (i < (sizeof(uint32_t) * CHAR_BIT)); ++i, x >>= 1)
    85cc:	47 43       	clr.b	r7		;
    85ce:	30 40 d8 85 	br	#0x85d8		;

000085d2 <.L74>:
    85d2:	38 53       	add	#-1,	r8	;r3 As==11
    85d4:	08 93       	cmp	#0,	r8	;r3 As==00
    85d6:	0a 24       	jz	$+22     	;abs 0x85ec

000085d8 <.L44>:
    n += (int)(x & 1L);
    85d8:	0a 4c       	mov	r12,	r10	;
    85da:	5a f3       	and.b	#1,	r10	;r3 As==01
    85dc:	07 5a       	add	r10,	r7	;

000085de <.Loc.115.1>:
}

static int bit_shifter(uint32_t x)
{
  int i, n;
  for (i = n = 0; x && (i < (sizeof(uint32_t) * CHAR_BIT)); ++i, x >>= 1)
    85de:	12 c3       	clrc			
    85e0:	0d 10       	rrc	r13		;
    85e2:	0c 10       	rrc	r12		;
    85e4:	0a 4c       	mov	r12,	r10	;
    85e6:	0a dd       	bis	r13,	r10	;
    85e8:	0a 93       	cmp	#0,	r10	;r3 As==00
    85ea:	f3 23       	jnz	$-24     	;abs 0x85d2

000085ec <.L42>:
			}
		}
		else if(func == 6){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_6 += bit_shifter(seed);
    85ec:	82 57 12 41 	add	r7,	&0x4112	;

000085f0 <.Loc.202.1>:

				n_5 += AR_btbl_bitcount(seed);
			}
		}
		else if(func == 6){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    85f0:	3e 50 0d 00 	add	#13,	r14	;#0x000d

000085f4 <.LVL61>:
    85f4:	0f 63       	adc	r15		;

000085f6 <.LVL62>:
    85f6:	3e 90 18 05 	cmp	#1304,	r14	;#0x0518
    85fa:	e4 23       	jnz	$-54     	;abs 0x85c4
    85fc:	0f 93       	cmp	#0,	r15	;r3 As==00
    85fe:	e2 23       	jnz	$-58     	;abs 0x85c4

00008600 <.LVL63>:
	n_5=0;
	n_6=0;

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {
    8600:	b1 90 07 00 	cmp	#7,	10(r1)	; 0x000a
    8604:	0a 00 
    8606:	25 24       	jz	$+76     	;abs 0x8652

00008608 <.L47>:
    8608:	91 53 04 00 	inc	4(r1)		;
    860c:	91 53 0a 00 	inc	10(r1)		;

00008610 <.LVL65>:

		seed = (uint32_t)SEED;
		if(func == 0){
    8610:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    8614:	c4 23       	jnz	$-118    	;abs 0x859e

00008616 <.L68>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
    8616:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8618:	4f 43       	clr.b	r15		;

0000861a <.L61>:
    861a:	0c 4e       	mov	r14,	r12	;
    861c:	0d 4f       	mov	r15,	r13	;

0000861e <.LBB40>:
            cnt += btbl_bitcnt(x);
      return cnt;
}
int bit_count(uint32_t x)
{
        int n = 0;
    861e:	47 43       	clr.b	r7		;

00008620 <.L28>:

        if (x) do
              n++;
    8620:	17 53       	inc	r7		;

00008622 <.Loc.54.1>:
        while (0 != (x = x&(x-1))) ;
    8622:	08 4c       	mov	r12,	r8	;
    8624:	38 53       	add	#-1,	r8	;r3 As==11
    8626:	0a 4d       	mov	r13,	r10	;
    8628:	3a 63       	addc	#-1,	r10	;r3 As==11
    862a:	08 fc       	and	r12,	r8	;
    862c:	0a fd       	and	r13,	r10	;
    862e:	0c 48       	mov	r8,	r12	;

00008630 <.LVL69>:
    8630:	0d 4a       	mov	r10,	r13	;

00008632 <.LVL70>:
    8632:	0a 48       	mov	r8,	r10	;

00008634 <.LVL71>:
    8634:	0a dd       	bis	r13,	r10	;
    8636:	0a 93       	cmp	#0,	r10	;r3 As==00
    8638:	f3 23       	jnz	$-24     	;abs 0x8620

0000863a <.LBE40>:

		seed = (uint32_t)SEED;
		if(func == 0){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_0 += bit_count(seed);
    863a:	82 57 16 41 	add	r7,	&0x4116	;

0000863e <.Loc.166.1>:

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
		if(func == 0){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    863e:	3e 50 0d 00 	add	#13,	r14	;#0x000d

00008642 <.LVL73>:
    8642:	0f 63       	adc	r15		;

00008644 <.LVL74>:
    8644:	3e 90 18 05 	cmp	#1304,	r14	;#0x0518
    8648:	e8 23       	jnz	$-46     	;abs 0x861a
    864a:	0f 93       	cmp	#0,	r15	;r3 As==00
    864c:	e6 23       	jnz	$-50     	;abs 0x861a
    864e:	30 40 08 86 	br	#0x8608		;

00008652 <.L75>:
			}
		}
	}

#ifdef UART_DBG
	UART_WriteString("Benchmark Complete! \r\n");
    8652:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    8656:	84 12       	call	r4		;

00008658 <.LVL76>:
	UART_WriteNumber(n_0);
    8658:	1c 42 16 41 	mov	&0x4116,r12	;0x4116
    865c:	85 12       	call	r5		;

0000865e <.Loc.212.1>:
	UART_WriteString("\r\n");
    865e:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    8662:	84 12       	call	r4		;

00008664 <.Loc.213.1>:
	UART_WriteNumber(n_1);
    8664:	1c 42 18 41 	mov	&0x4118,r12	;0x4118
    8668:	85 12       	call	r5		;

0000866a <.Loc.214.1>:
	UART_WriteString("\r\n");
    866a:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    866e:	84 12       	call	r4		;

00008670 <.Loc.215.1>:
	UART_WriteNumber(n_2);
    8670:	1c 42 1c 41 	mov	&0x411c,r12	;0x411c
    8674:	85 12       	call	r5		;

00008676 <.Loc.216.1>:
	UART_WriteString("\r\n");
    8676:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    867a:	84 12       	call	r4		;

0000867c <.Loc.217.1>:
	UART_WriteNumber(n_3);
    867c:	1c 42 1e 41 	mov	&0x411e,r12	;0x411e
    8680:	85 12       	call	r5		;

00008682 <.Loc.218.1>:
	UART_WriteString("\r\n");
    8682:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    8686:	84 12       	call	r4		;

00008688 <.Loc.219.1>:
	UART_WriteNumber(n_4);
    8688:	1c 42 1a 41 	mov	&0x411a,r12	;0x411a
    868c:	85 12       	call	r5		;

0000868e <.Loc.220.1>:
	UART_WriteString("\r\n");
    868e:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    8692:	84 12       	call	r4		;

00008694 <.Loc.221.1>:
	UART_WriteNumber(n_5);
    8694:	1c 42 14 41 	mov	&0x4114,r12	;0x4114
    8698:	85 12       	call	r5		;

0000869a <.Loc.222.1>:
	UART_WriteString("\r\n");
    869a:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    869e:	84 12       	call	r4		;

000086a0 <.Loc.223.1>:
	UART_WriteNumber(n_6);
    86a0:	1c 42 12 41 	mov	&0x4112,r12	;0x4112
    86a4:	85 12       	call	r5		;

000086a6 <.Loc.224.1>:
	UART_WriteString("\r\n");
    86a6:	3c 40 17 80 	mov	#32791,	r12	;#0x8017
    86aa:	84 12       	call	r4		;

000086ac <.Loc.148.1>:

	/* Iterate through the 7 func statements 0 - 7*/
	/* Each statement executes a different bitcount routine, with a different seed value, a 100 times*/
	while(1){

	LED_CTRL ^= 0x0F;
    86ac:	30 40 66 85 	br	#0x8566		;

000086b0 <.L73>:
    86b0:	68 42       	mov.b	#4,	r8	;r2 As==10

000086b2 <.Loc.164.1>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
    86b2:	66 42       	mov.b	#4,	r6	;r2 As==10
    86b4:	47 43       	clr.b	r7		;

000086b6 <.L41>:
int AR_btbl_bitcount(uint32_t x)
{
      unsigned char * Ptr = (unsigned char *) &x ;
      int Accu ;

      Accu  = bits[ *Ptr++ ];
    86b6:	0c 49       	mov	r9,	r12	;
    86b8:	0c 58       	add	r8,	r12	;
    86ba:	6a 4c       	mov.b	@r12,	r10	;

000086bc <.Loc.97.1>:
      Accu += bits[ *Ptr++ ];
    86bc:	0c 46       	mov	r6,	r12	;
    86be:	b0 12 1a 8c 	call	#35866		;#0x8c1a
    86c2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86c6:	0c 59       	add	r9,	r12	;
    86c8:	6c 4c       	mov.b	@r12,	r12	;
    86ca:	0a 5c       	add	r12,	r10	;

000086cc <.Loc.98.1>:
      Accu += bits[ *Ptr++ ];
    86cc:	4c 47       	mov.b	r7,	r12	;
    86ce:	0c 59       	add	r9,	r12	;
    86d0:	6c 4c       	mov.b	@r12,	r12	;
    86d2:	0a 5c       	add	r12,	r10	;

000086d4 <.LBE44>:
			}
		}
		else if(func == 5){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_5 += AR_btbl_bitcount(seed);
    86d4:	91 42 14 41 	mov	&0x4114,6(r1)	;0x4114
    86d8:	06 00 

000086da <.LBB47>:
      int Accu ;

      Accu  = bits[ *Ptr++ ];
      Accu += bits[ *Ptr++ ];
      Accu += bits[ *Ptr++ ];
      Accu += bits[ *Ptr ];
    86da:	0c 47       	mov	r7,	r12	;
    86dc:	b0 12 1a 8c 	call	#35866		;#0x8c1a
    86e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86e4:	0c 59       	add	r9,	r12	;
    86e6:	6c 4c       	mov.b	@r12,	r12	;
    86e8:	0a 5c       	add	r12,	r10	;

000086ea <.LBE47>:
			}
		}
		else if(func == 5){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_5 += AR_btbl_bitcount(seed);
    86ea:	1a 51 06 00 	add	6(r1),	r10	;
    86ee:	82 4a 14 41 	mov	r10,	&0x4114	;

000086f2 <.Loc.196.1>:

				n_4 += BW_btbl_bitcount(seed);
			}
		}
		else if(func == 5){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    86f2:	36 50 0d 00 	add	#13,	r6	;#0x000d

000086f6 <.LVL98>:
    86f6:	07 63       	adc	r7		;

000086f8 <.LVL99>:
    86f8:	4c 48       	mov.b	r8,	r12	;
    86fa:	7c 50 0d 00 	add.b	#13,	r12	;#0x000d
    86fe:	48 4c       	mov.b	r12,	r8	;
    8700:	7c 90 18 00 	cmp.b	#24,	r12	;#0x0018
    8704:	d8 23       	jnz	$-78     	;abs 0x86b6
    8706:	30 40 08 86 	br	#0x8608		;

0000870a <.L72>:
    870a:	66 42       	mov.b	#4,	r6	;r2 As==10

0000870c <.Loc.164.1>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
    870c:	6e 42       	mov.b	#4,	r14	;r2 As==10
    870e:	4f 43       	clr.b	r15		;

00008710 <.L39>:
      {
            unsigned char ch[4];
            long y;
      } U;

      U.y = x;
    8710:	07 4f       	mov	r15,	r7	;

00008712 <.LBE48>:
			}
		}
		else if(func == 4){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_4 += BW_btbl_bitcount(seed);
    8712:	18 42 1a 41 	mov	&0x411a,r8	;0x411a

00008716 <.LBB51>:
            long y;
      } U;

      U.y = x;

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    8716:	0c 49       	mov	r9,	r12	;
    8718:	0c 56       	add	r6,	r12	;
    871a:	6a 4c       	mov.b	@r12,	r10	;
    871c:	0c 4e       	mov	r14,	r12	;
    871e:	81 4e 02 00 	mov	r14,	2(r1)	;
    8722:	81 4f 00 00 	mov	r15,	0(r1)	;
    8726:	b0 12 1a 8c 	call	#35866		;#0x8c1a

0000872a <.LVL103>:
    872a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    872e:	0c 59       	add	r9,	r12	;
    8730:	6c 4c       	mov.b	@r12,	r12	;
    8732:	0a 5c       	add	r12,	r10	;

00008734 <.Loc.89.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    8734:	0c 47       	mov	r7,	r12	;
    8736:	b0 12 1a 8c 	call	#35866		;#0x8c1a
    873a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    873e:	0c 59       	add	r9,	r12	;

00008740 <.Loc.88.1>:
            long y;
      } U;

      U.y = x;

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    8740:	6c 4c       	mov.b	@r12,	r12	;
    8742:	0a 5c       	add	r12,	r10	;

00008744 <.Loc.89.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    8744:	4c 47       	mov.b	r7,	r12	;
    8746:	0c 59       	add	r9,	r12	;
    8748:	6c 4c       	mov.b	@r12,	r12	;
    874a:	0c 5a       	add	r10,	r12	;

0000874c <.LBE51>:
			}
		}
		else if(func == 4){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_4 += BW_btbl_bitcount(seed);
    874c:	0c 58       	add	r8,	r12	;
    874e:	82 4c 1a 41 	mov	r12,	&0x411a	;

00008752 <.Loc.190.1>:

				n_3 += ntbl_bitcount(seed);
			}
		}
		else if(func == 4){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8752:	1e 41 02 00 	mov	2(r1),	r14	;
    8756:	0f 47       	mov	r7,	r15	;
    8758:	3e 50 0d 00 	add	#13,	r14	;#0x000d
    875c:	0f 63       	adc	r15		;

0000875e <.LVL105>:
    875e:	4c 46       	mov.b	r6,	r12	;
    8760:	7c 50 0d 00 	add.b	#13,	r12	;#0x000d
    8764:	46 4c       	mov.b	r12,	r6	;
    8766:	7c 90 18 00 	cmp.b	#24,	r12	;#0x0018
    876a:	d2 23       	jnz	$-90     	;abs 0x8710
    876c:	30 40 08 86 	br	#0x8608		;

00008770 <.L71>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
    8770:	66 42       	mov.b	#4,	r6	;r2 As==10
    8772:	47 43       	clr.b	r7		;

00008774 <.L63>:
			}
		}
		else if(func == 3){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_3 += ntbl_bitcount(seed);
    8774:	0c 46       	mov	r6,	r12	;
    8776:	0d 47       	mov	r7,	r13	;
    8778:	b0 12 ae 83 	call	#33710		;#0x83ae
    877c:	82 5c 1e 41 	add	r12,	&0x411e	;

00008780 <.Loc.184.1>:

				n_2 += ntbl_bitcnt(seed);
			}
		}
		else if(func == 3){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    8780:	36 50 0d 00 	add	#13,	r6	;#0x000d

00008784 <.LVL109>:
    8784:	07 63       	adc	r7		;

00008786 <.LVL110>:
    8786:	36 90 18 05 	cmp	#1304,	r6	;#0x0518
    878a:	f4 23       	jnz	$-22     	;abs 0x8774
    878c:	07 93       	cmp	#0,	r7	;r3 As==00
    878e:	f2 23       	jnz	$-26     	;abs 0x8774
    8790:	30 40 08 86 	br	#0x8608		;

00008794 <.L70>:
      Accu += bits[ *Ptr ];
      return Accu;
}
int ntbl_bitcnt(uint32_t x)
{
      int cnt = bits[(int)(x & 0x0000000FL)];
    8794:	1a 41 0c 00 	mov	12(r1),	r10	;0x0000c

00008798 <.LBE52>:
    8798:	78 40 11 00 	mov.b	#17,	r8	;#0x0011

0000879c <.Loc.164.1>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
    879c:	a1 42 06 00 	mov	#4,	6(r1)	;r2 As==10
    87a0:	81 43 08 00 	mov	#0,	8(r1)	;r3 As==00
    87a4:	47 43       	clr.b	r7		;
    87a6:	0c 4a       	mov	r10,	r12	;
    87a8:	0a 47       	mov	r7,	r10	;
    87aa:	07 4c       	mov	r12,	r7	;

000087ac <.L33>:
			}
		}
		else if(func == 2){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_2 += ntbl_bitcnt(seed);
    87ac:	0e 4a       	mov	r10,	r14	;
    87ae:	0e 57       	add	r7,	r14	;
    87b0:	82 5e 1c 41 	add	r14,	&0x411c	;

000087b4 <.Loc.178.1>:

				n_1 += bitcount(seed);
			}
		}
		else if(func == 2){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    87b4:	b1 50 0d 00 	add	#13,	6(r1)	;#0x000d
    87b8:	06 00 
    87ba:	81 63 08 00 	adc	8(r1)		;

000087be <.LVL113>:
    87be:	38 90 18 05 	cmp	#1304,	r8	;#0x0518
    87c2:	22 27       	jz	$-442    	;abs 0x8608

000087c4 <.LBB53>:
      Accu += bits[ *Ptr ];
      return Accu;
}
int ntbl_bitcnt(uint32_t x)
{
      int cnt = bits[(int)(x & 0x0000000FL)];
    87c4:	0c 48       	mov	r8,	r12	;
    87c6:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    87ca:	0c 59       	add	r9,	r12	;
    87cc:	67 4c       	mov.b	@r12,	r7	;

000087ce <.Loc.106.1>:

      if (0L != (x >>= 4))
    87ce:	1c 41 06 00 	mov	6(r1),	r12	;
    87d2:	1d 41 08 00 	mov	8(r1),	r13	;
    87d6:	b0 12 8a 8c 	call	#35978		;#0x8c8a

000087da <.LVL115>:
    87da:	4a 43       	clr.b	r10		;

000087dc <.L35>:
    87dc:	0a 57       	add	r7,	r10	;

000087de <.Loc.104.1>:
      Accu += bits[ *Ptr ];
      return Accu;
}
int ntbl_bitcnt(uint32_t x)
{
      int cnt = bits[(int)(x & 0x0000000FL)];
    87de:	0e 4c       	mov	r12,	r14	;
    87e0:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    87e4:	0e 59       	add	r9,	r14	;
    87e6:	67 4e       	mov.b	@r14,	r7	;

000087e8 <.Loc.106.1>:

      if (0L != (x >>= 4))
    87e8:	b0 12 8a 8c 	call	#35978		;#0x8c8a

000087ec <.LVL118>:
    87ec:	0e 4c       	mov	r12,	r14	;
    87ee:	0e dd       	bis	r13,	r14	;
    87f0:	0e 93       	cmp	#0,	r14	;r3 As==00
    87f2:	f4 23       	jnz	$-22     	;abs 0x87dc
    87f4:	38 50 0d 00 	add	#13,	r8	;#0x000d
    87f8:	30 40 ac 87 	br	#0x87ac		;

000087fc <.L69>:

	//Toggle LED upon every execution

	for (func = 0; func < 7; func++) {

		seed = (uint32_t)SEED;
    87fc:	66 42       	mov.b	#4,	r6	;r2 As==10
    87fe:	47 43       	clr.b	r7		;

00008800 <.L62>:
			}
		}
		else if(func == 1){
			for(iter = 0; iter < ITER; ++iter, seed += 13){

				n_1 += bitcount(seed);
    8800:	0c 46       	mov	r6,	r12	;
    8802:	0d 47       	mov	r7,	r13	;
    8804:	b0 12 0c 83 	call	#33548		;#0x830c
    8808:	82 5c 18 41 	add	r12,	&0x4118	;

0000880c <.Loc.172.1>:

				n_0 += bit_count(seed);
			}
		}
		else if(func == 1){
			for(iter = 0; iter < ITER; ++iter, seed += 13){
    880c:	36 50 0d 00 	add	#13,	r6	;#0x000d

00008810 <.LVL122>:
    8810:	07 63       	adc	r7		;

00008812 <.LVL123>:
    8812:	36 90 18 05 	cmp	#1304,	r6	;#0x0518
    8816:	f4 23       	jnz	$-22     	;abs 0x8800
    8818:	07 93       	cmp	#0,	r7	;r3 As==00
    881a:	f2 23       	jnz	$-26     	;abs 0x8800
    881c:	30 40 08 86 	br	#0x8608		;

00008820 <INT_Qwark>:
	//---------------------------------------------------------------------------------------------------------------------------------//
	//    CHECKPOINT SETUP: Identify which of the 2 checkpoint buffers should be written, one should always be consistent		   //
	//	  W.C. 18 CYCLES  													   //	 
	//	  B.C. 10 CYCLES 													   //
	//---------------------------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov r13, &0x6070"); 		//temporal r13: 4 cycles
    8820:	82 4d 70 60 	mov	r13,	&0x6070	;

00008824 <.Loc.277.1>:
		__asm__ __volatile__ ("mov r12, &0x6072"); 		//temporal r12: 4 cycles
    8824:	82 4c 72 60 	mov	r12,	&0x6072	;

00008828 <.Loc.279.1>:

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075"); 		//4 cycles
    8828:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

0000882c <.Loc.280.1>:
		__asm__ __volatile__ ("jz __second_buffer_init");	//2 cycles
    882c:	06 24       	jz	$+14     	;abs 0x883a

0000882e <.Loc.282.1>:

		__asm__ __volatile__ ("mov #0x6010, r12"); 		//Load the base pointer of the first checkpoint buffer: 2 cycles
    882e:	3c 40 10 60 	mov	#24592,	r12	;#0x6010

00008832 <.Loc.283.1>:
		__asm__ __volatile__ ("mov.b #0x01,&0x6074");		//4 cycles
    8832:	d2 43 74 60 	mov.b	#1,	&0x6074	;r3 As==01

00008836 <.Loc.284.1>:
		__asm__ __volatile__ ("br #__first_phase_commit");	//2 cycles
    8836:	30 40 3e 88 	br	#0x883e		;

0000883a <__second_buffer_init>:

		__asm__ __volatile__ ("__second_buffer_init:");

		__asm__ __volatile__ ("mov #0x6040, r12"); 		//Load the base pointer of the second checkpoint buffer: 2 cycles
    883a:	3c 40 40 60 	mov	#24640,	r12	;#0x6040

0000883e <__first_phase_commit>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 2(r1),@r12"); 	//PC/R0   6 cycles
    883e:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    8842:	00 00 

00008844 <.Loc.307.1>:
		__asm__ __volatile__ ("incd r12");		//	  1 cycle
    8844:	2c 53       	incd	r12		;

00008846 <.Loc.313.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark  - 3 cycles
		//__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles	

		__asm__ __volatile__ ("mov r1,@r12");   	//SP/R1   4 cycles
    8846:	8c 41 00 00 	mov	r1,	0(r12)	;

0000884a <.Loc.314.1>:
		__asm__ __volatile__ ("add #0x04,@r12");	//	  5 cycles
    884a:	ac 52 00 00 	add	#4,	0(r12)	;r2 As==10

0000884e <.Loc.315.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    884e:	2c 53       	incd	r12		;

00008850 <.Loc.321.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 0(r1),@r12"); 	//SR/R2   6 cycles
    8850:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008854 <.Loc.322.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8854:	2c 53       	incd	r12		;

00008856 <.Loc.324.1>:

		__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark and signal a buffer reset without modifying the data - 3 cycles
    8856:	1d 42 a0 02 	mov	&0x02a0,r13	;0x02a0

0000885a <.Loc.325.1>:
		__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
    885a:	3d f0 3e 00 	and	#62,	r13	;#0x003e

0000885e <.Loc.326.1>:
		__asm__ __volatile__ ("bis #0x40,r13"); 	//	  2 cycles
    885e:	3d d0 40 00 	bis	#64,	r13	;#0x0040

00008862 <.Loc.327.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    8862:	82 4d a0 02 	mov	r13,	&0x02a0	;

00008866 <.Loc.328.1>:
		__asm__ __volatile__ ("and #0xBF,r13"); 	//	  2 cycles
    8866:	3d f0 bf 00 	and	#191,	r13	;#0x00bf

0000886a <.Loc.329.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    886a:	82 4d a0 02 	mov	r13,	&0x02a0	;

0000886e <.Loc.331.1>:

		__asm__ __volatile__ ("mov r4,@r12"); 		//R4	  4 cycles
    886e:	8c 44 00 00 	mov	r4,	0(r12)	;

00008872 <.Loc.332.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8872:	2c 53       	incd	r12		;

00008874 <.Loc.334.1>:

		__asm__ __volatile__ ("mov r5,@r12"); 		//R5	  4 cycles
    8874:	8c 45 00 00 	mov	r5,	0(r12)	;

00008878 <.Loc.335.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    8878:	2c 53       	incd	r12		;

0000887a <.Loc.337.1>:

		__asm__ __volatile__ ("mov r6,@r12"); 		//R6	  4 cycles
    887a:	8c 46 00 00 	mov	r6,	0(r12)	;

0000887e <.Loc.338.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    887e:	2c 53       	incd	r12		;

00008880 <.Loc.340.1>:

		__asm__ __volatile__ ("mov r7,@r12"); 		//R7	  4 cycles
    8880:	8c 47 00 00 	mov	r7,	0(r12)	;

00008884 <.Loc.341.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8884:	2c 53       	incd	r12		;

00008886 <.Loc.343.1>:

		__asm__ __volatile__ ("mov r8,@r12"); 		//R8	  4 cycles
    8886:	8c 48 00 00 	mov	r8,	0(r12)	;

0000888a <.Loc.344.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    888a:	2c 53       	incd	r12		;

0000888c <.Loc.346.1>:

		__asm__ __volatile__ ("mov r9,@r12"); 		//R9	  4 cycles
    888c:	8c 49 00 00 	mov	r9,	0(r12)	;

00008890 <.Loc.347.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8890:	2c 53       	incd	r12		;

00008892 <.Loc.349.1>:

		__asm__ __volatile__ ("mov r10,@r12"); 		//R10	  4 cycles
    8892:	8c 4a 00 00 	mov	r10,	0(r12)	;

00008896 <.Loc.350.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8896:	2c 53       	incd	r12		;

00008898 <.Loc.352.1>:

		__asm__ __volatile__ ("mov r11,@r12"); 		//R11	  4 cycles
    8898:	8c 4b 00 00 	mov	r11,	0(r12)	;

0000889c <.Loc.353.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    889c:	2c 53       	incd	r12		;

0000889e <.Loc.355.1>:

		__asm__ __volatile__ ("mov &0x6072,@r12"); 	//R12	  6 cycles
    889e:	9c 42 72 60 	mov	&0x6072,0(r12)	;0x6072
    88a2:	00 00 

000088a4 <.Loc.356.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    88a4:	2c 53       	incd	r12		;

000088a6 <.Loc.358.1>:

		__asm__ __volatile__ ("mov &0x6070,@r12"); 	//R13	  4 cycles
    88a6:	9c 42 70 60 	mov	&0x6070,0(r12)	;0x6070
    88aa:	00 00 

000088ac <.Loc.359.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    88ac:	2c 53       	incd	r12		;

000088ae <.Loc.361.1>:

		__asm__ __volatile__ ("mov r14,@r12"); 		//R14	  4 cycles
    88ae:	8c 4e 00 00 	mov	r14,	0(r12)	;

000088b2 <.Loc.362.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    88b2:	2c 53       	incd	r12		;

000088b4 <.Loc.364.1>:

		__asm__ __volatile__ ("mov r15,@r12"); 		//R15	  4 cycles
    88b4:	8c 4f 00 00 	mov	r15,	0(r12)	;

000088b8 <.Loc.365.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    88b8:	2c 53       	incd	r12		;

000088ba <.Loc.373.1>:
		//    WAR VIOLATION INDEX CHECKPOINT: Get the index indicating the amount of violations stored 				   //
		//	  10 CYCLES																								   //
		//																											   //
		//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("mov &0x02A0, r14");	// 		  3 cycles
    88ba:	1e 42 a0 02 	mov	&0x02a0,r14	;0x02a0

000088be <.Loc.374.1>:
		__asm__ __volatile__ ("RRA r14");			// 		  1 cycle
    88be:	0e 11       	rra	r14		;

000088c0 <.Loc.375.1>:
		__asm__ __volatile__ ("mov.b r14, @r12");	// 		  4 cycles
    88c0:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

000088c4 <.Loc.376.1>:
		__asm__ __volatile__ ("mov r14, r15 ");		// 		  1 cycle (save the index for later)
    88c4:	0f 4e       	mov	r14,	r15	;

000088c6 <.Loc.377.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 Cycle
    88c6:	2c 53       	incd	r12		;

000088c8 <.Loc.387.1>:
		//	  B.C.	 5 CYCLES FOR EMPTY TLB																			   //
		//-------------------------------------------------------------------------------------------------------------//

		/* Setup registers for copy*/

		__asm__ __volatile__ ("tst r14 ");     	    // 		  1 cycle
    88c8:	0e 93       	cmp	#0,	r14	;r3 As==00

000088ca <.Loc.388.1>:
		__asm__ __volatile__ ("jz  __second_phase_start");	// 		  2 cycles
    88ca:	08 24       	jz	$+18     	;abs 0x88dc

000088cc <.Loc.390.1>:

		__asm__ __volatile__ ("mov #0x02A2, r13");	// 		  2 cycles
    88cc:	3d 40 a2 02 	mov	#674,	r13	;#0x02a2

000088d0 <_scratchpad_addr_cpy>:

		__asm__ __volatile__ ("_scratchpad_addr_cpy:");   // Each iteration takes 10 cycles - Worst case 70 cycles

		__asm__ __volatile__ ("mov @r13+2, @r12");  // 		  5 cycles
    88d0:	bc 4d 00 00 	mov	@r13+,	0(r12)	;

000088d4 <.Loc.395.1>:
		__asm__ __volatile__ ("incd r12");  		// 		  1 cycle
    88d4:	2c 53       	incd	r12		;

000088d6 <.Loc.396.1>:
		__asm__ __volatile__ ("dec r14 ");      	// 		  1 cycle
    88d6:	1e 83       	dec	r14		;

000088d8 <.Loc.397.1>:
		__asm__ __volatile__ ("tst r14 ");     		// 		  1 cycle
    88d8:	0e 93       	cmp	#0,	r14	;r3 As==00

000088da <.Loc.398.1>:
		__asm__ __volatile__ ("jnz  _scratchpad_addr_cpy");// 2 cycles
    88da:	fa 23       	jnz	$-10     	;abs 0x88d0

000088dc <__second_phase_start>:
	//    END OF THE FIRST PHASE: Atomic Flag Handling for halfway through checkpoint							   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("__second_phase_start:");

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075");		 // 4 cycles
    88dc:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

000088e0 <.Loc.446.1>:
		__asm__ __volatile__ ("jz  __set_flag_2nd ");		 // 2 cycles
    88e0:	04 24       	jz	$+10     	;abs 0x88ea

000088e2 <.Loc.448.1>:

		__asm__ __volatile__ ("add.b #0x01, &0x6074 "); 	 //4 cycles
    88e2:	d2 53 74 60 	inc.b	&0x6074		;

000088e6 <.Loc.449.1>:
		__asm__ __volatile__ ("br  #_second_phase_commit "); //4 cycles
    88e6:	30 40 ee 88 	br	#0x88ee		;

000088ea <__set_flag_2nd>:

		__asm__ __volatile__ ("__set_flag_2nd:");
		__asm__ __volatile__ ("add.b #0x01, &0x6075 "); 	 // 4 cycles		/* after setting this bit, THE RESTORE ROUTINE CAN FINALIZE THIS HALFWAY CHECKPOINT  */
    88ea:	d2 53 75 60 	inc.b	&0x6075		;

000088ee <_second_phase_commit>:
	//	  ASSUMMING ONLY WORD ADDRESSING. 																		   //
	//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("_second_phase_commit:");

		__asm__ __volatile__ ("tst r15 ");     		         // 1 cycle
    88ee:	0f 93       	cmp	#0,	r15	;r3 As==00

000088f0 <.Loc.463.1>:
		__asm__ __volatile__ ("jz  _chkpt_finished");		 // 2 cycles
    88f0:	25 24       	jz	$+76     	;abs 0x893c

000088f2 <.Loc.465.1>:

		__asm__ __volatile__ ("mov #0x6000,  r14 ");		 // 2 cycles
    88f2:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

000088f6 <.Loc.467.1>:

		__asm__ __volatile__ ("mov #0x6060,  r12 ");		 // 2 cycles
    88f6:	3c 40 60 60 	mov	#24672,	r12	;#0x6060

000088fa <.Loc.468.1>:
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");		 // 4 cycles
    88fa:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

000088fe <.Loc.469.1>:
		__asm__ __volatile__ ("jz _second_phase_commit_strt");   // 2 cycles
    88fe:	02 24       	jz	$+6      	;abs 0x8904

00008900 <.Loc.471.1>:

		__asm__ __volatile__ ("mov #0x6030,  r12 ");		 // 2 cycles
    8900:	3c 40 30 60 	mov	#24624,	r12	;#0x6030

00008904 <_second_phase_commit_strt>:


		__asm__ __volatile__ ("_second_phase_commit_strt:"); 	 // Worst case

		__asm__ __volatile__ ("mov @r12+2,  r13 ");   		 // 3 cycles
    8904:	3d 4c       	mov	@r12+,	r13	;

00008906 <.Loc.478.1>:

		__asm__ __volatile__ ("mov r13,  r11 ");   		 // 1 cycle
    8906:	0b 4d       	mov	r13,	r11	;

00008908 <.Loc.480.1>:

		__asm__ __volatile__ ("and #0x8000,  r11 ");   		 // 2 cycles
    8908:	3b f0 00 80 	and	#32768,	r11	;#0x8000

0000890c <.Loc.481.1>:
		__asm__ __volatile__ ("cmp #0x8000,  r11 ");   		 // 2 cycles
    890c:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

00008910 <.Loc.482.1>:
		__asm__ __volatile__ ("jeq _byte_copy ");   		 // 2 cycles
    8910:	08 24       	jz	$+18     	;abs 0x8922

00008912 <.Loc.493.1>:
	
		//__asm__ __volatile__ ("incd r10 	  ");    	 // 1 cycle
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		 // 1 cycle - verify that the redirected value corresponds to the current PC return value
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	 // 2 cycles
  
		__asm__ __volatile__ ("mov @r14, @r13 ");    		 // 5 cycles
    8912:	ad 4e 00 00 	mov	@r14,	0(r13)	;

00008916 <_pre_end_copy>:

		__asm__ __volatile__ ("_pre_end_copy:");
		__asm__ __volatile__ ("incd r14");    			 // 1 cycle
    8916:	2e 53       	incd	r14		;

00008918 <.Loc.497.1>:
		__asm__ __volatile__ ("dec r15");    			 // 1 cycle
    8918:	1f 83       	dec	r15		;

0000891a <.Loc.498.1>:
		__asm__ __volatile__ ("tst r15");    			 // 1 cycle
    891a:	0f 93       	cmp	#0,	r15	;r3 As==00

0000891c <.Loc.500.1>:

		__asm__ __volatile__ ("jnz  _second_phase_commit_strt"); // 2 cycles
    891c:	f3 23       	jnz	$-24     	;abs 0x8904

0000891e <.Loc.501.1>:
		__asm__ __volatile__ ("br #_chkpt_finished");		 // 2 cycles
    891e:	30 40 3c 89 	br	#0x893c		;

00008922 <_byte_copy>:

		__asm__ __volatile__ ("_byte_copy:");
		__asm__ __volatile__ ("and #0x7FFF,  r13 ");   		// mask the highest bit - 2 cycles
    8922:	3d f0 ff 7f 	and	#32767,	r13	;#0x7fff

00008926 <.Loc.505.1>:
		__asm__ __volatile__ ("mov r13,      r11 ");   		// 1 cycle
    8926:	0b 4d       	mov	r13,	r11	;

00008928 <.Loc.506.1>:
		__asm__ __volatile__ ("and #0x01,    r11 ");   		// detect if its a byte write - 1 cycle
    8928:	1b f3       	and	#1,	r11	;r3 As==01

0000892a <.Loc.507.1>:
		__asm__ __volatile__ ("bis  r11,     r14 ");   		// detect if its a byte write - 1 cycle
    892a:	0e db       	bis	r11,	r14	;

0000892c <.Loc.519.1>:
		//__asm__ __volatile__ ("incd r10 	  ");    	// 1 cycle							
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		// 1 cycle - verify that the PC will not be overwritten by a previous violation (Discard it)
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	// 2 cycles


		__asm__ __volatile__ ("mov.b @r14, @r13 ");    				// 5 cycles
    892c:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00008930 <.Loc.521.1>:

		__asm__ __volatile__ ("and #0xFFFE, r14");    				// 2 cycles
    8930:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

00008934 <.Loc.522.1>:
		__asm__ __volatile__ ("incd r14");    				 		// 1 cycle
    8934:	2e 53       	incd	r14		;

00008936 <.Loc.523.1>:
		__asm__ __volatile__ ("dec r15");    						// 1 cycles
    8936:	1f 83       	dec	r15		;

00008938 <.Loc.524.1>:
		__asm__ __volatile__ ("tst r15");    						// 1 cycles
    8938:	0f 93       	cmp	#0,	r15	;r3 As==00

0000893a <.Loc.525.1>:
		__asm__ __volatile__ ("jnz  _second_phase_commit_strt");	// 2 cycles
    893a:	e4 23       	jnz	$-54     	;abs 0x8904

0000893c <_chkpt_finished>:
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("_chkpt_finished:");


	    /* Set second phase complete Bit - Atomic Flag*/
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");			//4 cycles
    893c:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008940 <.Loc.536.1>:
		__asm__ __volatile__ ("jeq  __pre_finish_2nd_buffer "); //2 cycles
    8940:	11 24       	jz	$+36     	;abs 0x8964

00008942 <.Loc.538.1>:

		__asm__ __volatile__ ("mov #0x0103, &0x6074 "); //5 cycles	/* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 1ST CHECKPOINT COMPLETELY  */
    8942:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    8946:	74 60 

00008948 <.Loc.544.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//																											   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6022,r10"); 		//3 cycles
    8948:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

0000894c <.Loc.545.1>:
		__asm__ __volatile__ ("mov &0x6024,r11"); 		//3 cycles
    894c:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

00008950 <.Loc.546.1>:
		__asm__ __volatile__ ("mov &0x6026,r12"); 		//3 cycles
    8950:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

00008954 <.Loc.547.1>:
		__asm__ __volatile__ ("mov &0x6028,r13"); 	    //3 cycles
    8954:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00008958 <.Loc.548.1>:
		__asm__ __volatile__ ("mov &0x602A,r14"); 	    //3 cycles
    8958:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

0000895c <.Loc.549.1>:
		__asm__ __volatile__ ("mov &0x602C,r15"); 	    //3 cycles
    895c:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

00008960 <.Loc.551.1>:

		__asm__ __volatile__ ("br #_finish"); 	   		//3 cycles
    8960:	30 40 82 89 	br	#0x8982		;

00008964 <__pre_finish_2nd_buffer>:

		__asm__ __volatile__ ("__pre_finish_2nd_buffer:");

		__asm__ __volatile__ ("mov #0x0301, &0x6074 "); //4 cycles /* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 2ND CHECKPOINT COMPLETELY  */
    8964:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    8968:	74 60 

0000896a <.Loc.560.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6052,r10"); 	    //3 cycles		
    896a:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

0000896e <.Loc.561.1>:
		__asm__ __volatile__ ("mov &0x6054,r11"); 	    //3 cycles
    896e:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

00008972 <.Loc.562.1>:
		__asm__ __volatile__ ("mov &0x6056,r12"); 	    //3 cycles
    8972:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

00008976 <.Loc.563.1>:
		__asm__ __volatile__ ("mov &0x6058,r13"); 	    //3 cycles
    8976:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

0000897a <.Loc.564.1>:
		__asm__ __volatile__ ("mov &0x605A,r14"); 	    //3 cycles
    897a:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

0000897e <.Loc.565.1>:
		__asm__ __volatile__ ("mov &0x605C,r15"); 	    //3 cycles
    897e:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

00008982 <_finish>:

		__asm__ __volatile__ ("_finish:");
		/* Clear the counters, and re-enable Idempotency tracking*/
		__asm__ __volatile__ ("mov #0x0000, &0x6000");	//4 cycles
    8982:	82 43 00 60 	mov	#0,	&0x6000	;r3 As==00

00008986 <.Loc.570.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6002");	//4 cycles
    8986:	82 43 02 60 	mov	#0,	&0x6002	;r3 As==00

0000898a <.Loc.571.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6004");	//4 cycles
    898a:	82 43 04 60 	mov	#0,	&0x6004	;r3 As==00

0000898e <.Loc.572.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6006");	//4 cycles
    898e:	82 43 06 60 	mov	#0,	&0x6006	;r3 As==00

00008992 <.Loc.573.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6008");	//4 cycles
    8992:	82 43 08 60 	mov	#0,	&0x6008	;r3 As==00

00008996 <.Loc.574.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600A");	//4 cycles
    8996:	82 43 0a 60 	mov	#0,	&0x600a	;r3 As==00

0000899a <.Loc.575.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600C");	//4 cycles
    899a:	82 43 0c 60 	mov	#0,	&0x600c	;r3 As==00

0000899e <.Loc.576.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600E");	//4 cycles
    899e:	82 43 0e 60 	mov	#0,	&0x600e	;r3 As==00

000089a2 <.Loc.578.1>:

		__asm__ __volatile__ ("mov #0x0000, &0x02A2");	//4 cycles
    89a2:	82 43 a2 02 	mov	#0,	&0x02a2	;r3 As==00

000089a6 <.Loc.579.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A4");	//4 cycles
    89a6:	82 43 a4 02 	mov	#0,	&0x02a4	;r3 As==00

000089aa <.Loc.580.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A6");	//4 cycles
    89aa:	82 43 a6 02 	mov	#0,	&0x02a6	;r3 As==00

000089ae <.Loc.581.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A8");	//4 cycles
    89ae:	82 43 a8 02 	mov	#0,	&0x02a8	;r3 As==00

000089b2 <.Loc.582.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AA");	//4 cycles
    89b2:	82 43 aa 02 	mov	#0,	&0x02aa	;r3 As==00

000089b6 <.Loc.583.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AC");	//4 cycles
    89b6:	82 43 ac 02 	mov	#0,	&0x02ac	;r3 As==00

000089ba <.Loc.584.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AE");	//4 cycles
    89ba:	82 43 ae 02 	mov	#0,	&0x02ae	;r3 As==00

000089be <.Loc.585.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02B0");	//4 cycles
    89be:	82 43 b0 02 	mov	#0,	&0x02b0	;r3 As==00

000089c2 <.Loc.591.1>:

		//Test software to measure the amount of checkpoints

		//__asm__ __volatile__ ("add #0x01, &0x6076");	//4 cycles

		__asm__ __volatile__ ("mov #0x0001, &0x02A0");	//4 cycles
    89c2:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

000089c6 <.Loc.595.1>:



}
    89c6:	00 13       	reti			

000089c8 <ta_wait_no_lpm>:
//                                                   //
//---------------------------------------------------//
void ta_wait_no_lpm(unsigned int time_cnt) {

  // Start and re-initialize TimerA
  TACTL = TASSEL0 | TACLR | MC_2;
    89c8:	b2 40 24 01 	mov	#292,	&0x0160	;#0x0124
    89cc:	60 01 

000089ce <.Loc.17.1>:

  // Wait until time is over
  while(TAR < time_cnt);
    89ce:	3e 40 70 01 	mov	#368,	r14	;#0x0170

000089d2 <.L2>:
    89d2:	2d 4e       	mov	@r14,	r13	;
    89d4:	0d 9c       	cmp	r12,	r13	;
    89d6:	fd 2b       	jnc	$-4      	;abs 0x89d2

000089d8 <.Loc.19.1>:

}
    89d8:	30 41       	ret			

000089da <ta_wait>:
//--------------------------------------------------//
unsigned int periodic_val;
void ta_wait(unsigned int time_cnt) {

  // Set time limit for IRQ generation
  TACCR0 = time_cnt;
    89da:	82 4c 72 01 	mov	r12,	&0x0172	;

000089de <.Loc.32.1>:
  periodic_val = time_cnt;
    89de:	82 4c 20 41 	mov	r12,	&0x4120	;

000089e2 <.Loc.34.1>:
  // Start and re-initialize TimerA
  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    89e2:	b2 40 16 02 	mov	#534,	&0x0160	;#0x0216
    89e6:	60 01 

000089e8 <.Loc.39.1>:

  // Go to Low-Power-Mode 0
  //LPM0;

}
    89e8:	30 41       	ret			

000089ea <INT_timerA1>:

//--------------------------------------------------//
//    TIMER A INTERRUPT                             //
//--------------------------------------------------//
wakeup interrupt (TIMERA1_VECTOR) INT_timerA1(void) {
    89ea:	0c 12       	push	r12		;

000089ec <.LCFI0>:


      //Force Reset
	 // WDTCTL = 0;
	  TACTL = TAIFG;
    89ec:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    89f0:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

000089f4 <.Loc.52.1>:
	  //LED_CTRL ^= 0x0F;
	  // Set time limit for IRQ generation
	  TACCR0 = periodic_val;
    89f4:	92 42 20 41 	mov	&0x4120,&0x0172	;0x4120
    89f8:	72 01 

000089fa <.Loc.55.1>:

	  // Start and re-initialize TimerA
	  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    89fa:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    89fe:	00 00 

00008a00 <.Loc.57.1>:

	  QWARK_CHECKPOINT();
    8a00:	b2 d0 20 00 	bis	#32,	&0x02a0	;#0x0020
    8a04:	a0 02 

00008a06 <.Loc.60.1>:


}
    8a06:	b1 c0 f0 00 	bic	#240,	2(r1)	;#0x00f0
    8a0a:	02 00 
    8a0c:	3c 41       	pop	r12		;
    8a0e:	00 13       	reti			

00008a10 <UART_WriteChar>:

//--------------------------------------------------//
//                 tty_putc function                 //
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {
    8a10:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008a14 <.Loc.19.1>:

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    8a14:	7d 40 81 00 	mov.b	#129,	r13	;#0x0081

00008a18 <.L2>:
    8a18:	fd b2 00 00 	bit.b	#8,	0(r13)	;r2 As==11
    8a1c:	fd 23       	jnz	$-4      	;abs 0x8a18

00008a1e <.Loc.20.1>:
  LED_CTRL = 0xEE;
    8a1e:	f2 40 ee ff 	mov.b	#65518,	&0x0090	;#0xffee
    8a22:	90 00 

00008a24 <.Loc.22.1>:
  // Write the output character
  UART_TXD = txdata;
    8a24:	c2 4c 84 00 	mov.b	r12,	&0x0084	;

00008a28 <.Loc.25.1>:

  return 0;
}
    8a28:	4c 43       	clr.b	r12		;

00008a2a <.LVL1>:
    8a2a:	30 41       	ret			

00008a2c <UART_WriteNumber>:


void UART_WriteNumber (int n)
{
    8a2c:	0a 12       	push	r10		;

00008a2e <.LCFI0>:
    8a2e:	09 12       	push	r9		;

00008a30 <.LCFI1>:
    8a30:	08 12       	push	r8		;

00008a32 <.LCFI2>:
    8a32:	07 12       	push	r7		;

00008a34 <.LCFI3>:
    8a34:	06 12       	push	r6		;

00008a36 <.LCFI4>:
    8a36:	05 12       	push	r5		;

00008a38 <.LCFI5>:
    8a38:	04 12       	push	r4		;

00008a3a <.LCFI6>:
    8a3a:	31 80 16 00 	sub	#22,	r1	;#0x0016

00008a3e <.LCFI7>:
    8a3e:	0a 4c       	mov	r12,	r10	;

00008a40 <.Loc.32.1>:
  char buf[20];
  int i = 0;
  if (n < 0)
    8a40:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a42:	43 38       	jl	$+136    	;abs 0x8aca

00008a44 <.Loc.37.1>:
    {
	  UART_WriteChar ('-');
      n = -n;
    }
  while (n > 9)
    8a44:	7c 40 09 00 	mov.b	#9,	r12	;

00008a48 <.LVL4>:
    8a48:	0c 9a       	cmp	r10,	r12	;
    8a4a:	51 34       	jge	$+164    	;abs 0x8aee

00008a4c <.L18>:
    8a4c:	0c 41       	mov	r1,	r12	;
    8a4e:	2c 53       	incd	r12		;
    8a50:	81 4c 00 00 	mov	r12,	0(r1)	;
    8a54:	09 4c       	mov	r12,	r9	;
    8a56:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8a58:	0c 89       	sub	r9,	r12	;
    8a5a:	04 4c       	mov	r12,	r4	;
    8a5c:	35 40 bc 8b 	mov	#35772,	r5	;#0x8bbc
    8a60:	36 40 70 8b 	mov	#35696,	r6	;#0x8b70

00008a64 <.Loc.39.1>:
    {
      buf[i++] = (n%10) + '0';
    8a64:	78 40 0a 00 	mov.b	#10,	r8	;#0x000a

00008a68 <.L9>:
    8a68:	07 44       	mov	r4,	r7	;
    8a6a:	07 59       	add	r9,	r7	;

00008a6c <.LVL6>:
    8a6c:	0d 48       	mov	r8,	r13	;
    8a6e:	0c 4a       	mov	r10,	r12	;
    8a70:	85 12       	call	r5		;
    8a72:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    8a76:	c9 4c 00 00 	mov.b	r12,	0(r9)	;

00008a7a <.Loc.40.1>:
      n /= 10;
    8a7a:	0d 48       	mov	r8,	r13	;
    8a7c:	0c 4a       	mov	r10,	r12	;
    8a7e:	86 12       	call	r6		;
    8a80:	0a 4c       	mov	r12,	r10	;
    8a82:	19 53       	inc	r9		;

00008a84 <.Loc.37.1>:
  if (n < 0)
    {
	  UART_WriteChar ('-');
      n = -n;
    }
  while (n > 9)
    8a84:	7c 40 09 00 	mov.b	#9,	r12	;
    8a88:	0c 9a       	cmp	r10,	r12	;
    8a8a:	ee 3b       	jl	$-34     	;abs 0x8a68
    8a8c:	0d 47       	mov	r7,	r13	;
    8a8e:	1d 53       	inc	r13		;

00008a90 <.L8>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
    8a90:	27 51       	add	@r1,	r7	;
    8a92:	7a 50 30 00 	add.b	#48,	r10	;#0x0030

00008a96 <.LVL12>:
    8a96:	c7 4a 00 00 	mov.b	r10,	0(r7)	;
    8a9a:	3d 53       	add	#-1,	r13	;r3 As==11
    8a9c:	2d 51       	add	@r1,	r13	;
    8a9e:	0a 41       	mov	r1,	r10	;
    8aa0:	1a 53       	inc	r10		;

00008aa2 <.LBB8>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    8aa2:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

00008aa6 <.Loc.22.1>:
  LED_CTRL = 0xEE;
  // Write the output character
  UART_TXD = txdata;
    8aa6:	7f 40 84 00 	mov.b	#132,	r15	;#0x0084

00008aaa <.L11>:
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
  while (i > 0)
	  UART_WriteChar (buf[--i]);
    8aaa:	6e 4d       	mov.b	@r13,	r14	;

00008aac <.L10>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    8aac:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    8ab0:	fd 23       	jnz	$-4      	;abs 0x8aac

00008ab2 <.Loc.20.1>:
  LED_CTRL = 0xEE;
    8ab2:	f2 40 ee ff 	mov.b	#65518,	&0x0090	;#0xffee
    8ab6:	90 00 

00008ab8 <.LVL15>:
  // Write the output character
  UART_TXD = txdata;
    8ab8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;
    8abc:	3d 53       	add	#-1,	r13	;r3 As==11

00008abe <.LBE11>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
  while (i > 0)
    8abe:	0a 9d       	cmp	r13,	r10	;
    8ac0:	f4 23       	jnz	$-22     	;abs 0x8aaa

00008ac2 <.Loc.45.1>:
	  UART_WriteChar (buf[--i]);
}
    8ac2:	31 50 16 00 	add	#22,	r1	;#0x0016
    8ac6:	30 40 ee 8b 	br	#0x8bee		;

00008aca <.L17>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    8aca:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

00008ace <.L7>:
    8ace:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    8ad2:	fd 23       	jnz	$-4      	;abs 0x8ace

00008ad4 <.Loc.20.1>:
  LED_CTRL = 0xEE;
    8ad4:	f2 40 ee ff 	mov.b	#65518,	&0x0090	;#0xffee
    8ad8:	90 00 

00008ada <.Loc.22.1>:
  // Write the output character
  UART_TXD = txdata;
    8ada:	f2 40 2d 00 	mov.b	#45,	&0x0084	;#0x002d
    8ade:	84 00 

00008ae0 <.LBE12>:
  char buf[20];
  int i = 0;
  if (n < 0)
    {
	  UART_WriteChar ('-');
      n = -n;
    8ae0:	4c 43       	clr.b	r12		;
    8ae2:	0c 8a       	sub	r10,	r12	;
    8ae4:	0a 4c       	mov	r12,	r10	;

00008ae6 <.Loc.37.1>:
    }
  while (n > 9)
    8ae6:	7c 40 09 00 	mov.b	#9,	r12	;
    8aea:	0c 9a       	cmp	r10,	r12	;
    8aec:	af 3b       	jl	$-160    	;abs 0x8a4c

00008aee <.L12>:
    8aee:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8af0:	47 43       	clr.b	r7		;
    8af2:	0c 41       	mov	r1,	r12	;
    8af4:	2c 53       	incd	r12		;
    8af6:	81 4c 00 00 	mov	r12,	0(r1)	;
    8afa:	30 40 90 8a 	br	#0x8a90		;

00008afe <UART_WriteString>:
void UART_WriteString(char* string){

    char i = 0;

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    8afe:	6f 4c       	mov.b	@r12,	r15	;
    8b00:	0f 93       	cmp	#0,	r15	;r3 As==00
    8b02:	15 24       	jz	$+44     	;abs 0x8b2e

00008b04 <.Loc.54.1>:
/* Parameter(s)                                                                                     */
/* string      string of characters that will be printed through the UART                           */

void UART_WriteString(char* string){

    char i = 0;
    8b04:	4e 43       	clr.b	r14		;

00008b06 <.LBB14>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    8b06:	7d 40 81 00 	mov.b	#129,	r13	;#0x0081

00008b0a <.Loc.22.1>:
  LED_CTRL = 0xEE;
  // Write the output character
  UART_TXD = txdata;
    8b0a:	7b 40 84 00 	mov.b	#132,	r11	;#0x0084

00008b0e <.L22>:

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);
    8b0e:	5e 53       	inc.b	r14		;

00008b10 <.LVL22>:
    8b10:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00008b14 <.L21>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    8b14:	fd b2 00 00 	bit.b	#8,	0(r13)	;r2 As==11
    8b18:	fd 23       	jnz	$-4      	;abs 0x8b14

00008b1a <.Loc.20.1>:
  LED_CTRL = 0xEE;
    8b1a:	f2 40 ee ff 	mov.b	#65518,	&0x0090	;#0xffee
    8b1e:	90 00 

00008b20 <.Loc.22.1>:
  // Write the output character
  UART_TXD = txdata;
    8b20:	cb 4f 00 00 	mov.b	r15,	0(r11)	;

00008b24 <.LBE17>:
void UART_WriteString(char* string){

    char i = 0;

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    8b24:	0f 4c       	mov	r12,	r15	;

00008b26 <.LVL24>:
    8b26:	0f 5e       	add	r14,	r15	;
    8b28:	6f 4f       	mov.b	@r15,	r15	;
    8b2a:	0f 93       	cmp	#0,	r15	;r3 As==00
    8b2c:	f0 23       	jnz	$-30     	;abs 0x8b0e

00008b2e <.L19>:
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);

    }
 }
    8b2e:	30 41       	ret			

00008b30 <udivmodhi4>:
    8b30:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011

00008b34 <.Loc.35.1>:
    8b34:	5b 43       	mov.b	#1,	r11	;r3 As==01

00008b36 <.L2>:
    8b36:	0d 9c       	cmp	r12,	r13	;
    8b38:	08 28       	jnc	$+18     	;abs 0x8b4a

00008b3a <.L15>:
    8b3a:	4f 43       	clr.b	r15		;

00008b3c <.L4>:
    8b3c:	0b 93       	cmp	#0,	r11	;r3 As==00
    8b3e:	0e 20       	jnz	$+30     	;abs 0x8b5c

00008b40 <.L5>:
    8b40:	0e 93       	cmp	#0,	r14	;r3 As==00
    8b42:	01 24       	jz	$+4      	;abs 0x8b46
    8b44:	0f 4c       	mov	r12,	r15	;

00008b46 <.L1>:
    8b46:	0c 4f       	mov	r15,	r12	;
    8b48:	30 41       	ret			

00008b4a <.L3>:
    8b4a:	3f 53       	add	#-1,	r15	;r3 As==11

00008b4c <.Loc.38.1>:
    8b4c:	0f 93       	cmp	#0,	r15	;r3 As==00
    8b4e:	f8 27       	jz	$-14     	;abs 0x8b40

00008b50 <.Loc.38.1>:
    8b50:	0d 93       	cmp	#0,	r13	;r3 As==00
    8b52:	f3 3b       	jl	$-24     	;abs 0x8b3a

00008b54 <.Loc.40.1>:
    8b54:	0d 5d       	rla	r13		;

00008b56 <.Loc.41.1>:
    8b56:	0b 5b       	rla	r11		;
    8b58:	30 40 36 8b 	br	#0x8b36		;

00008b5c <.L9>:
    8b5c:	0c 9d       	cmp	r13,	r12	;
    8b5e:	02 28       	jnc	$+6      	;abs 0x8b64

00008b60 <.Loc.47.1>:
    8b60:	0c 8d       	sub	r13,	r12	;

00008b62 <.Loc.48.1>:
    8b62:	0f db       	bis	r11,	r15	;

00008b64 <.L8>:
    8b64:	12 c3       	clrc			
    8b66:	0b 10       	rrc	r11		;

00008b68 <.Loc.51.1>:
    8b68:	12 c3       	clrc			
    8b6a:	0d 10       	rrc	r13		;
    8b6c:	30 40 3c 8b 	br	#0x8b3c		;

00008b70 <__mspabi_divi>:
    8b70:	0a 12       	push	r10		;

00008b72 <.LCFI0>:
    8b72:	0f 4c       	mov	r12,	r15	;
    8b74:	0e 4d       	mov	r13,	r14	;

00008b76 <.LVL14>:
    8b76:	3b 40 30 8b 	mov	#35632,	r11	;#0x8b30

00008b7a <.Loc.64.1>:
    8b7a:	0c 93       	cmp	#0,	r12	;r3 As==00
    8b7c:	1a 34       	jge	$+54     	;abs 0x8bb2

00008b7e <.Loc.66.1>:
    8b7e:	4c 43       	clr.b	r12		;

00008b80 <.LVL15>:
    8b80:	0c 8f       	sub	r15,	r12	;
    8b82:	0f 4c       	mov	r12,	r15	;

00008b84 <.LVL16>:
    8b84:	0d 93       	cmp	#0,	r13	;r3 As==00
    8b86:	0d 34       	jge	$+28     	;abs 0x8ba2

00008b88 <.Loc.67.1>:
    8b88:	5a 43       	mov.b	#1,	r10	;r3 As==01

00008b8a <.L21>:
    8b8a:	0d 43       	clr	r13		;
    8b8c:	0d 8e       	sub	r14,	r13	;

00008b8e <.LVL18>:
    8b8e:	4e 43       	clr.b	r14		;

00008b90 <.LVL19>:
    8b90:	0c 4f       	mov	r15,	r12	;

00008b92 <.LVL20>:
    8b92:	8b 12       	call	r11		;

00008b94 <.LVL21>:
    8b94:	1a 93       	cmp	#1,	r10	;r3 As==01
    8b96:	03 24       	jz	$+8      	;abs 0x8b9e

00008b98 <.L20>:
    8b98:	4d 43       	clr.b	r13		;
    8b9a:	0d 8c       	sub	r12,	r13	;
    8b9c:	0c 4d       	mov	r13,	r12	;

00008b9e <.L16>:
    8b9e:	3a 41       	pop	r10		;
    8ba0:	30 41       	ret			

00008ba2 <.L18>:
    8ba2:	4e 43       	clr.b	r14		;
    8ba4:	8b 12       	call	r11		;

00008ba6 <.LVL25>:
    8ba6:	30 40 98 8b 	br	#0x8b98		;

00008baa <.L27>:
    8baa:	4e 43       	clr.b	r14		;
    8bac:	8b 12       	call	r11		;

00008bae <.LVL27>:
    8bae:	30 40 9e 8b 	br	#0x8b9e		;

00008bb2 <.L17>:
    8bb2:	0d 93       	cmp	#0,	r13	;r3 As==00
    8bb4:	fa 37       	jge	$-10     	;abs 0x8baa

00008bb6 <.Loc.61.1>:
    8bb6:	4a 43       	clr.b	r10		;
    8bb8:	30 40 8a 8b 	br	#0x8b8a		;

00008bbc <__mspabi_remi>:
    8bbc:	0a 12       	push	r10		;

00008bbe <.LCFI1>:
    8bbe:	0c 93       	cmp	#0,	r12	;r3 As==00
    8bc0:	13 34       	jge	$+40     	;abs 0x8be8

00008bc2 <.Loc.92.1>:
    8bc2:	4e 43       	clr.b	r14		;
    8bc4:	0e 8c       	sub	r12,	r14	;
    8bc6:	0c 4e       	mov	r14,	r12	;

00008bc8 <.LVL31>:
    8bc8:	5a 43       	mov.b	#1,	r10	;r3 As==01

00008bca <.L29>:
    8bca:	0d 93       	cmp	#0,	r13	;r3 As==00
    8bcc:	03 34       	jge	$+8      	;abs 0x8bd4
    8bce:	4e 43       	clr.b	r14		;
    8bd0:	0e 8d       	sub	r13,	r14	;
    8bd2:	0d 4e       	mov	r14,	r13	;

00008bd4 <.L30>:
    8bd4:	5e 43       	mov.b	#1,	r14	;r3 As==01
    8bd6:	b0 12 30 8b 	call	#35632		;#0x8b30

00008bda <.LVL34>:
    8bda:	0a 93       	cmp	#0,	r10	;r3 As==00
    8bdc:	03 24       	jz	$+8      	;abs 0x8be4

00008bde <.LVL35>:
    8bde:	4d 43       	clr.b	r13		;
    8be0:	0d 8c       	sub	r12,	r13	;
    8be2:	0c 4d       	mov	r13,	r12	;

00008be4 <.L28>:
    8be4:	3a 41       	pop	r10		;
    8be6:	30 41       	ret			

00008be8 <.L32>:
    8be8:	4a 43       	clr.b	r10		;
    8bea:	30 40 ca 8b 	br	#0x8bca		;

00008bee <__mspabi_func_epilog_7>:
    8bee:	34 41       	pop	r4		;

00008bf0 <__mspabi_func_epilog_6>:
    8bf0:	35 41       	pop	r5		;

00008bf2 <__mspabi_func_epilog_5>:
    8bf2:	36 41       	pop	r6		;

00008bf4 <__mspabi_func_epilog_4>:
    8bf4:	37 41       	pop	r7		;

00008bf6 <__mspabi_func_epilog_3>:
    8bf6:	38 41       	pop	r8		;

00008bf8 <__mspabi_func_epilog_2>:
    8bf8:	39 41       	pop	r9		;

00008bfa <__mspabi_func_epilog_1>:
    8bfa:	3a 41       	pop	r10		;
    8bfc:	30 41       	ret			

00008bfe <__mspabi_srli_15>:
    8bfe:	12 c3       	clrc			
    8c00:	0c 10       	rrc	r12		;

00008c02 <__mspabi_srli_14>:
    8c02:	12 c3       	clrc			
    8c04:	0c 10       	rrc	r12		;

00008c06 <__mspabi_srli_13>:
    8c06:	12 c3       	clrc			
    8c08:	0c 10       	rrc	r12		;

00008c0a <__mspabi_srli_12>:
    8c0a:	12 c3       	clrc			
    8c0c:	0c 10       	rrc	r12		;

00008c0e <__mspabi_srli_11>:
    8c0e:	12 c3       	clrc			
    8c10:	0c 10       	rrc	r12		;

00008c12 <__mspabi_srli_10>:
    8c12:	12 c3       	clrc			
    8c14:	0c 10       	rrc	r12		;

00008c16 <__mspabi_srli_9>:
    8c16:	12 c3       	clrc			
    8c18:	0c 10       	rrc	r12		;

00008c1a <__mspabi_srli_8>:
    8c1a:	12 c3       	clrc			
    8c1c:	0c 10       	rrc	r12		;

00008c1e <__mspabi_srli_7>:
    8c1e:	12 c3       	clrc			
    8c20:	0c 10       	rrc	r12		;

00008c22 <__mspabi_srli_6>:
    8c22:	12 c3       	clrc			
    8c24:	0c 10       	rrc	r12		;

00008c26 <__mspabi_srli_5>:
    8c26:	12 c3       	clrc			
    8c28:	0c 10       	rrc	r12		;

00008c2a <__mspabi_srli_4>:
    8c2a:	12 c3       	clrc			
    8c2c:	0c 10       	rrc	r12		;

00008c2e <__mspabi_srli_3>:
    8c2e:	12 c3       	clrc			
    8c30:	0c 10       	rrc	r12		;

00008c32 <__mspabi_srli_2>:
    8c32:	12 c3       	clrc			
    8c34:	0c 10       	rrc	r12		;

00008c36 <__mspabi_srli_1>:
    8c36:	12 c3       	clrc			
    8c38:	0c 10       	rrc	r12		;
    8c3a:	30 41       	ret			

00008c3c <.L11>:
    8c3c:	3d 53       	add	#-1,	r13	;r3 As==11
    8c3e:	12 c3       	clrc			
    8c40:	0c 10       	rrc	r12		;

00008c42 <__mspabi_srli>:
    8c42:	0d 93       	cmp	#0,	r13	;r3 As==00
    8c44:	fb 23       	jnz	$-8      	;abs 0x8c3c
    8c46:	30 41       	ret			

00008c48 <__mspabi_srll_15>:
    8c48:	12 c3       	clrc			
    8c4a:	0d 10       	rrc	r13		;
    8c4c:	0c 10       	rrc	r12		;

00008c4e <__mspabi_srll_14>:
    8c4e:	12 c3       	clrc			
    8c50:	0d 10       	rrc	r13		;
    8c52:	0c 10       	rrc	r12		;

00008c54 <__mspabi_srll_13>:
    8c54:	12 c3       	clrc			
    8c56:	0d 10       	rrc	r13		;
    8c58:	0c 10       	rrc	r12		;

00008c5a <__mspabi_srll_12>:
    8c5a:	12 c3       	clrc			
    8c5c:	0d 10       	rrc	r13		;
    8c5e:	0c 10       	rrc	r12		;

00008c60 <__mspabi_srll_11>:
    8c60:	12 c3       	clrc			
    8c62:	0d 10       	rrc	r13		;
    8c64:	0c 10       	rrc	r12		;

00008c66 <__mspabi_srll_10>:
    8c66:	12 c3       	clrc			
    8c68:	0d 10       	rrc	r13		;
    8c6a:	0c 10       	rrc	r12		;

00008c6c <__mspabi_srll_9>:
    8c6c:	12 c3       	clrc			
    8c6e:	0d 10       	rrc	r13		;
    8c70:	0c 10       	rrc	r12		;

00008c72 <__mspabi_srll_8>:
    8c72:	12 c3       	clrc			
    8c74:	0d 10       	rrc	r13		;
    8c76:	0c 10       	rrc	r12		;

00008c78 <__mspabi_srll_7>:
    8c78:	12 c3       	clrc			
    8c7a:	0d 10       	rrc	r13		;
    8c7c:	0c 10       	rrc	r12		;

00008c7e <__mspabi_srll_6>:
    8c7e:	12 c3       	clrc			
    8c80:	0d 10       	rrc	r13		;
    8c82:	0c 10       	rrc	r12		;

00008c84 <__mspabi_srll_5>:
    8c84:	12 c3       	clrc			
    8c86:	0d 10       	rrc	r13		;
    8c88:	0c 10       	rrc	r12		;

00008c8a <__mspabi_srll_4>:
    8c8a:	12 c3       	clrc			
    8c8c:	0d 10       	rrc	r13		;
    8c8e:	0c 10       	rrc	r12		;

00008c90 <__mspabi_srll_3>:
    8c90:	12 c3       	clrc			
    8c92:	0d 10       	rrc	r13		;
    8c94:	0c 10       	rrc	r12		;

00008c96 <__mspabi_srll_2>:
    8c96:	12 c3       	clrc			
    8c98:	0d 10       	rrc	r13		;
    8c9a:	0c 10       	rrc	r12		;

00008c9c <__mspabi_srll_1>:
    8c9c:	12 c3       	clrc			
    8c9e:	0d 10       	rrc	r13		;
    8ca0:	0c 10       	rrc	r12		;
    8ca2:	30 41       	ret			

00008ca4 <.L12>:
    8ca4:	3e 53       	add	#-1,	r14	;r3 As==11
    8ca6:	12 c3       	clrc			
    8ca8:	0d 10       	rrc	r13		;
    8caa:	0c 10       	rrc	r12		;

00008cac <__mspabi_srll>:
    8cac:	0e 93       	cmp	#0,	r14	;r3 As==00
    8cae:	fa 23       	jnz	$-10     	;abs 0x8ca4
    8cb0:	30 41       	ret			

00008cb2 <memmove>:
    8cb2:	0d 9c       	cmp	r12,	r13	;
    8cb4:	0a 28       	jnc	$+22     	;abs 0x8cca

00008cb6 <.L5>:
    8cb6:	0f 4c       	mov	r12,	r15	;
    8cb8:	0e 5c       	add	r12,	r14	;

00008cba <.L3>:
    8cba:	0e 9f       	cmp	r15,	r14	;
    8cbc:	0d 24       	jz	$+28     	;abs 0x8cd8

00008cbe <.LVL3>:
    8cbe:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    8cc2:	1f 53       	inc	r15		;

00008cc4 <.LVL4>:
    8cc4:	1d 53       	inc	r13		;
    8cc6:	30 40 ba 8c 	br	#0x8cba		;

00008cca <.L2>:
    8cca:	0f 4d       	mov	r13,	r15	;
    8ccc:	0f 5e       	add	r14,	r15	;
    8cce:	0c 9f       	cmp	r15,	r12	;
    8cd0:	f2 2f       	jc	$-26     	;abs 0x8cb6

00008cd2 <.L4>:
    8cd2:	3e 53       	add	#-1,	r14	;r3 As==11

00008cd4 <.LVL7>:
    8cd4:	3e 93       	cmp	#-1,	r14	;r3 As==11
    8cd6:	01 20       	jnz	$+4      	;abs 0x8cda

00008cd8 <.L10>:
    8cd8:	30 41       	ret			

00008cda <.L6>:
    8cda:	0b 4c       	mov	r12,	r11	;
    8cdc:	0b 5e       	add	r14,	r11	;
    8cde:	0f 4d       	mov	r13,	r15	;
    8ce0:	0f 5e       	add	r14,	r15	;
    8ce2:	eb 4f 00 00 	mov.b	@r15,	0(r11)	;
    8ce6:	30 40 d2 8c 	br	#0x8cd2		;

00008cea <memset>:
    8cea:	0f 4c       	mov	r12,	r15	;
    8cec:	0e 5c       	add	r12,	r14	;

00008cee <.L2>:
    8cee:	0f 9e       	cmp	r14,	r15	;
    8cf0:	01 20       	jnz	$+4      	;abs 0x8cf4

00008cf2 <.Loc.104.1>:
    8cf2:	30 41       	ret			

00008cf4 <.L3>:
    8cf4:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    8cf8:	1f 53       	inc	r15		;

00008cfa <.LVL4>:
    8cfa:	30 40 ee 8c 	br	#0x8cee		;

00008cfe <__do_global_ctors_aux>:
    8cfe:	0a 12       	push	r10		;
    8d00:	3a 40 24 80 	mov	#32804,	r10	;#0x8024

00008d04 <.L2>:
    8d04:	2c 4a       	mov	@r10,	r12	;
    8d06:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8d08:	02 20       	jnz	$+6      	;abs 0x8d0e
    8d0a:	3a 41       	pop	r10		;
    8d0c:	30 41       	ret			

00008d0e <.L3>:
    8d0e:	8c 12       	call	r12		;
    8d10:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    8d14:	30 40 04 8d 	br	#0x8d04		;

00008d18 <__msp430_init>:
    8d18:	b0 12 94 82 	call	#33428		;#0x8294
    8d1c:	b0 12 fe 8c 	call	#36094		;#0x8cfe

00008d20 <L0>:
    8d20:	b0 12 d0 81 	call	#33232		;#0x81d0

00008d24 <.Loc.19.1>:
    8d24:	b0 12 c2 81 	call	#33218		;#0x81c2

00008d28 <.Loc.20.1>:
    8d28:	30 41       	ret			

00008d2a <__msp430_fini>:
    8d2a:	b0 12 de 81 	call	#33246		;#0x81de

00008d2e <L0>:
    8d2e:	b0 12 46 82 	call	#33350		;#0x8246

00008d32 <L0>:
    8d32:	30 41       	ret			

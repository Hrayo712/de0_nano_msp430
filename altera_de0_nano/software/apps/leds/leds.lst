
leds.elf:     file format elf32-msp430

SYMBOL TABLE:
0000ffe8 l    d  __interrupt_vector_5	00000000 __interrupt_vector_5
0000fff0 l    d  __interrupt_vector_9	00000000 __interrupt_vector_9
0000fffe l    d  __reset_vector	00000000 __reset_vector
00008000 l    d  .rodata	00000000 .rodata
00008010 l    d  .text	00000000 .text
00004000 l    d  .data	00000000 .data
00004102 l    d  .bss	00000000 .bss
00004114 l    d  .noinit	00000000 .noinit
00000000 l    d  .MP430.attributes	00000000 .MP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 qwark.c
0000804c l       .text	00000000 __qwark_retry_1st_setup
00008040 l       .text	00000000 __qwark_restore_2nd_setup
00008060 l       .text	00000000 __qwark_retry_2nd_setup
00008034 l       .text	00000000 __qwark_restore_1st_setup
000080c4 l       .text	00000000 __system_restore
00008070 l       .text	00000000 __second_stage_retry
00008078 l       .text	00000000 _retry_second_phase_commit_strt
00008094 l       .text	00000000 _retry_byte_copy
000080ae l       .text	00000000 __retry_complete
000080be l       .text	00000000 __set_flag_complete
0000813a l       .text	00000000 __Second_buffer_restore_stack
000080fa l       .text	00000000 __First_buffer_restore_stack
000086d8 l       .text	00000000 __second_buffer_init
000086dc l       .text	00000000 __first_phase_commit
0000877a l       .text	00000000 __second_phase_start
0000876e l       .text	00000000 _scratchpad_addr_cpy
00008788 l       .text	00000000 __set_flag_2nd
0000878c l       .text	00000000 _second_phase_commit
000087da l       .text	00000000 _chkpt_finished
000087a2 l       .text	00000000 _second_phase_commit_strt
000087c0 l       .text	00000000 _byte_copy
000087b4 l       .text	00000000 _pre_end_copy
00008802 l       .text	00000000 __pre_finish_2nd_buffer
00008820 l       .text	00000000 _finish
00000000 l    df *ABS*	00000000 timerA.c
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
000081d4 l       .text	00000000 _msp430_run_array
000081e2 l       .text	00000000 _msp430_run_done
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtbegin.o
00008008 l     O .rodata	00000000 __CTOR_LIST__
0000800c l     O .rodata	00000000 __DTOR_LIST__
00008000 l     O .rodata	00000000 __EH_FRAME_BEGIN__
00008a34 l     O .text	00000000 __TMC_LIST__
000081e4 l     F .text	00000000 deregister_tm_clones
000081fe l     F .text	00000000 register_tm_clones
0000822c l     F .text	00000000 __do_global_dtors_aux
00004102 l     O .bss	00000000 completed.3056
00004104 l     O .bss	00000000 dtor_idx.3058
0000827a l     F .text	00000000 frame_dummy
00004106 l     O .bss	00000000 object.3071
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtend.o
0000800a l     O .rodata	00000000 __CTOR_END__
00008000 l     O .rodata	00000000 __FRAME_END__
000089fe l     F .text	00000000 __do_global_ctors_aux
00000000 l    df *ABS*	00000000 crt_bss.o
00000000 l    df *ABS*	00000000 crt_movedata.o
00000000 l    df *ABS*	00000000 crt_main.o
00000000 l    df *ABS*	00000000 main.c
00008648 l     F .text	0000004a bit_shifter
00000000 l    df *ABS*	00000000 srli.o
00000000 l    df *ABS*	00000000 lib_a-memmove.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crtn.o
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 
00008010 l       .text	00000000 _start
00008916 g       .text	00000000 .hidden __mspabi_srli_9
00008966 g       .text	00000000 .hidden __mspabi_srll_10
00008912 g       .text	00000000 .hidden __mspabi_srli_10
0000848a g     F .text	000000be ntbl_bitcount
000088fe g       .text	00000000 .hidden __mspabi_srli_15
000089b2 g     F .text	00000038 memmove
0000892a g       .text	00000000 .hidden __mspabi_srli_4
0000891e g       .text	00000000 .hidden __mspabi_srli_7
00008978 g       .text	00000000 .hidden __mspabi_srll_7
00008990 g       .text	00000000 .hidden __mspabi_srll_3
000088f0 g       .text	00000000 .hidden __mspabi_func_epilog_6
00008a34 g     O .text	00000000 .hidden __TMC_END__
00008954 g       .text	00000000 .hidden __mspabi_srll_13
0000800e g     O .rodata	00000000 .hidden __DTOR_END__
00008004 g       .rodata	00000000 __fini_array_end
0000890a g       .text	00000000 .hidden __mspabi_srli_12
00008010 g     F .text	00000004 __crt0_start
0000817c g     F .text	0000000e __crt0_init_bss
00004000 g     O .data	00000100 bits
00000012 g       *ABS*	00000000 __bsssize
0000819e g     F .text	0000000a __crt0_call_init_then_main
000088fa g       .text	00000000 .hidden __mspabi_func_epilog_1
000088f6 g       .text	00000000 .hidden __mspabi_func_epilog_3
00008984 g       .text	00000000 .hidden __mspabi_srll_5
00008942 g       .text	00000000 .hidden __mspabi_srli
00008960 g       .text	00000000 .hidden __mspabi_srll_11
00008926 g       .text	00000000 .hidden __mspabi_srli_5
00008548 g     F .text	00000044 BW_btbl_bitcount
00000000  w      *UND*	00000000 __deregister_frame_info
00004114 g       .noinit	00000000 end
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
0000897e g       .text	00000000 .hidden __mspabi_srll_6
000081c4 g     F .text	00000000 _msp430_run_fini_array
00008936 g       .text	00000000 .hidden __mspabi_srli_1
0000894e g       .text	00000000 .hidden __mspabi_srll_14
00008326 g     F .text	00000164 bitcount
00008014 g     F .text	00000168 qwark_restore
00008902 g       .text	00000000 .hidden __mspabi_srli_14
00000102 g       *ABS*	00000000 __romdatacopysize
00008692 g     F .text	00000024 init
0000890e g       .text	00000000 .hidden __mspabi_srli_11
00004100 g     O .data	00000002 periodic_val
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
00008004 g       .rodata	00000000 __fini_array_start
00000000  w      *ABS*	00000000 __rom_highdatacopysize
000085fa g     F .text	0000004e ntbl_bitcnt
00008a18 g       .text	00000000 __msp430_init
000089ea g     F .text	00000014 memset
000086b6 g     F .text	00000008 main
0000888a g     F .text	00000022 ta_wait
0000898a g       .text	00000000 .hidden __mspabi_srll_4
00008004 g       .rodata	00000000 __init_array_end
00008932 g       .text	00000000 .hidden __mspabi_srli_2
00000000  w      *ABS*	00000000 __high_bsssize
000082e2 g     F .text	00000044 bit_count
00000000  w      *ABS*	00000000 __rom_highdatastart
000088ac g     F .text	00000042 INT_timerA1
00008a34 g       .text	00000000 __msp430_fini_end
0000895a g       .text	00000000 .hidden __mspabi_srll_12
00008a34 g       *ABS*	00000000 __romdatastart
000081a8 g     F .text	00000000 _msp430_run_init_array
00008868 g     F .text	00000022 ta_wait_no_lpm
00008922 g       .text	00000000 .hidden __mspabi_srli_6
00008004 g       .rodata	00000000 __preinit_array_end
0000892e g       .text	00000000 .hidden __mspabi_srli_3
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
00004102 g       .bss	00000000 __bssstart
000088f2 g       .text	00000000 .hidden __mspabi_func_epilog_5
00008292 g     F .text	00000050 btbl_bitcnt
00008000 g       .noinit	00000000 __stack
000086be g     F .text	000001aa INT_Qwark
0000896c g       .text	00000000 .hidden __mspabi_srll_9
00004102 g       .data	00000000 _edata
00008a2a g       .text	00000000 __msp430_init_end
000089ac g       .text	00000000 .hidden __mspabi_srll
00000000  w      *ABS*	00000000 __high_bssstart
00008948 g       .text	00000000 .hidden __mspabi_srll_15
00008004 g       .rodata	00000000 __init_array_start
0000858c g     F .text	0000006e AR_btbl_bitcount
00008906 g       .text	00000000 .hidden __mspabi_srli_13
00004000 g       .data	00000000 __datastart
00008972 g       .text	00000000 .hidden __mspabi_srll_8
0000899c g       .text	00000000 .hidden __mspabi_srll_1
00008004 g       .rodata	00000000 __preinit_array_start
0000818a g     F .text	00000014 __crt0_movedata
000088f8 g       .text	00000000 .hidden __mspabi_func_epilog_2
00000000  w      *UND*	00000000 __register_frame_info
000081b6 g     F .text	00000000 _msp430_run_preinit_array
000088ee g       .text	00000000 .hidden __mspabi_func_epilog_7
000088f4 g       .text	00000000 .hidden __mspabi_func_epilog_4
00008996 g       .text	00000000 .hidden __mspabi_srll_2
00008a2a g       .text	00000000 __msp430_fini
0000891a g       .text	00000000 .hidden __mspabi_srli_8



Disassembly of section __interrupt_vector_5:

0000ffe8 <__interrupt_vector_5>:
    ffe8:	be 86       	interrupt service routine at 0x86be

Disassembly of section __interrupt_vector_9:

0000fff0 <__interrupt_vector_9>:
    fff0:	ac 88       	interrupt service routine at 0x88ac

Disassembly of section .text:

00008010 <__crt0_start>:
    8010:	31 40 00 80 	mov	#32768,	r1	;#0x8000

00008014 <qwark_restore>:
	//    RESTORE HANDLING LOGIC																  				   //
	//	  W.C 30 CYCLES																							   //
	//-------------------------------------------------------------------------------------------------------------//

	/* Disable Qwark */
	__asm__ __volatile__ ("mov #0x0000, &0x02A0");				// 4 cycles
    8014:	82 43 a0 02 	mov	#0,	&0x02a0	;r3 As==00

00008018 <.Loc.29.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");				// 2 cycles
    8018:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

0000801c <.Loc.30.1>:
	__asm__ __volatile__ ("jz __qwark_retry_1st_setup");		// 2 cycles
    801c:	17 24       	jz	$+48     	;abs 0x804c

0000801e <.Loc.32.1>:

	__asm__ __volatile__ ("cmp.b #0x03, &0x6075");				// 3 cycles
    801e:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    8022:	75 60 

00008024 <.Loc.33.1>:
	__asm__ __volatile__ ("jz __qwark_restore_2nd_setup");		// 2 cycles
    8024:	0d 24       	jz	$+28     	;abs 0x8040

00008026 <.Loc.34.1>:
	__asm__ __volatile__ ("cmp.b #0x03, &0x6074");				// 3 cycles
    8026:	f2 90 03 00 	cmp.b	#3,	&0x6074	;
    802a:	74 60 

0000802c <.Loc.35.1>:
	__asm__ __volatile__ ("jnz __crt0_init_bss");				// 2 cycles
    802c:	a7 20       	jnz	$+336    	;abs 0x817c

0000802e <.Loc.37.1>:

	__asm__ __volatile__ ("cmp.b #0x02, &0x6075");				// 2 cycles
    802e:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

00008032 <.Loc.38.1>:
	__asm__ __volatile__ ("jz  __qwark_retry_2nd_setup");		// 2 cycles
    8032:	16 24       	jz	$+46     	;abs 0x8060

00008034 <__qwark_restore_1st_setup>:

	__asm__ __volatile__ ("__qwark_restore_1st_setup:");

	__asm__ __volatile__ ("mov &0X6012,   r12 ");				// 3 cycles
    8034:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008038 <.Loc.43.1>:
    __asm__ __volatile__ ("mov #0x6FFE,   r13 ");				// 2 cycles
    8038:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

0000803c <.Loc.44.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    803c:	30 40 c4 80 	br	#0x80c4		;

00008040 <__qwark_restore_2nd_setup>:

	__asm__ __volatile__ ("__qwark_restore_2nd_setup:");

	__asm__ __volatile__ ("mov &0X6042, r12   ");				// 3 cycles
    8040:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008044 <.Loc.49.1>:
    __asm__ __volatile__ ("mov #0x6BFE, r13   ");				// 2 cycles
    8044:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

00008048 <.Loc.50.1>:
	__asm__ __volatile__ ("br  #__system_restore");				// 2 cycles
    8048:	30 40 c4 80 	br	#0x80c4		;

0000804c <__qwark_retry_1st_setup>:

	__asm__ __volatile__ ("__qwark_retry_1st_setup:");

	__asm__ __volatile__ ("mov  #0x6030,   r10 ");				// 2 cycles
    804c:	3a 40 30 60 	mov	#24624,	r10	;#0x6030

00008050 <.Loc.55.1>:
	__asm__ __volatile__ ("mov  &0X6012,   r12 ");				// 3 cycles
    8050:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

00008054 <.Loc.56.1>:
    __asm__ __volatile__ ("mov  #0x6FFE,   r13 ");				// 2 cycles
    8054:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

00008058 <.Loc.57.1>:
	__asm__ __volatile__ ("mov  &0x602E,   r15 ");				// 3 cycles
    8058:	1f 42 2e 60 	mov	&0x602e,r15	;0x602e

0000805c <.Loc.58.1>:
	__asm__ __volatile__ ("br  #__second_stage_retry");			// 2 cycles
    805c:	30 40 70 80 	br	#0x8070		;

00008060 <__qwark_retry_2nd_setup>:

	__asm__ __volatile__ ("__qwark_retry_2nd_setup:");

	__asm__ __volatile__ ("mov #0x6060,   r10 ");				// 2 cycles
    8060:	3a 40 60 60 	mov	#24672,	r10	;#0x6060

00008064 <.Loc.63.1>:
	__asm__ __volatile__ ("mov &0X6042,   r12 ");				// 3 cycles
    8064:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

00008068 <.Loc.64.1>:
    __asm__ __volatile__ ("mov #0x6BFE,   r13 ");				// 2 cycles
    8068:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

0000806c <.Loc.65.1>:
	__asm__ __volatile__ ("mov &0x605E,   r15 ");				// 3 cycles
    806c:	1f 42 5e 60 	mov	&0x605e,r15	;0x605e

00008070 <__second_stage_retry>:
	//-------------------------------------------------------------------------------------------------------------//
	//    RETRY SECOND PHASE OF THE COMMIT PROCESS	: 148 cycles												   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__second_stage_retry:");

	__asm__ __volatile__ ("tst r15 ");     		            // 1 cycles
    8070:	0f 93       	cmp	#0,	r15	;r3 As==00

00008072 <.Loc.73.1>:
	__asm__ __volatile__ ("jz  __system_restore");		    // 2 cycles
    8072:	28 24       	jz	$+82     	;abs 0x80c4

00008074 <.Loc.75.1>:

	__asm__ __volatile__ ("mov #0x6000,  r14");			    // 2 cycles
    8074:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008078 <_retry_second_phase_commit_strt>:

	__asm__ __volatile__ ("_retry_second_phase_commit_strt:");  // Worst case

	__asm__ __volatile__ ("mov @r10+2,  r9 ");   			// 2 cycles
    8078:	39 4a       	mov	@r10+,	r9	;

0000807a <.Loc.81.1>:

	__asm__ __volatile__ ("mov r9,  r11 ");   			    // 1 cycle
    807a:	0b 49       	mov	r9,	r11	;

0000807c <.Loc.83.1>:

	__asm__ __volatile__ ("and #0x8000,  r11 ");   			// 2 cycles
    807c:	3b f0 00 80 	and	#32768,	r11	;#0x8000

00008080 <.Loc.84.1>:
	__asm__ __volatile__ ("cmp #0x8000,  r11 ");   			// 2 cycles
    8080:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

00008084 <.Loc.85.1>:
	__asm__ __volatile__ ("jeq _retry_byte_copy ");   		// 2 cycles
    8084:	07 24       	jz	$+16     	;abs 0x8094

00008086 <.Loc.87.1>:

	__asm__ __volatile__ ("mov @r14+2, @r9 ");    			// 5 cycles
    8086:	b9 4e 00 00 	mov	@r14+,	0(r9)	;

0000808a <.Loc.89.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    808a:	1f 83       	dec	r15		;

0000808c <.Loc.90.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    808c:	0f 93       	cmp	#0,	r15	;r3 As==00

0000808e <.Loc.92.1>:

	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    808e:	f4 23       	jnz	$-22     	;abs 0x8078

00008090 <.Loc.93.1>:
	__asm__ __volatile__ ("br #__retry_complete");		    // 2 cycle
    8090:	30 40 ae 80 	br	#0x80ae		;

00008094 <_retry_byte_copy>:

	__asm__ __volatile__ ("_retry_byte_copy: ");
	__asm__ __volatile__ ("and #0x7FFF,  r9  ");   			// mask the highest bit 2 cycles
    8094:	39 f0 ff 7f 	and	#32767,	r9	;#0x7fff

00008098 <.Loc.97.1>:
	__asm__ __volatile__ ("mov r9,      r11  ");   			// 1 cycle
    8098:	0b 49       	mov	r9,	r11	;

0000809a <.Loc.98.1>:
	__asm__ __volatile__ ("and #0x01,    r11 ");   			// detect if its a byte write - 2 cycles
    809a:	1b f3       	and	#1,	r11	;r3 As==01

0000809c <.Loc.99.1>:
	__asm__ __volatile__ ("bis  r11,     r14 ");   			// detect if its a byte write - 2 cycles
    809c:	0e db       	bis	r11,	r14	;

0000809e <.Loc.101.1>:

	__asm__ __volatile__ ("mov.b @r14, @r9  ");    			// 5 cycles
    809e:	e9 4e 00 00 	mov.b	@r14,	0(r9)	;

000080a2 <.Loc.102.1>:
	__asm__ __volatile__ ("and #0xFFFE, r14 ");    			// 1 cycle
    80a2:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

000080a6 <.Loc.103.1>:
	__asm__ __volatile__ ("incd r14 ");    					// 1 cycle
    80a6:	2e 53       	incd	r14		;

000080a8 <.Loc.105.1>:

	__asm__ __volatile__ ("dec r15");    					// 1 cycles
    80a8:	1f 83       	dec	r15		;

000080aa <.Loc.106.1>:
	__asm__ __volatile__ ("tst r15");    					// 1 cycles
    80aa:	0f 93       	cmp	#0,	r15	;r3 As==00

000080ac <.Loc.107.1>:
	__asm__ __volatile__ ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80ac:	e5 23       	jnz	$-52     	;abs 0x8078

000080ae <__retry_complete>:

	//-------------------------------------------------------------------------------------------------------------//
	//    END OF THE RETRY-SECOND PHASE	: Atomic Flag Set														   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("cmp.b #0x02, &0x6074");		// 4 cycles
    80ae:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

000080b2 <.Loc.116.1>:
	__asm__ __volatile__ ("jz __set_flag_complete");	// 2 cycles
    80b2:	05 24       	jz	$+12     	;abs 0x80be

000080b4 <.Loc.118.1>:

	__asm__ __volatile__ ("mov #0x0301, &0x6074 ");		// 5 cycles
    80b4:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    80b8:	74 60 

000080ba <.Loc.119.1>:
	__asm__ __volatile__ ("br #__system_restore:");		// 2 cycles
    80ba:	30 40 c4 80 	br	#0x80c4		;

000080be <__set_flag_complete>:

	__asm__ __volatile__ ("__set_flag_complete:");
	__asm__ __volatile__ ("mov #0x0103, &0x6074 ");		// 5 cycles
    80be:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    80c2:	74 60 

000080c4 <__system_restore>:
	//	 12 CYCLES																								   //
	//-------------------------------------------------------------------------------------------------------------//
	__asm__ __volatile__ ("__system_restore:");

	/* Disable The Watchdog */
	__asm__ __volatile__ ("mov #288, r8");		// 2 cycles
    80c4:	38 40 20 01 	mov	#288,	r8	;#0x0120

000080c8 <.Loc.132.1>:
	__asm__ __volatile__ ("mov #23168, 0(r8)");	// 2 cycles
    80c8:	b8 40 80 5a 	mov	#23168,	0(r8)	;#0x5a80
    80cc:	00 00 

000080ce <.Loc.135.1>:

	/* Enable and Configure the UART */
	__asm__ __volatile__ ("mov.b #130, r8");	// 2 cycles
    80ce:	78 40 82 00 	mov.b	#130,	r8	;#0x0082

000080d2 <.Loc.136.1>:
	__asm__ __volatile__ ("mov   #8, 0(r8)");	// 2 cycles
    80d2:	b8 42 00 00 	mov	#8,	0(r8)	;r2 As==11

000080d6 <.Loc.138.1>:

	__asm__ __volatile__ ("mov.b #128, r8");	// 2 cycles
    80d6:	78 40 80 00 	mov.b	#128,	r8	;#0x0080

000080da <.Loc.139.1>:
	__asm__ __volatile__ ("mov.b   #1, 0(r8)"); // 2 cycles
    80da:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01

000080de <.Loc.145.1>:

	/* Configure the timer */


#ifdef TIMER_TEST
	__asm__ __volatile__ ("mov  #370, r8");		    // 2 cycles
    80de:	38 40 72 01 	mov	#370,	r8	;#0x0172

000080e2 <.Loc.146.1>:
	__asm__ __volatile__ ("mov  #9980, 0(r8)");	// 2 cycles
    80e2:	b8 40 fc 26 	mov	#9980,	0(r8)	;#0x26fc
    80e6:	00 00 

000080e8 <.Loc.148.1>:

	__asm__ __volatile__ ("mov  #352, r8");		    // 2 cycles
    80e8:	38 40 60 01 	mov	#352,	r8	;#0x0160

000080ec <.Loc.149.1>:
	__asm__ __volatile__ ("mov  #534, 0(r8)");	    // 2 cycles
    80ec:	b8 40 16 02 	mov	#534,	0(r8)	;#0x0216
    80f0:	00 00 

000080f2 <.Loc.205.1>:
	//-------------------------------------------------------------------------------------------------------------//
	//   REGISTERS RESTORE: VERIFY WHICH REGISTERS SHOULD BE RESTORED					   						   //
	//	 																										   //
	//-------------------------------------------------------------------------------------------------------------//

	__asm__ __volatile__ ("cmp.b #0x03,&0x6075");				// 5 cycles
    80f2:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    80f6:	75 60 

000080f8 <.Loc.206.1>:
	__asm__ __volatile__ ("jeq __Second_buffer_restore_stack"); // 2 cycles
    80f8:	20 24       	jz	$+66     	;abs 0x813a

000080fa <__First_buffer_restore_stack>:
	/* EDE -> Rm  : 3 cycles each 											  				  			  */
	/* EDE -> PC  : 4 cycles (1 extra cycle penalty) for openMSP430 		  				  			  */
	/* Register time: 14x3 = 42 cycles + 4 cycles (PC) = 49 Cycles + 4(Qwark enable) = 53 cycles 		  */
	__asm__ __volatile__ ("__First_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6016,r4"); 		//R4
    80fa:	14 42 16 60 	mov	&0x6016,r4	;0x6016

000080fe <.Loc.216.1>:
	__asm__ __volatile__ ("mov &0x6018,r5"); 		//R5
    80fe:	15 42 18 60 	mov	&0x6018,r5	;0x6018

00008102 <.Loc.217.1>:
	__asm__ __volatile__ ("mov &0x601A,r6"); 		//R6
    8102:	16 42 1a 60 	mov	&0x601a,r6	;0x601a

00008106 <.Loc.218.1>:
	__asm__ __volatile__ ("mov &0x601C,r7"); 		//R7
    8106:	17 42 1c 60 	mov	&0x601c,r7	;0x601c

0000810a <.Loc.219.1>:
	__asm__ __volatile__ ("mov &0x601E,r8"); 		//R8
    810a:	18 42 1e 60 	mov	&0x601e,r8	;0x601e

0000810e <.Loc.220.1>:
	__asm__ __volatile__ ("mov &0x6020,r9"); 		//R9
    810e:	19 42 20 60 	mov	&0x6020,r9	;0x6020

00008112 <.Loc.221.1>:
	__asm__ __volatile__ ("mov &0x6022,r10"); 		//R10
    8112:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

00008116 <.Loc.222.1>:
	__asm__ __volatile__ ("mov &0x6024,r11"); 		//R11
    8116:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

0000811a <.Loc.223.1>:
	__asm__ __volatile__ ("mov &0x6026,r12"); 		//R12
    811a:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

0000811e <.Loc.224.1>:
	__asm__ __volatile__ ("mov &0x6028,r13"); 	    //R13
    811e:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00008122 <.Loc.225.1>:
	__asm__ __volatile__ ("mov &0x602A,r14"); 		//R14
    8122:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

00008126 <.Loc.226.1>:
	__asm__ __volatile__ ("mov &0x602C,r15"); 		//R15
    8126:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

0000812a <.Loc.227.1>:
	__asm__ __volatile__ ("mov &0x6012,r1");   		//SP/R1
    812a:	11 42 12 60 	mov	&0x6012,r1	;0x6012

0000812e <.Loc.228.1>:
	__asm__ __volatile__ ("mov &0x6014,r2"); 	    //SR/R2
    812e:	12 42 14 60 	mov	&0x6014,r2	;0x6014

00008132 <.Loc.231.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    8132:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008136 <.Loc.234.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6010, pc"); 	    //PC/R0
    8136:	10 42 10 60 	br	&0x6010		;

0000813a <__Second_buffer_restore_stack>:

	__asm__ __volatile__ ("__Second_buffer_restore_stack:");

	__asm__ __volatile__ ("mov &0x6046,r4"); 		//R4
    813a:	14 42 46 60 	mov	&0x6046,r4	;0x6046

0000813e <.Loc.239.1>:
	__asm__ __volatile__ ("mov &0x6048,r5"); 		//R5
    813e:	15 42 48 60 	mov	&0x6048,r5	;0x6048

00008142 <.Loc.240.1>:
	__asm__ __volatile__ ("mov &0x604A,r6"); 		//R6
    8142:	16 42 4a 60 	mov	&0x604a,r6	;0x604a

00008146 <.Loc.241.1>:
	__asm__ __volatile__ ("mov &0x604C,r7"); 		//R7
    8146:	17 42 4c 60 	mov	&0x604c,r7	;0x604c

0000814a <.Loc.242.1>:
	__asm__ __volatile__ ("mov &0x604E,r8"); 		//R8
    814a:	18 42 4e 60 	mov	&0x604e,r8	;0x604e

0000814e <.Loc.243.1>:
	__asm__ __volatile__ ("mov &0x6050,r9"); 		//R9
    814e:	19 42 50 60 	mov	&0x6050,r9	;0x6050

00008152 <.Loc.244.1>:
	__asm__ __volatile__ ("mov &0x6052,r10"); 		//R10
    8152:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

00008156 <.Loc.245.1>:
	__asm__ __volatile__ ("mov &0x6054,r11"); 		//R11
    8156:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

0000815a <.Loc.246.1>:
	__asm__ __volatile__ ("mov &0x6056,r12"); 		//R12
    815a:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

0000815e <.Loc.247.1>:
	__asm__ __volatile__ ("mov &0x6058,r13"); 	    //R13
    815e:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

00008162 <.Loc.248.1>:
	__asm__ __volatile__ ("mov &0x605A,r14"); 		//R14
    8162:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

00008166 <.Loc.249.1>:
	__asm__ __volatile__ ("mov &0x605C,r15"); 		//R15
    8166:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

0000816a <.Loc.250.1>:
	__asm__ __volatile__ ("mov &0x6042,r1");   		//SP/R1
    816a:	11 42 42 60 	mov	&0x6042,r1	;0x6042

0000816e <.Loc.251.1>:
	__asm__ __volatile__ ("mov &0x6044,r2"); 	    //SR/R2
    816e:	12 42 44 60 	mov	&0x6044,r2	;0x6044

00008172 <.Loc.254.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	__asm__ __volatile__ ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    8172:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008176 <.Loc.257.1>:

	/*Restore program Counter */
	__asm__ __volatile__ ("mov &0x6040, pc"); 	    //PC/R0
    8176:	10 42 40 60 	br	&0x6040		;

0000817a <.Loc.259.1>:

}
    817a:	03 43       	nop			

0000817c <__crt0_init_bss>:
    817c:	3c 40 02 41 	mov	#16642,	r12	;#0x4102

00008180 <.Loc.74.1>:
    8180:	0d 43       	clr	r13		;

00008182 <.Loc.75.1>:
    8182:	3e 40 12 00 	mov	#18,	r14	;#0x0012

00008186 <.Loc.79.1>:
    8186:	b0 12 ea 89 	call	#35306		;#0x89ea

0000818a <__crt0_movedata>:
    818a:	3c 40 00 40 	mov	#16384,	r12	;#0x4000

0000818e <.Loc.116.1>:
    818e:	3d 40 34 8a 	mov	#35380,	r13	;#0x8a34

00008192 <.Loc.119.1>:
    8192:	0d 9c       	cmp	r12,	r13	;

00008194 <.Loc.120.1>:
    8194:	04 24       	jz	$+10     	;abs 0x819e

00008196 <.Loc.122.1>:
    8196:	3e 40 02 01 	mov	#258,	r14	;#0x0102

0000819a <.Loc.124.1>:
    819a:	b0 12 b2 89 	call	#35250		;#0x89b2

0000819e <__crt0_call_init_then_main>:
    819e:	b0 12 18 8a 	call	#35352		;#0x8a18

000081a2 <.Loc.196.1>:
    81a2:	0c 43       	clr	r12		;

000081a4 <.Loc.197.1>:
    81a4:	b0 12 b6 86 	call	#34486		;#0x86b6

000081a8 <_msp430_run_init_array>:
    81a8:	34 40 04 80 	mov	#32772,	r4	;#0x8004

000081ac <.Loc.224.1>:
    81ac:	35 40 04 80 	mov	#32772,	r5	;#0x8004

000081b0 <.Loc.225.1>:
    81b0:	26 43       	mov	#2,	r6	;r3 As==10

000081b2 <.Loc.226.1>:
    81b2:	30 40 d4 81 	br	#0x81d4		;

000081b6 <_msp430_run_preinit_array>:
    81b6:	34 40 04 80 	mov	#32772,	r4	;#0x8004

000081ba <.Loc.232.1>:
    81ba:	35 40 04 80 	mov	#32772,	r5	;#0x8004

000081be <.Loc.233.1>:
    81be:	26 43       	mov	#2,	r6	;r3 As==10

000081c0 <.Loc.234.1>:
    81c0:	30 40 d4 81 	br	#0x81d4		;

000081c4 <_msp430_run_fini_array>:
    81c4:	34 40 04 80 	mov	#32772,	r4	;#0x8004

000081c8 <.Loc.240.1>:
    81c8:	35 40 04 80 	mov	#32772,	r5	;#0x8004

000081cc <.Loc.241.1>:
    81cc:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe

000081d0 <.Loc.242.1>:
    81d0:	30 40 d4 81 	br	#0x81d4		;

000081d4 <_msp430_run_array>:
    81d4:	05 94       	cmp	r4,	r5	;

000081d6 <.Loc.246.1>:
    81d6:	05 24       	jz	$+12     	;abs 0x81e2

000081d8 <.Loc.247.1>:
    81d8:	27 44       	mov	@r4,	r7	;

000081da <.Loc.248.1>:
    81da:	04 56       	add	r6,	r4	;

000081dc <.Loc.249.1>:
    81dc:	a7 12       	call	@r7		;

000081de <.Loc.250.1>:
    81de:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x81d4

000081e2 <_msp430_run_done>:
    81e2:	30 41       	ret			

000081e4 <deregister_tm_clones>:
    81e4:	3c 40 34 8a 	mov	#35380,	r12	;#0x8a34
    81e8:	3c 90 34 8a 	cmp	#35380,	r12	;#0x8a34
    81ec:	07 24       	jz	$+16     	;abs 0x81fc
    81ee:	3d 40 00 00 	mov	#0,	r13	;
    81f2:	0d 93       	cmp	#0,	r13	;r3 As==00
    81f4:	03 24       	jz	$+8      	;abs 0x81fc
    81f6:	3c 40 34 8a 	mov	#35380,	r12	;#0x8a34
    81fa:	8d 12       	call	r13		;

000081fc <.L1>:
    81fc:	30 41       	ret			

000081fe <register_tm_clones>:
    81fe:	0a 12       	push	r10		;
    8200:	3a 40 34 8a 	mov	#35380,	r10	;#0x8a34
    8204:	3a 80 34 8a 	sub	#35380,	r10	;#0x8a34
    8208:	0a 11       	rra	r10		;
    820a:	0c 4a       	mov	r10,	r12	;
    820c:	b0 12 fe 88 	call	#35070		;#0x88fe
    8210:	0c 5a       	add	r10,	r12	;
    8212:	0d 4c       	mov	r12,	r13	;
    8214:	0d 11       	rra	r13		;
    8216:	0d 93       	cmp	#0,	r13	;r3 As==00
    8218:	07 24       	jz	$+16     	;abs 0x8228
    821a:	3e 40 00 00 	mov	#0,	r14	;
    821e:	0e 93       	cmp	#0,	r14	;r3 As==00
    8220:	03 24       	jz	$+8      	;abs 0x8228
    8222:	3c 40 34 8a 	mov	#35380,	r12	;#0x8a34
    8226:	8e 12       	call	r14		;

00008228 <.L9>:
    8228:	3a 41       	pop	r10		;
    822a:	30 41       	ret			

0000822c <__do_global_dtors_aux>:
    822c:	0a 12       	push	r10		;
    822e:	09 12       	push	r9		;
    8230:	c2 93 02 41 	cmp.b	#0,	&0x4102	;r3 As==00
    8234:	17 20       	jnz	$+48     	;abs 0x8264
    8236:	3a 40 0e 80 	mov	#32782,	r10	;#0x800e
    823a:	3a 80 0c 80 	sub	#32780,	r10	;#0x800c
    823e:	0a 11       	rra	r10		;
    8240:	3a 53       	add	#-1,	r10	;r3 As==11
    8242:	39 40 0c 80 	mov	#32780,	r9	;#0x800c

00008246 <.L19>:
    8246:	1c 42 04 41 	mov	&0x4104,r12	;0x4104
    824a:	0c 9a       	cmp	r10,	r12	;
    824c:	0d 28       	jnc	$+28     	;abs 0x8268
    824e:	b0 12 e4 81 	call	#33252		;#0x81e4
    8252:	3d 40 00 00 	mov	#0,	r13	;
    8256:	0d 93       	cmp	#0,	r13	;r3 As==00
    8258:	03 24       	jz	$+8      	;abs 0x8260
    825a:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    825e:	8d 12       	call	r13		;

00008260 <.L21>:
    8260:	d2 43 02 41 	mov.b	#1,	&0x4102	;r3 As==01

00008264 <.L17>:
    8264:	30 40 f8 88 	br	#0x88f8		;

00008268 <.L20>:
    8268:	1c 53       	inc	r12		;
    826a:	82 4c 04 41 	mov	r12,	&0x4104	;
    826e:	0c 5c       	rla	r12		;
    8270:	0c 59       	add	r9,	r12	;
    8272:	2c 4c       	mov	@r12,	r12	;
    8274:	8c 12       	call	r12		;
    8276:	30 40 46 82 	br	#0x8246		;

0000827a <frame_dummy>:
    827a:	3e 40 00 00 	mov	#0,	r14	;
    827e:	0e 93       	cmp	#0,	r14	;r3 As==00
    8280:	05 24       	jz	$+12     	;abs 0x828c
    8282:	3d 40 06 41 	mov	#16646,	r13	;#0x4106
    8286:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    828a:	8e 12       	call	r14		;

0000828c <.L27>:
    828c:	b0 12 fe 81 	call	#33278		;#0x81fe
    8290:	30 41       	ret			

00008292 <btbl_bitcnt>:
      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8   /* 240 - 255 */
};


int btbl_bitcnt(uint32_t x)
{
    8292:	31 80 06 00 	sub	#6,	r1	;

00008296 <.LCFI0>:
    8296:	81 4c 00 00 	mov	r12,	0(r1)	;
    829a:	81 4d 02 00 	mov	r13,	2(r1)	;

0000829e <.Loc.42.1>:
      int cnt = bits[ ((char *)&x)[0] & 0xFF ];
    829e:	0c 41       	mov	r1,	r12	;
    82a0:	6c 4c       	mov.b	@r12,	r12	;
    82a2:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    82a6:	81 4c 04 00 	mov	r12,	4(r1)	;

000082aa <.Loc.44.1>:

      if (0L != (x >>= 8))
    82aa:	2c 41       	mov	@r1,	r12	;
    82ac:	1d 41 02 00 	mov	2(r1),	r13	;
    82b0:	b0 12 72 89 	call	#35186		;#0x8972
    82b4:	81 4c 00 00 	mov	r12,	0(r1)	;
    82b8:	81 4d 02 00 	mov	r13,	2(r1)	;
    82bc:	2d 41       	mov	@r1,	r13	;
    82be:	1e 41 02 00 	mov	2(r1),	r14	;
    82c2:	0c 4d       	mov	r13,	r12	;
    82c4:	0c de       	bis	r14,	r12	;
    82c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    82c8:	07 24       	jz	$+16     	;abs 0x82d8

000082ca <.Loc.45.1>:
            cnt += btbl_bitcnt(x);
    82ca:	2c 41       	mov	@r1,	r12	;
    82cc:	1d 41 02 00 	mov	2(r1),	r13	;
    82d0:	b0 12 92 82 	call	#33426		;#0x8292
    82d4:	81 5c 04 00 	add	r12,	4(r1)	;

000082d8 <.L2>:
      return cnt;
    82d8:	1c 41 04 00 	mov	4(r1),	r12	;

000082dc <.Loc.47.1>:
}
    82dc:	31 50 06 00 	add	#6,	r1	;
    82e0:	30 41       	ret			

000082e2 <bit_count>:
int bit_count(uint32_t x)
{
    82e2:	31 80 06 00 	sub	#6,	r1	;

000082e6 <.LCFI1>:
    82e6:	81 4c 00 00 	mov	r12,	0(r1)	;
    82ea:	81 4d 02 00 	mov	r13,	2(r1)	;

000082ee <.Loc.50.1>:
        int n = 0;
    82ee:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

000082f2 <.Loc.52.1>:

        if (x) do
    82f2:	2c 41       	mov	@r1,	r12	;
    82f4:	1c d1 02 00 	bis	2(r1),	r12	;
    82f8:	0c 93       	cmp	#0,	r12	;r3 As==00
    82fa:	10 24       	jz	$+34     	;abs 0x831c

000082fc <.L8>:
              n++;
    82fc:	91 53 04 00 	inc	4(r1)		;

00008300 <.Loc.54.1>:
        while (0 != (x = x&(x-1))) ;
    8300:	2e 41       	mov	@r1,	r14	;
    8302:	3e 53       	add	#-1,	r14	;r3 As==11
    8304:	1f 41 02 00 	mov	2(r1),	r15	;
    8308:	3f 63       	addc	#-1,	r15	;r3 As==11
    830a:	81 fe 00 00 	and	r14,	0(r1)	;
    830e:	81 ff 02 00 	and	r15,	2(r1)	;
    8312:	2c 41       	mov	@r1,	r12	;
    8314:	1c d1 02 00 	bis	2(r1),	r12	;
    8318:	0c 93       	cmp	#0,	r12	;r3 As==00
    831a:	f0 23       	jnz	$-30     	;abs 0x82fc

0000831c <.L6>:
        return(n);
    831c:	1c 41 04 00 	mov	4(r1),	r12	;

00008320 <.Loc.56.1>:
}
    8320:	31 50 06 00 	add	#6,	r1	;
    8324:	30 41       	ret			

00008326 <bitcount>:
int bitcount(uint32_t i)
{
    8326:	0a 12       	push	r10		;

00008328 <.LCFI2>:
    8328:	09 12       	push	r9		;

0000832a <.LCFI3>:
    832a:	08 12       	push	r8		;

0000832c <.LCFI4>:
    832c:	07 12       	push	r7		;

0000832e <.LCFI5>:
    832e:	06 12       	push	r6		;

00008330 <.LCFI6>:
    8330:	05 12       	push	r5		;

00008332 <.LCFI7>:
    8332:	04 12       	push	r4		;

00008334 <.LCFI8>:
    8334:	31 80 14 00 	sub	#20,	r1	;#0x0014

00008338 <.LCFI9>:
    8338:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    833c:	81 4d 12 00 	mov	r13,	18(r1)	; 0x0012

00008340 <.Loc.59.1>:
      i = ((i & 0xAAAAAAAAL) >>  1) + (i & 0x55555555L);
    8340:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8344:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8348:	12 c3       	clrc			
    834a:	0d 10       	rrc	r13		;
    834c:	0c 10       	rrc	r12		;
    834e:	0a 4c       	mov	r12,	r10	;
    8350:	3a f0 55 55 	and	#21845,	r10	;#0x5555
    8354:	0b 4d       	mov	r13,	r11	;
    8356:	3b f0 55 55 	and	#21845,	r11	;#0x5555
    835a:	1e 41 10 00 	mov	16(r1),	r14	;0x00010
    835e:	3e f0 55 55 	and	#21845,	r14	;#0x5555
    8362:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    8366:	3f f0 55 55 	and	#21845,	r15	;#0x5555
    836a:	0c 4a       	mov	r10,	r12	;
    836c:	0c 5e       	add	r14,	r12	;
    836e:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    8372:	0c 4b       	mov	r11,	r12	;
    8374:	0c 6f       	addc	r15,	r12	;
    8376:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012

0000837a <.Loc.60.1>:
      i = ((i & 0xCCCCCCCCL) >>  2) + (i & 0x33333333L);
    837a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    837e:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8382:	b0 12 96 89 	call	#35222		;#0x8996
    8386:	0e 4c       	mov	r12,	r14	;
    8388:	3e f0 33 33 	and	#13107,	r14	;#0x3333
    838c:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    8390:	0e 4d       	mov	r13,	r14	;
    8392:	3e f0 33 33 	and	#13107,	r14	;#0x3333
    8396:	81 4e 0e 00 	mov	r14,	14(r1)	; 0x000e
    839a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    839e:	3c f0 33 33 	and	#13107,	r12	;#0x3333
    83a2:	81 4c 08 00 	mov	r12,	8(r1)	;
    83a6:	1e 41 12 00 	mov	18(r1),	r14	;0x00012
    83aa:	3e f0 33 33 	and	#13107,	r14	;#0x3333
    83ae:	81 4e 0a 00 	mov	r14,	10(r1)	; 0x000a
    83b2:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    83b6:	1c 51 08 00 	add	8(r1),	r12	;
    83ba:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    83be:	1e 41 0e 00 	mov	14(r1),	r14	;0x0000e
    83c2:	1e 61 0a 00 	addc	10(r1),	r14	;0x0000a
    83c6:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

000083ca <.Loc.61.1>:
      i = ((i & 0xF0F0F0F0L) >>  4) + (i & 0x0F0F0F0FL);
    83ca:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    83ce:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    83d2:	b0 12 8a 89 	call	#35210		;#0x898a
    83d6:	0e 4c       	mov	r12,	r14	;
    83d8:	3e f0 0f 0f 	and	#3855,	r14	;#0x0f0f
    83dc:	81 4e 04 00 	mov	r14,	4(r1)	;
    83e0:	0e 4d       	mov	r13,	r14	;
    83e2:	3e f0 0f 0f 	and	#3855,	r14	;#0x0f0f
    83e6:	81 4e 06 00 	mov	r14,	6(r1)	;
    83ea:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    83ee:	3c f0 0f 0f 	and	#3855,	r12	;#0x0f0f
    83f2:	81 4c 00 00 	mov	r12,	0(r1)	;
    83f6:	1e 41 12 00 	mov	18(r1),	r14	;0x00012
    83fa:	3e f0 0f 0f 	and	#3855,	r14	;#0x0f0f
    83fe:	81 4e 02 00 	mov	r14,	2(r1)	;
    8402:	1c 41 04 00 	mov	4(r1),	r12	;
    8406:	2c 51       	add	@r1,	r12	;
    8408:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    840c:	1e 41 06 00 	mov	6(r1),	r14	;
    8410:	1e 61 02 00 	addc	2(r1),	r14	;
    8414:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

00008418 <.Loc.62.1>:
      i = ((i & 0xFF00FF00L) >>  8) + (i & 0x00FF00FFL);
    8418:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    841c:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8420:	b0 12 72 89 	call	#35186		;#0x8972
    8424:	04 4c       	mov	r12,	r4	;
    8426:	74 f0 ff 00 	and.b	#255,	r4	;#0x00ff
    842a:	05 4d       	mov	r13,	r5	;
    842c:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff
    8430:	16 41 10 00 	mov	16(r1),	r6	;0x00010
    8434:	76 f0 ff 00 	and.b	#255,	r6	;#0x00ff
    8438:	17 41 12 00 	mov	18(r1),	r7	;0x00012
    843c:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff
    8440:	0c 44       	mov	r4,	r12	;
    8442:	0c 56       	add	r6,	r12	;
    8444:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    8448:	0e 45       	mov	r5,	r14	;
    844a:	0e 67       	addc	r7,	r14	;
    844c:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

00008450 <.Loc.63.1>:
      i = ((i & 0xFFFF0000L) >> 16) + (i & 0x0000FFFFL);
    8450:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8454:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8458:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    845c:	4f 43       	clr.b	r15		;
    845e:	b0 12 ac 89 	call	#35244		;#0x89ac
    8462:	18 41 10 00 	mov	16(r1),	r8	;0x00010
    8466:	08 c3       	bic	#0,	r8	;r3 As==00
    8468:	19 41 12 00 	mov	18(r1),	r9	;0x00012
    846c:	39 c3       	bic	#-1,	r9	;r3 As==11
    846e:	0e 4c       	mov	r12,	r14	;
    8470:	0e 58       	add	r8,	r14	;
    8472:	81 4e 10 00 	mov	r14,	16(r1)	; 0x0010
    8476:	0e 4d       	mov	r13,	r14	;
    8478:	0e 69       	addc	r9,	r14	;
    847a:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

0000847e <.Loc.64.1>:
      return (int)i;
    847e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010

00008482 <.Loc.65.1>:
}
    8482:	31 50 14 00 	add	#20,	r1	;#0x0014
    8486:	30 40 ee 88 	br	#0x88ee		;

0000848a <ntbl_bitcount>:
int ntbl_bitcount(uint32_t x)
{
    848a:	0a 12       	push	r10		;

0000848c <.LCFI10>:
    848c:	21 82       	sub	#4,	r1	;r2 As==10

0000848e <.LCFI11>:
    848e:	81 4c 00 00 	mov	r12,	0(r1)	;
    8492:	81 4d 02 00 	mov	r13,	2(r1)	;

00008496 <.Loc.69.1>:
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
    8496:	2c 41       	mov	@r1,	r12	;
    8498:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    849c:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    84a0:	0a 4c       	mov	r12,	r10	;

000084a2 <.Loc.70.1>:
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
    84a2:	2c 41       	mov	@r1,	r12	;
    84a4:	1d 41 02 00 	mov	2(r1),	r13	;
    84a8:	b0 12 8a 89 	call	#35210		;#0x898a
    84ac:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84b0:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

000084b4 <.Loc.69.1>:
      return (int)i;
}
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
    84b4:	0a 5c       	add	r12,	r10	;

000084b6 <.Loc.71.1>:
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
    84b6:	2c 41       	mov	@r1,	r12	;
    84b8:	1d 41 02 00 	mov	2(r1),	r13	;
    84bc:	b0 12 72 89 	call	#35186		;#0x8972
    84c0:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84c4:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

000084c8 <.Loc.70.1>:
}
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
    84c8:	0a 5c       	add	r12,	r10	;

000084ca <.Loc.72.1>:
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
    84ca:	2c 41       	mov	@r1,	r12	;
    84cc:	1d 41 02 00 	mov	2(r1),	r13	;
    84d0:	b0 12 5a 89 	call	#35162		;#0x895a
    84d4:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84d8:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

000084dc <.Loc.71.1>:
int ntbl_bitcount(uint32_t x)
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
    84dc:	0a 5c       	add	r12,	r10	;

000084de <.Loc.73.1>:
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
    84de:	2c 41       	mov	@r1,	r12	;
    84e0:	1d 41 02 00 	mov	2(r1),	r13	;
    84e4:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    84e8:	4f 43       	clr.b	r15		;
    84ea:	b0 12 ac 89 	call	#35244		;#0x89ac
    84ee:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84f2:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

000084f6 <.Loc.72.1>:
{
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
    84f6:	0a 5c       	add	r12,	r10	;

000084f8 <.Loc.74.1>:
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
    84f8:	2c 41       	mov	@r1,	r12	;
    84fa:	1d 41 02 00 	mov	2(r1),	r13	;
    84fe:	7e 40 14 00 	mov.b	#20,	r14	;#0x0014
    8502:	4f 43       	clr.b	r15		;
    8504:	b0 12 ac 89 	call	#35244		;#0x89ac
    8508:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    850c:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

00008510 <.Loc.73.1>:
      return
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
    8510:	0a 5c       	add	r12,	r10	;

00008512 <.Loc.75.1>:
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
    8512:	2c 41       	mov	@r1,	r12	;
    8514:	1d 41 02 00 	mov	2(r1),	r13	;
    8518:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    851c:	4f 43       	clr.b	r15		;
    851e:	b0 12 ac 89 	call	#35244		;#0x89ac
    8522:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    8526:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

0000852a <.Loc.74.1>:
            bits[ (int) (x & 0x0000000FUL)       ] +
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
    852a:	0a 5c       	add	r12,	r10	;

0000852c <.Loc.76.1>:
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
            bits[ (int)((x & 0xF0000000UL) >> 28)];
    852c:	2c 41       	mov	@r1,	r12	;
    852e:	1d 41 02 00 	mov	2(r1),	r13	;
    8532:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    8536:	4f 43       	clr.b	r15		;
    8538:	b0 12 ac 89 	call	#35244		;#0x89ac
    853c:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

00008540 <.Loc.75.1>:
            bits[ (int)((x & 0x000000F0UL) >> 4) ] +
            bits[ (int)((x & 0x00000F00UL) >> 8) ] +
            bits[ (int)((x & 0x0000F000UL) >> 12)] +
            bits[ (int)((x & 0x000F0000UL) >> 16)] +
            bits[ (int)((x & 0x00F00000UL) >> 20)] +
            bits[ (int)((x & 0x0F000000UL) >> 24)] +
    8540:	0c 5a       	add	r10,	r12	;

00008542 <.Loc.77.1>:
            bits[ (int)((x & 0xF0000000UL) >> 28)];
}
    8542:	21 52       	add	#4,	r1	;r2 As==10
    8544:	3a 41       	pop	r10		;
    8546:	30 41       	ret			

00008548 <BW_btbl_bitcount>:
int BW_btbl_bitcount(uint32_t x)
{
    8548:	31 82       	sub	#8,	r1	;r2 As==11

0000854a <.LCFI12>:
    854a:	81 4c 00 00 	mov	r12,	0(r1)	;
    854e:	81 4d 02 00 	mov	r13,	2(r1)	;

00008552 <.Loc.86.1>:
      {
            unsigned char ch[4];
            long y;
      } U;

      U.y = x;
    8552:	2c 41       	mov	@r1,	r12	;
    8554:	1d 41 02 00 	mov	2(r1),	r13	;
    8558:	81 4c 04 00 	mov	r12,	4(r1)	;
    855c:	81 4d 06 00 	mov	r13,	6(r1)	;

00008560 <.Loc.88.1>:

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    8560:	5c 41 04 00 	mov.b	4(r1),	r12	;
    8564:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    8568:	0d 4c       	mov	r12,	r13	;
    856a:	5c 41 05 00 	mov.b	5(r1),	r12	;
    856e:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    8572:	0d 5c       	add	r12,	r13	;

00008574 <.Loc.89.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    8574:	5c 41 07 00 	mov.b	7(r1),	r12	;
    8578:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000

0000857c <.Loc.88.1>:
            long y;
      } U;

      U.y = x;

      return bits[ U.ch[0] ] + bits[ U.ch[1] ] +
    857c:	0d 5c       	add	r12,	r13	;

0000857e <.Loc.89.1>:
             bits[ U.ch[3] ] + bits[ U.ch[2] ];
    857e:	5c 41 06 00 	mov.b	6(r1),	r12	;
    8582:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    8586:	0c 5d       	add	r13,	r12	;

00008588 <.Loc.90.1>:
}
    8588:	31 52       	add	#8,	r1	;r2 As==11
    858a:	30 41       	ret			

0000858c <AR_btbl_bitcount>:
int AR_btbl_bitcount(uint32_t x)
{
    858c:	31 82       	sub	#8,	r1	;r2 As==11

0000858e <.LCFI13>:
    858e:	81 4c 00 00 	mov	r12,	0(r1)	;
    8592:	81 4d 02 00 	mov	r13,	2(r1)	;

00008596 <.Loc.93.1>:
      unsigned char * Ptr = (unsigned char *) &x ;
    8596:	7c 42       	mov.b	#8,	r12	;r2 As==11
    8598:	0c 51       	add	r1,	r12	;
    859a:	3c 50 f8 ff 	add	#65528,	r12	;#0xfff8
    859e:	81 4c 06 00 	mov	r12,	6(r1)	;

000085a2 <.Loc.96.1>:
      int Accu ;

      Accu  = bits[ *Ptr++ ];
    85a2:	1c 41 06 00 	mov	6(r1),	r12	;
    85a6:	0d 4c       	mov	r12,	r13	;
    85a8:	1d 53       	inc	r13		;
    85aa:	81 4d 06 00 	mov	r13,	6(r1)	;
    85ae:	6c 4c       	mov.b	@r12,	r12	;
    85b0:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    85b4:	81 4c 04 00 	mov	r12,	4(r1)	;

000085b8 <.Loc.97.1>:
      Accu += bits[ *Ptr++ ];
    85b8:	1c 41 06 00 	mov	6(r1),	r12	;
    85bc:	0d 4c       	mov	r12,	r13	;
    85be:	1d 53       	inc	r13		;
    85c0:	81 4d 06 00 	mov	r13,	6(r1)	;
    85c4:	6c 4c       	mov.b	@r12,	r12	;
    85c6:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    85ca:	81 5c 04 00 	add	r12,	4(r1)	;

000085ce <.Loc.98.1>:
      Accu += bits[ *Ptr++ ];
    85ce:	1c 41 06 00 	mov	6(r1),	r12	;
    85d2:	0d 4c       	mov	r12,	r13	;
    85d4:	1d 53       	inc	r13		;
    85d6:	81 4d 06 00 	mov	r13,	6(r1)	;
    85da:	6c 4c       	mov.b	@r12,	r12	;
    85dc:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    85e0:	81 5c 04 00 	add	r12,	4(r1)	;

000085e4 <.Loc.99.1>:
      Accu += bits[ *Ptr ];
    85e4:	1c 41 06 00 	mov	6(r1),	r12	;
    85e8:	6c 4c       	mov.b	@r12,	r12	;
    85ea:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    85ee:	81 5c 04 00 	add	r12,	4(r1)	;

000085f2 <.Loc.100.1>:
      return Accu;
    85f2:	1c 41 04 00 	mov	4(r1),	r12	;

000085f6 <.Loc.101.1>:
}
    85f6:	31 52       	add	#8,	r1	;r2 As==11
    85f8:	30 41       	ret			

000085fa <ntbl_bitcnt>:
int ntbl_bitcnt(uint32_t x)
{
    85fa:	31 80 06 00 	sub	#6,	r1	;

000085fe <.LCFI14>:
    85fe:	81 4c 00 00 	mov	r12,	0(r1)	;
    8602:	81 4d 02 00 	mov	r13,	2(r1)	;

00008606 <.Loc.104.1>:
      int cnt = bits[(int)(x & 0x0000000FL)];
    8606:	2c 41       	mov	@r1,	r12	;
    8608:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    860c:	5c 4c 00 40 	mov.b	16384(r12),r12	;0x04000
    8610:	81 4c 04 00 	mov	r12,	4(r1)	;

00008614 <.Loc.106.1>:

      if (0L != (x >>= 4))
    8614:	2c 41       	mov	@r1,	r12	;
    8616:	1d 41 02 00 	mov	2(r1),	r13	;
    861a:	b0 12 8a 89 	call	#35210		;#0x898a
    861e:	81 4c 00 00 	mov	r12,	0(r1)	;
    8622:	81 4d 02 00 	mov	r13,	2(r1)	;
    8626:	2c 41       	mov	@r1,	r12	;
    8628:	1c d1 02 00 	bis	2(r1),	r12	;
    862c:	0c 93       	cmp	#0,	r12	;r3 As==00
    862e:	07 24       	jz	$+16     	;abs 0x863e

00008630 <.Loc.107.1>:
            cnt += ntbl_bitcnt(x);
    8630:	2c 41       	mov	@r1,	r12	;
    8632:	1d 41 02 00 	mov	2(r1),	r13	;
    8636:	b0 12 fa 85 	call	#34298		;#0x85fa
    863a:	81 5c 04 00 	add	r12,	4(r1)	;

0000863e <.L19>:

      return cnt;
    863e:	1c 41 04 00 	mov	4(r1),	r12	;

00008642 <.Loc.110.1>:
}
    8642:	31 50 06 00 	add	#6,	r1	;
    8646:	30 41       	ret			

00008648 <bit_shifter>:

static int bit_shifter(uint32_t x)
{
    8648:	31 82       	sub	#8,	r1	;r2 As==11

0000864a <.LCFI15>:
    864a:	81 4c 00 00 	mov	r12,	0(r1)	;
    864e:	81 4d 02 00 	mov	r13,	2(r1)	;

00008652 <.Loc.115.1>:
  int i, n;
  for (i = n = 0; x && (i < (sizeof(uint32_t) * CHAR_BIT)); ++i, x >>= 1)
    8652:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    8656:	91 41 04 00 	mov	4(r1),	6(r1)	;
    865a:	06 00 
    865c:	30 40 74 86 	br	#0x8674		;

00008660 <.L26>:
    n += (int)(x & 1L);
    8660:	2c 41       	mov	@r1,	r12	;
    8662:	5c f3       	and.b	#1,	r12	;r3 As==01
    8664:	81 5c 04 00 	add	r12,	4(r1)	;

00008668 <.Loc.115.1>:
}

static int bit_shifter(uint32_t x)
{
  int i, n;
  for (i = n = 0; x && (i < (sizeof(uint32_t) * CHAR_BIT)); ++i, x >>= 1)
    8668:	91 53 06 00 	inc	6(r1)		;
    866c:	12 c3       	clrc			
    866e:	11 10 02 00 	rrc	2(r1)		;
    8672:	21 10       	rrc	@r1		;

00008674 <.L23>:
    8674:	2c 41       	mov	@r1,	r12	;
    8676:	1c d1 02 00 	bis	2(r1),	r12	;
    867a:	0c 93       	cmp	#0,	r12	;r3 As==00
    867c:	06 24       	jz	$+14     	;abs 0x868a
    867e:	1d 41 06 00 	mov	6(r1),	r13	;
    8682:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    8686:	0c 9d       	cmp	r13,	r12	;
    8688:	eb 2f       	jc	$-40     	;abs 0x8660

0000868a <.L24>:
    n += (int)(x & 1L);
  return n;
    868a:	1c 41 04 00 	mov	4(r1),	r12	;

0000868e <.Loc.118.1>:
}
    868e:	31 52       	add	#8,	r1	;r2 As==11
    8690:	30 41       	ret			

00008692 <init>:


void init()
{
     WDTCTL = WDTPW | WDTHOLD; // Stop WDT
    8692:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    8696:	bc 40 80 5a 	mov	#23168,	0(r12)	;#0x5a80
    869a:	00 00 

0000869c <.Loc.124.1>:
  	 __asm__ __volatile__ ("nop");
    869c:	03 43       	nop			

0000869e <.Loc.125.1>:
     eint();
    869e:	32 d2       	eint			
    86a0:	03 43       	nop			

000086a2 <.Loc.126.1>:
 	 UART_BAUD = BAUD;                   // Init UART
    86a2:	7c 40 82 00 	mov.b	#130,	r12	;#0x0082
    86a6:	bc 42 00 00 	mov	#8,	0(r12)	;r2 As==11

000086aa <.Loc.127.1>:
     UART_CTL  = UART_EN;
    86aa:	7c 40 80 00 	mov.b	#128,	r12	;#0x0080
    86ae:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000086b2 <.Loc.130.1>:
     //Enable QWARK
     //QWARK_CTL = QWARK_EN;
}
    86b2:	03 43       	nop			
    86b4:	30 41       	ret			

000086b6 <main>:



int main()
{
	init();
    86b6:	b0 12 92 86 	call	#34450		;#0x8692

000086ba <.L30>:
	while(1);
    86ba:	30 40 ba 86 	br	#0x86ba		;

000086be <INT_Qwark>:
	//---------------------------------------------------------------------------------------------------------------------------------//
	//    CHECKPOINT SETUP: Identify which of the 2 checkpoint buffers should be written, one should always be consistent		   //
	//	  W.C. 18 CYCLES  													   //	 
	//	  B.C. 10 CYCLES 													   //
	//---------------------------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov r13, &0x6070"); 		//temporal r13: 4 cycles
    86be:	82 4d 70 60 	mov	r13,	&0x6070	;

000086c2 <.Loc.277.1>:
		__asm__ __volatile__ ("mov r12, &0x6072"); 		//temporal r12: 4 cycles
    86c2:	82 4c 72 60 	mov	r12,	&0x6072	;

000086c6 <.Loc.279.1>:

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075"); 		//4 cycles
    86c6:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

000086ca <.Loc.280.1>:
		__asm__ __volatile__ ("jz __second_buffer_init");	//2 cycles
    86ca:	06 24       	jz	$+14     	;abs 0x86d8

000086cc <.Loc.282.1>:

		__asm__ __volatile__ ("mov #0x6010, r12"); 		//Load the base pointer of the first checkpoint buffer: 2 cycles
    86cc:	3c 40 10 60 	mov	#24592,	r12	;#0x6010

000086d0 <.Loc.283.1>:
		__asm__ __volatile__ ("mov.b #0x01,&0x6074");		//4 cycles
    86d0:	d2 43 74 60 	mov.b	#1,	&0x6074	;r3 As==01

000086d4 <.Loc.284.1>:
		__asm__ __volatile__ ("br #__first_phase_commit");	//2 cycles
    86d4:	30 40 dc 86 	br	#0x86dc		;

000086d8 <__second_buffer_init>:

		__asm__ __volatile__ ("__second_buffer_init:");

		__asm__ __volatile__ ("mov #0x6040, r12"); 		//Load the base pointer of the second checkpoint buffer: 2 cycles
    86d8:	3c 40 40 60 	mov	#24640,	r12	;#0x6040

000086dc <__first_phase_commit>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 2(r1),@r12"); 	//PC/R0   6 cycles
    86dc:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    86e0:	00 00 

000086e2 <.Loc.307.1>:
		__asm__ __volatile__ ("incd r12");		//	  1 cycle
    86e2:	2c 53       	incd	r12		;

000086e4 <.Loc.313.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark  - 3 cycles
		//__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles	

		__asm__ __volatile__ ("mov r1,@r12");   	//SP/R1   4 cycles
    86e4:	8c 41 00 00 	mov	r1,	0(r12)	;

000086e8 <.Loc.314.1>:
		__asm__ __volatile__ ("add #0x04,@r12");	//	  5 cycles
    86e8:	ac 52 00 00 	add	#4,	0(r12)	;r2 As==10

000086ec <.Loc.315.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    86ec:	2c 53       	incd	r12		;

000086ee <.Loc.321.1>:

		//__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Re-enable Qwark without modifying the data 3 cycles
		//__asm__ __volatile__ ("bis #0x01,r13"); 	//	  2 cycles
		//__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles

		__asm__ __volatile__ ("mov 0(r1),@r12"); 	//SR/R2   6 cycles
    86ee:	ac 41 00 00 	mov	@r1,	0(r12)	;

000086f2 <.Loc.322.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    86f2:	2c 53       	incd	r12		;

000086f4 <.Loc.324.1>:

		__asm__ __volatile__ ("mov &0x02A0,r13"); 	//Disable Qwark and signal a buffer reset without modifying the data - 3 cycles
    86f4:	1d 42 a0 02 	mov	&0x02a0,r13	;0x02a0

000086f8 <.Loc.325.1>:
		__asm__ __volatile__ ("and #0x3E,r13"); 	//	  2 cycles
    86f8:	3d f0 3e 00 	and	#62,	r13	;#0x003e

000086fc <.Loc.326.1>:
		__asm__ __volatile__ ("bis #0x40,r13"); 	//	  2 cycles
    86fc:	3d d0 40 00 	bis	#64,	r13	;#0x0040

00008700 <.Loc.327.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    8700:	82 4d a0 02 	mov	r13,	&0x02a0	;

00008704 <.Loc.328.1>:
		__asm__ __volatile__ ("and #0xBF,r13"); 	//	  2 cycles
    8704:	3d f0 bf 00 	and	#191,	r13	;#0x00bf

00008708 <.Loc.329.1>:
		__asm__ __volatile__ ("mov r13,&0x02A0");	//	  4 cycles		
    8708:	82 4d a0 02 	mov	r13,	&0x02a0	;

0000870c <.Loc.331.1>:

		__asm__ __volatile__ ("mov r4,@r12"); 		//R4	  4 cycles
    870c:	8c 44 00 00 	mov	r4,	0(r12)	;

00008710 <.Loc.332.1>:
		__asm__ __volatile__ ("incd r12");		// 	  1 cycle
    8710:	2c 53       	incd	r12		;

00008712 <.Loc.334.1>:

		__asm__ __volatile__ ("mov r5,@r12"); 		//R5	  4 cycles
    8712:	8c 45 00 00 	mov	r5,	0(r12)	;

00008716 <.Loc.335.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    8716:	2c 53       	incd	r12		;

00008718 <.Loc.337.1>:

		__asm__ __volatile__ ("mov r6,@r12"); 		//R6	  4 cycles
    8718:	8c 46 00 00 	mov	r6,	0(r12)	;

0000871c <.Loc.338.1>:
		__asm__ __volatile__ ("incd r12");		// 		  1 cycle
    871c:	2c 53       	incd	r12		;

0000871e <.Loc.340.1>:

		__asm__ __volatile__ ("mov r7,@r12"); 		//R7	  4 cycles
    871e:	8c 47 00 00 	mov	r7,	0(r12)	;

00008722 <.Loc.341.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8722:	2c 53       	incd	r12		;

00008724 <.Loc.343.1>:

		__asm__ __volatile__ ("mov r8,@r12"); 		//R8	  4 cycles
    8724:	8c 48 00 00 	mov	r8,	0(r12)	;

00008728 <.Loc.344.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8728:	2c 53       	incd	r12		;

0000872a <.Loc.346.1>:

		__asm__ __volatile__ ("mov r9,@r12"); 		//R9	  4 cycles
    872a:	8c 49 00 00 	mov	r9,	0(r12)	;

0000872e <.Loc.347.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    872e:	2c 53       	incd	r12		;

00008730 <.Loc.349.1>:

		__asm__ __volatile__ ("mov r10,@r12"); 		//R10	  4 cycles
    8730:	8c 4a 00 00 	mov	r10,	0(r12)	;

00008734 <.Loc.350.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8734:	2c 53       	incd	r12		;

00008736 <.Loc.352.1>:

		__asm__ __volatile__ ("mov r11,@r12"); 		//R11	  4 cycles
    8736:	8c 4b 00 00 	mov	r11,	0(r12)	;

0000873a <.Loc.353.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    873a:	2c 53       	incd	r12		;

0000873c <.Loc.355.1>:

		__asm__ __volatile__ ("mov &0x6072,@r12"); 	//R12	  6 cycles
    873c:	9c 42 72 60 	mov	&0x6072,0(r12)	;0x6072
    8740:	00 00 

00008742 <.Loc.356.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8742:	2c 53       	incd	r12		;

00008744 <.Loc.358.1>:

		__asm__ __volatile__ ("mov &0x6070,@r12"); 	//R13	  4 cycles
    8744:	9c 42 70 60 	mov	&0x6070,0(r12)	;0x6070
    8748:	00 00 

0000874a <.Loc.359.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    874a:	2c 53       	incd	r12		;

0000874c <.Loc.361.1>:

		__asm__ __volatile__ ("mov r14,@r12"); 		//R14	  4 cycles
    874c:	8c 4e 00 00 	mov	r14,	0(r12)	;

00008750 <.Loc.362.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8750:	2c 53       	incd	r12		;

00008752 <.Loc.364.1>:

		__asm__ __volatile__ ("mov r15,@r12"); 		//R15	  4 cycles
    8752:	8c 4f 00 00 	mov	r15,	0(r12)	;

00008756 <.Loc.365.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 cycle
    8756:	2c 53       	incd	r12		;

00008758 <.Loc.373.1>:
		//    WAR VIOLATION INDEX CHECKPOINT: Get the index indicating the amount of violations stored 				   //
		//	  10 CYCLES																								   //
		//																											   //
		//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("mov &0x02A0, r14");	// 		  3 cycles
    8758:	1e 42 a0 02 	mov	&0x02a0,r14	;0x02a0

0000875c <.Loc.374.1>:
		__asm__ __volatile__ ("RRA r14");			// 		  1 cycle
    875c:	0e 11       	rra	r14		;

0000875e <.Loc.375.1>:
		__asm__ __volatile__ ("mov.b r14, @r12");	// 		  4 cycles
    875e:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00008762 <.Loc.376.1>:
		__asm__ __volatile__ ("mov r14, r15 ");		// 		  1 cycle (save the index for later)
    8762:	0f 4e       	mov	r14,	r15	;

00008764 <.Loc.377.1>:
		__asm__ __volatile__ ("incd r12");			// 		  1 Cycle
    8764:	2c 53       	incd	r12		;

00008766 <.Loc.387.1>:
		//	  B.C.	 5 CYCLES FOR EMPTY TLB																			   //
		//-------------------------------------------------------------------------------------------------------------//

		/* Setup registers for copy*/

		__asm__ __volatile__ ("tst r14 ");     	    // 		  1 cycle
    8766:	0e 93       	cmp	#0,	r14	;r3 As==00

00008768 <.Loc.388.1>:
		__asm__ __volatile__ ("jz  __second_phase_start");	// 		  2 cycles
    8768:	08 24       	jz	$+18     	;abs 0x877a

0000876a <.Loc.390.1>:

		__asm__ __volatile__ ("mov #0x02A2, r13");	// 		  2 cycles
    876a:	3d 40 a2 02 	mov	#674,	r13	;#0x02a2

0000876e <_scratchpad_addr_cpy>:

		__asm__ __volatile__ ("_scratchpad_addr_cpy:");   // Each iteration takes 10 cycles - Worst case 70 cycles

		__asm__ __volatile__ ("mov @r13+2, @r12");  // 		  5 cycles
    876e:	bc 4d 00 00 	mov	@r13+,	0(r12)	;

00008772 <.Loc.395.1>:
		__asm__ __volatile__ ("incd r12");  		// 		  1 cycle
    8772:	2c 53       	incd	r12		;

00008774 <.Loc.396.1>:
		__asm__ __volatile__ ("dec r14 ");      	// 		  1 cycle
    8774:	1e 83       	dec	r14		;

00008776 <.Loc.397.1>:
		__asm__ __volatile__ ("tst r14 ");     		// 		  1 cycle
    8776:	0e 93       	cmp	#0,	r14	;r3 As==00

00008778 <.Loc.398.1>:
		__asm__ __volatile__ ("jnz  _scratchpad_addr_cpy");// 2 cycles
    8778:	fa 23       	jnz	$-10     	;abs 0x876e

0000877a <__second_phase_start>:
	//    END OF THE FIRST PHASE: Atomic Flag Handling for halfway through checkpoint							   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("__second_phase_start:");

		__asm__ __volatile__ ("cmp.b #0x01,&0x6075");		 // 4 cycles
    877a:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

0000877e <.Loc.446.1>:
		__asm__ __volatile__ ("jz  __set_flag_2nd ");		 // 2 cycles
    877e:	04 24       	jz	$+10     	;abs 0x8788

00008780 <.Loc.448.1>:

		__asm__ __volatile__ ("add.b #0x01, &0x6074 "); 	 //4 cycles
    8780:	d2 53 74 60 	inc.b	&0x6074		;

00008784 <.Loc.449.1>:
		__asm__ __volatile__ ("br  #_second_phase_commit "); //4 cycles
    8784:	30 40 8c 87 	br	#0x878c		;

00008788 <__set_flag_2nd>:

		__asm__ __volatile__ ("__set_flag_2nd:");
		__asm__ __volatile__ ("add.b #0x01, &0x6075 "); 	 // 4 cycles		/* after setting this bit, THE RESTORE ROUTINE CAN FINALIZE THIS HALFWAY CHECKPOINT  */
    8788:	d2 53 75 60 	inc.b	&0x6075		;

0000878c <_second_phase_commit>:
	//	  ASSUMMING ONLY WORD ADDRESSING. 																		   //
	//-------------------------------------------------------------------------------------------------------------//

		__asm__ __volatile__ ("_second_phase_commit:");

		__asm__ __volatile__ ("tst r15 ");     		         // 1 cycle
    878c:	0f 93       	cmp	#0,	r15	;r3 As==00

0000878e <.Loc.463.1>:
		__asm__ __volatile__ ("jz  _chkpt_finished");		 // 2 cycles
    878e:	25 24       	jz	$+76     	;abs 0x87da

00008790 <.Loc.465.1>:

		__asm__ __volatile__ ("mov #0x6000,  r14 ");		 // 2 cycles
    8790:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00008794 <.Loc.467.1>:

		__asm__ __volatile__ ("mov #0x6060,  r12 ");		 // 2 cycles
    8794:	3c 40 60 60 	mov	#24672,	r12	;#0x6060

00008798 <.Loc.468.1>:
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");		 // 4 cycles
    8798:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

0000879c <.Loc.469.1>:
		__asm__ __volatile__ ("jz _second_phase_commit_strt");   // 2 cycles
    879c:	02 24       	jz	$+6      	;abs 0x87a2

0000879e <.Loc.471.1>:

		__asm__ __volatile__ ("mov #0x6030,  r12 ");		 // 2 cycles
    879e:	3c 40 30 60 	mov	#24624,	r12	;#0x6030

000087a2 <_second_phase_commit_strt>:


		__asm__ __volatile__ ("_second_phase_commit_strt:"); 	 // Worst case

		__asm__ __volatile__ ("mov @r12+2,  r13 ");   		 // 3 cycles
    87a2:	3d 4c       	mov	@r12+,	r13	;

000087a4 <.Loc.478.1>:

		__asm__ __volatile__ ("mov r13,  r11 ");   		 // 1 cycle
    87a4:	0b 4d       	mov	r13,	r11	;

000087a6 <.Loc.480.1>:

		__asm__ __volatile__ ("and #0x8000,  r11 ");   		 // 2 cycles
    87a6:	3b f0 00 80 	and	#32768,	r11	;#0x8000

000087aa <.Loc.481.1>:
		__asm__ __volatile__ ("cmp #0x8000,  r11 ");   		 // 2 cycles
    87aa:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

000087ae <.Loc.482.1>:
		__asm__ __volatile__ ("jeq _byte_copy ");   		 // 2 cycles
    87ae:	08 24       	jz	$+18     	;abs 0x87c0

000087b0 <.Loc.493.1>:
	
		//__asm__ __volatile__ ("incd r10 	  ");    	 // 1 cycle
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		 // 1 cycle - verify that the redirected value corresponds to the current PC return value
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	 // 2 cycles
  
		__asm__ __volatile__ ("mov @r14, @r13 ");    		 // 5 cycles
    87b0:	ad 4e 00 00 	mov	@r14,	0(r13)	;

000087b4 <_pre_end_copy>:

		__asm__ __volatile__ ("_pre_end_copy:");
		__asm__ __volatile__ ("incd r14");    			 // 1 cycle
    87b4:	2e 53       	incd	r14		;

000087b6 <.Loc.497.1>:
		__asm__ __volatile__ ("dec r15");    			 // 1 cycle
    87b6:	1f 83       	dec	r15		;

000087b8 <.Loc.498.1>:
		__asm__ __volatile__ ("tst r15");    			 // 1 cycle
    87b8:	0f 93       	cmp	#0,	r15	;r3 As==00

000087ba <.Loc.500.1>:

		__asm__ __volatile__ ("jnz  _second_phase_commit_strt"); // 2 cycles
    87ba:	f3 23       	jnz	$-24     	;abs 0x87a2

000087bc <.Loc.501.1>:
		__asm__ __volatile__ ("br #_chkpt_finished");		 // 2 cycles
    87bc:	30 40 da 87 	br	#0x87da		;

000087c0 <_byte_copy>:

		__asm__ __volatile__ ("_byte_copy:");
		__asm__ __volatile__ ("and #0x7FFF,  r13 ");   		// mask the highest bit - 2 cycles
    87c0:	3d f0 ff 7f 	and	#32767,	r13	;#0x7fff

000087c4 <.Loc.505.1>:
		__asm__ __volatile__ ("mov r13,      r11 ");   		// 1 cycle
    87c4:	0b 4d       	mov	r13,	r11	;

000087c6 <.Loc.506.1>:
		__asm__ __volatile__ ("and #0x01,    r11 ");   		// detect if its a byte write - 1 cycle
    87c6:	1b f3       	and	#1,	r11	;r3 As==01

000087c8 <.Loc.507.1>:
		__asm__ __volatile__ ("bis  r11,     r14 ");   		// detect if its a byte write - 1 cycle
    87c8:	0e db       	bis	r11,	r14	;

000087ca <.Loc.519.1>:
		//__asm__ __volatile__ ("incd r10 	  ");    	// 1 cycle							
		//__asm__ __volatile__ ("cmp  r10,      r13 ");		// 1 cycle - verify that the PC will not be overwritten by a previous violation (Discard it)
		//__asm__ __volatile__ ("jeq  _pre_end_copy ");    	// 2 cycles


		__asm__ __volatile__ ("mov.b @r14, @r13 ");    				// 5 cycles
    87ca:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

000087ce <.Loc.521.1>:

		__asm__ __volatile__ ("and #0xFFFE, r14");    				// 2 cycles
    87ce:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

000087d2 <.Loc.522.1>:
		__asm__ __volatile__ ("incd r14");    				 		// 1 cycle
    87d2:	2e 53       	incd	r14		;

000087d4 <.Loc.523.1>:
		__asm__ __volatile__ ("dec r15");    						// 1 cycles
    87d4:	1f 83       	dec	r15		;

000087d6 <.Loc.524.1>:
		__asm__ __volatile__ ("tst r15");    						// 1 cycles
    87d6:	0f 93       	cmp	#0,	r15	;r3 As==00

000087d8 <.Loc.525.1>:
		__asm__ __volatile__ ("jnz  _second_phase_commit_strt");	// 2 cycles
    87d8:	e4 23       	jnz	$-54     	;abs 0x87a2

000087da <_chkpt_finished>:
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("_chkpt_finished:");


	    /* Set second phase complete Bit - Atomic Flag*/
		__asm__ __volatile__ ("cmp.b #0x02,&0x6075");			//4 cycles
    87da:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

000087de <.Loc.536.1>:
		__asm__ __volatile__ ("jeq  __pre_finish_2nd_buffer "); //2 cycles
    87de:	11 24       	jz	$+36     	;abs 0x8802

000087e0 <.Loc.538.1>:

		__asm__ __volatile__ ("mov #0x0103, &0x6074 "); //5 cycles	/* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 1ST CHECKPOINT COMPLETELY  */
    87e0:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    87e4:	74 60 

000087e6 <.Loc.544.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//																											   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6022,r10"); 		//3 cycles
    87e6:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

000087ea <.Loc.545.1>:
		__asm__ __volatile__ ("mov &0x6024,r11"); 		//3 cycles
    87ea:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

000087ee <.Loc.546.1>:
		__asm__ __volatile__ ("mov &0x6026,r12"); 		//3 cycles
    87ee:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

000087f2 <.Loc.547.1>:
		__asm__ __volatile__ ("mov &0x6028,r13"); 	    //3 cycles
    87f2:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

000087f6 <.Loc.548.1>:
		__asm__ __volatile__ ("mov &0x602A,r14"); 	    //3 cycles
    87f6:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

000087fa <.Loc.549.1>:
		__asm__ __volatile__ ("mov &0x602C,r15"); 	    //3 cycles
    87fa:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

000087fe <.Loc.551.1>:

		__asm__ __volatile__ ("br #_finish"); 	   		//3 cycles
    87fe:	30 40 20 88 	br	#0x8820		;

00008802 <__pre_finish_2nd_buffer>:

		__asm__ __volatile__ ("__pre_finish_2nd_buffer:");

		__asm__ __volatile__ ("mov #0x0301, &0x6074 "); //4 cycles /* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 2ND CHECKPOINT COMPLETELY  */
    8802:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    8806:	74 60 

00008808 <.Loc.560.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 				   //
	//-------------------------------------------------------------------------------------------------------------//
		__asm__ __volatile__ ("mov &0x6052,r10"); 	    //3 cycles		
    8808:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

0000880c <.Loc.561.1>:
		__asm__ __volatile__ ("mov &0x6054,r11"); 	    //3 cycles
    880c:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

00008810 <.Loc.562.1>:
		__asm__ __volatile__ ("mov &0x6056,r12"); 	    //3 cycles
    8810:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

00008814 <.Loc.563.1>:
		__asm__ __volatile__ ("mov &0x6058,r13"); 	    //3 cycles
    8814:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

00008818 <.Loc.564.1>:
		__asm__ __volatile__ ("mov &0x605A,r14"); 	    //3 cycles
    8818:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

0000881c <.Loc.565.1>:
		__asm__ __volatile__ ("mov &0x605C,r15"); 	    //3 cycles
    881c:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

00008820 <_finish>:

		__asm__ __volatile__ ("_finish:");
		/* Clear the counters, and re-enable Idempotency tracking*/
		__asm__ __volatile__ ("mov #0x0000, &0x6000");	//4 cycles
    8820:	82 43 00 60 	mov	#0,	&0x6000	;r3 As==00

00008824 <.Loc.570.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6002");	//4 cycles
    8824:	82 43 02 60 	mov	#0,	&0x6002	;r3 As==00

00008828 <.Loc.571.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6004");	//4 cycles
    8828:	82 43 04 60 	mov	#0,	&0x6004	;r3 As==00

0000882c <.Loc.572.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6006");	//4 cycles
    882c:	82 43 06 60 	mov	#0,	&0x6006	;r3 As==00

00008830 <.Loc.573.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x6008");	//4 cycles
    8830:	82 43 08 60 	mov	#0,	&0x6008	;r3 As==00

00008834 <.Loc.574.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600A");	//4 cycles
    8834:	82 43 0a 60 	mov	#0,	&0x600a	;r3 As==00

00008838 <.Loc.575.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600C");	//4 cycles
    8838:	82 43 0c 60 	mov	#0,	&0x600c	;r3 As==00

0000883c <.Loc.576.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x600E");	//4 cycles
    883c:	82 43 0e 60 	mov	#0,	&0x600e	;r3 As==00

00008840 <.Loc.578.1>:

		__asm__ __volatile__ ("mov #0x0000, &0x02A2");	//4 cycles
    8840:	82 43 a2 02 	mov	#0,	&0x02a2	;r3 As==00

00008844 <.Loc.579.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A4");	//4 cycles
    8844:	82 43 a4 02 	mov	#0,	&0x02a4	;r3 As==00

00008848 <.Loc.580.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A6");	//4 cycles
    8848:	82 43 a6 02 	mov	#0,	&0x02a6	;r3 As==00

0000884c <.Loc.581.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02A8");	//4 cycles
    884c:	82 43 a8 02 	mov	#0,	&0x02a8	;r3 As==00

00008850 <.Loc.582.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AA");	//4 cycles
    8850:	82 43 aa 02 	mov	#0,	&0x02aa	;r3 As==00

00008854 <.Loc.583.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AC");	//4 cycles
    8854:	82 43 ac 02 	mov	#0,	&0x02ac	;r3 As==00

00008858 <.Loc.584.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02AE");	//4 cycles
    8858:	82 43 ae 02 	mov	#0,	&0x02ae	;r3 As==00

0000885c <.Loc.585.1>:
		__asm__ __volatile__ ("mov #0x0000, &0x02B0");	//4 cycles
    885c:	82 43 b0 02 	mov	#0,	&0x02b0	;r3 As==00

00008860 <.Loc.591.1>:

		//Test software to measure the amount of checkpoints

		//__asm__ __volatile__ ("add #0x01, &0x6076");	//4 cycles

		__asm__ __volatile__ ("mov #0x0001, &0x02A0");	//4 cycles
    8860:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008864 <.Loc.595.1>:



}
    8864:	03 43       	nop			
    8866:	00 13       	reti			

00008868 <ta_wait_no_lpm>:
//    TA_WAIT_NO_LPM                                 //
// ( the function implements a wait by continously ) //
// ( polling the TAR register                      ) //
//                                                   //
//---------------------------------------------------//
void ta_wait_no_lpm(unsigned int time_cnt) {
    8868:	21 83       	decd	r1		;

0000886a <.LCFI0>:
    886a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000886e <.Loc.14.1>:

  // Start and re-initialize TimerA
  TACTL = TASSEL0 | TACLR | MC_2;
    886e:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    8872:	bc 40 24 01 	mov	#292,	0(r12)	;#0x0124
    8876:	00 00 

00008878 <.Loc.17.1>:

  // Wait until time is over
  while(TAR < time_cnt);
    8878:	03 43       	nop			

0000887a <.L2>:
    887a:	3c 40 70 01 	mov	#368,	r12	;#0x0170
    887e:	2c 4c       	mov	@r12,	r12	;
    8880:	2c 91       	cmp	@r1,	r12	;
    8882:	fb 2b       	jnc	$-8      	;abs 0x887a

00008884 <.Loc.19.1>:

}
    8884:	03 43       	nop			
    8886:	21 53       	incd	r1		;
    8888:	30 41       	ret			

0000888a <ta_wait>:
// ( the timerA IRQ will exit the LPM0 state    )   //
//                                                  //
//--------------------------------------------------//
unsigned int periodic_val = 9980;

void ta_wait(unsigned int time_cnt) {
    888a:	21 83       	decd	r1		;

0000888c <.LCFI1>:
    888c:	81 4c 00 00 	mov	r12,	0(r1)	;

00008890 <.Loc.32.1>:

  // Set time limit for IRQ generation
  TACCR0 = time_cnt;
    8890:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    8894:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008898 <.Loc.33.1>:
  periodic_val = time_cnt;
    8898:	a2 41 00 41 	mov	@r1,	&0x4100	;

0000889c <.Loc.35.1>:
  // Start and re-initialize TimerA
  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    889c:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    88a0:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    88a4:	00 00 

000088a6 <.Loc.40.1>:

  // Go to Low-Power-Mode 0
  //LPM0;

}
    88a6:	03 43       	nop			
    88a8:	21 53       	incd	r1		;
    88aa:	30 41       	ret			

000088ac <INT_timerA1>:

//--------------------------------------------------//
//    TIMER A INTERRUPT                             //
//--------------------------------------------------//
wakeup interrupt (TIMERA1_VECTOR) INT_timerA1(void) {
    88ac:	0d 12       	push	r13		;

000088ae <.LCFI2>:
    88ae:	0c 12       	push	r12		;

000088b0 <.LCFI3>:


      //Force Reset
	 // WDTCTL = 0;
	  TACTL = TAIFG;
    88b0:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    88b4:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

000088b8 <.Loc.53.1>:
	  //LED_CTRL ^= 0x0F;
	  // Set time limit for IRQ generation
	  TACCR0 = periodic_val;
    88b8:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    88bc:	1d 42 00 41 	mov	&0x4100,r13	;0x4100
    88c0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000088c4 <.Loc.56.1>:

	  // Start and re-initialize TimerA
	  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    88c4:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    88c8:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    88cc:	00 00 

000088ce <.Loc.58.1>:

	  QWARK_CHECKPOINT();
    88ce:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    88d2:	2d 4c       	mov	@r12,	r13	;
    88d4:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    88d8:	3d d0 20 00 	bis	#32,	r13	;#0x0020
    88dc:	8c 4d 00 00 	mov	r13,	0(r12)	;

000088e0 <.Loc.61.1>:


}
    88e0:	03 43       	nop			
    88e2:	b1 c0 f0 00 	bic	#240,	4(r1)	;#0x00f0
    88e6:	04 00 
    88e8:	3c 41       	pop	r12		;
    88ea:	3d 41       	pop	r13		;
    88ec:	00 13       	reti			

000088ee <__mspabi_func_epilog_7>:
    88ee:	34 41       	pop	r4		;

000088f0 <__mspabi_func_epilog_6>:
    88f0:	35 41       	pop	r5		;

000088f2 <__mspabi_func_epilog_5>:
    88f2:	36 41       	pop	r6		;

000088f4 <__mspabi_func_epilog_4>:
    88f4:	37 41       	pop	r7		;

000088f6 <__mspabi_func_epilog_3>:
    88f6:	38 41       	pop	r8		;

000088f8 <__mspabi_func_epilog_2>:
    88f8:	39 41       	pop	r9		;

000088fa <__mspabi_func_epilog_1>:
    88fa:	3a 41       	pop	r10		;
    88fc:	30 41       	ret			

000088fe <__mspabi_srli_15>:
    88fe:	12 c3       	clrc			
    8900:	0c 10       	rrc	r12		;

00008902 <__mspabi_srli_14>:
    8902:	12 c3       	clrc			
    8904:	0c 10       	rrc	r12		;

00008906 <__mspabi_srli_13>:
    8906:	12 c3       	clrc			
    8908:	0c 10       	rrc	r12		;

0000890a <__mspabi_srli_12>:
    890a:	12 c3       	clrc			
    890c:	0c 10       	rrc	r12		;

0000890e <__mspabi_srli_11>:
    890e:	12 c3       	clrc			
    8910:	0c 10       	rrc	r12		;

00008912 <__mspabi_srli_10>:
    8912:	12 c3       	clrc			
    8914:	0c 10       	rrc	r12		;

00008916 <__mspabi_srli_9>:
    8916:	12 c3       	clrc			
    8918:	0c 10       	rrc	r12		;

0000891a <__mspabi_srli_8>:
    891a:	12 c3       	clrc			
    891c:	0c 10       	rrc	r12		;

0000891e <__mspabi_srli_7>:
    891e:	12 c3       	clrc			
    8920:	0c 10       	rrc	r12		;

00008922 <__mspabi_srli_6>:
    8922:	12 c3       	clrc			
    8924:	0c 10       	rrc	r12		;

00008926 <__mspabi_srli_5>:
    8926:	12 c3       	clrc			
    8928:	0c 10       	rrc	r12		;

0000892a <__mspabi_srli_4>:
    892a:	12 c3       	clrc			
    892c:	0c 10       	rrc	r12		;

0000892e <__mspabi_srli_3>:
    892e:	12 c3       	clrc			
    8930:	0c 10       	rrc	r12		;

00008932 <__mspabi_srli_2>:
    8932:	12 c3       	clrc			
    8934:	0c 10       	rrc	r12		;

00008936 <__mspabi_srli_1>:
    8936:	12 c3       	clrc			
    8938:	0c 10       	rrc	r12		;
    893a:	30 41       	ret			

0000893c <.L11>:
    893c:	3d 53       	add	#-1,	r13	;r3 As==11
    893e:	12 c3       	clrc			
    8940:	0c 10       	rrc	r12		;

00008942 <__mspabi_srli>:
    8942:	0d 93       	cmp	#0,	r13	;r3 As==00
    8944:	fb 23       	jnz	$-8      	;abs 0x893c
    8946:	30 41       	ret			

00008948 <__mspabi_srll_15>:
    8948:	12 c3       	clrc			
    894a:	0d 10       	rrc	r13		;
    894c:	0c 10       	rrc	r12		;

0000894e <__mspabi_srll_14>:
    894e:	12 c3       	clrc			
    8950:	0d 10       	rrc	r13		;
    8952:	0c 10       	rrc	r12		;

00008954 <__mspabi_srll_13>:
    8954:	12 c3       	clrc			
    8956:	0d 10       	rrc	r13		;
    8958:	0c 10       	rrc	r12		;

0000895a <__mspabi_srll_12>:
    895a:	12 c3       	clrc			
    895c:	0d 10       	rrc	r13		;
    895e:	0c 10       	rrc	r12		;

00008960 <__mspabi_srll_11>:
    8960:	12 c3       	clrc			
    8962:	0d 10       	rrc	r13		;
    8964:	0c 10       	rrc	r12		;

00008966 <__mspabi_srll_10>:
    8966:	12 c3       	clrc			
    8968:	0d 10       	rrc	r13		;
    896a:	0c 10       	rrc	r12		;

0000896c <__mspabi_srll_9>:
    896c:	12 c3       	clrc			
    896e:	0d 10       	rrc	r13		;
    8970:	0c 10       	rrc	r12		;

00008972 <__mspabi_srll_8>:
    8972:	12 c3       	clrc			
    8974:	0d 10       	rrc	r13		;
    8976:	0c 10       	rrc	r12		;

00008978 <__mspabi_srll_7>:
    8978:	12 c3       	clrc			
    897a:	0d 10       	rrc	r13		;
    897c:	0c 10       	rrc	r12		;

0000897e <__mspabi_srll_6>:
    897e:	12 c3       	clrc			
    8980:	0d 10       	rrc	r13		;
    8982:	0c 10       	rrc	r12		;

00008984 <__mspabi_srll_5>:
    8984:	12 c3       	clrc			
    8986:	0d 10       	rrc	r13		;
    8988:	0c 10       	rrc	r12		;

0000898a <__mspabi_srll_4>:
    898a:	12 c3       	clrc			
    898c:	0d 10       	rrc	r13		;
    898e:	0c 10       	rrc	r12		;

00008990 <__mspabi_srll_3>:
    8990:	12 c3       	clrc			
    8992:	0d 10       	rrc	r13		;
    8994:	0c 10       	rrc	r12		;

00008996 <__mspabi_srll_2>:
    8996:	12 c3       	clrc			
    8998:	0d 10       	rrc	r13		;
    899a:	0c 10       	rrc	r12		;

0000899c <__mspabi_srll_1>:
    899c:	12 c3       	clrc			
    899e:	0d 10       	rrc	r13		;
    89a0:	0c 10       	rrc	r12		;
    89a2:	30 41       	ret			

000089a4 <.L12>:
    89a4:	3e 53       	add	#-1,	r14	;r3 As==11
    89a6:	12 c3       	clrc			
    89a8:	0d 10       	rrc	r13		;
    89aa:	0c 10       	rrc	r12		;

000089ac <__mspabi_srll>:
    89ac:	0e 93       	cmp	#0,	r14	;r3 As==00
    89ae:	fa 23       	jnz	$-10     	;abs 0x89a4
    89b0:	30 41       	ret			

000089b2 <memmove>:
    89b2:	0d 9c       	cmp	r12,	r13	;
    89b4:	0a 28       	jnc	$+22     	;abs 0x89ca

000089b6 <.L5>:
    89b6:	0f 4c       	mov	r12,	r15	;
    89b8:	0e 5c       	add	r12,	r14	;

000089ba <.L3>:
    89ba:	0e 9f       	cmp	r15,	r14	;
    89bc:	0d 24       	jz	$+28     	;abs 0x89d8

000089be <.LVL3>:
    89be:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    89c2:	1f 53       	inc	r15		;

000089c4 <.LVL4>:
    89c4:	1d 53       	inc	r13		;
    89c6:	30 40 ba 89 	br	#0x89ba		;

000089ca <.L2>:
    89ca:	0f 4d       	mov	r13,	r15	;
    89cc:	0f 5e       	add	r14,	r15	;
    89ce:	0c 9f       	cmp	r15,	r12	;
    89d0:	f2 2f       	jc	$-26     	;abs 0x89b6

000089d2 <.L4>:
    89d2:	3e 53       	add	#-1,	r14	;r3 As==11

000089d4 <.LVL7>:
    89d4:	3e 93       	cmp	#-1,	r14	;r3 As==11
    89d6:	01 20       	jnz	$+4      	;abs 0x89da

000089d8 <.L10>:
    89d8:	30 41       	ret			

000089da <.L6>:
    89da:	0b 4c       	mov	r12,	r11	;
    89dc:	0b 5e       	add	r14,	r11	;
    89de:	0f 4d       	mov	r13,	r15	;
    89e0:	0f 5e       	add	r14,	r15	;
    89e2:	eb 4f 00 00 	mov.b	@r15,	0(r11)	;
    89e6:	30 40 d2 89 	br	#0x89d2		;

000089ea <memset>:
    89ea:	0f 4c       	mov	r12,	r15	;
    89ec:	0e 5c       	add	r12,	r14	;

000089ee <.L2>:
    89ee:	0f 9e       	cmp	r14,	r15	;
    89f0:	01 20       	jnz	$+4      	;abs 0x89f4

000089f2 <.Loc.104.1>:
    89f2:	30 41       	ret			

000089f4 <.L3>:
    89f4:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    89f8:	1f 53       	inc	r15		;

000089fa <.LVL4>:
    89fa:	30 40 ee 89 	br	#0x89ee		;

000089fe <__do_global_ctors_aux>:
    89fe:	0a 12       	push	r10		;
    8a00:	3a 40 08 80 	mov	#32776,	r10	;#0x8008

00008a04 <.L2>:
    8a04:	2c 4a       	mov	@r10,	r12	;
    8a06:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8a08:	02 20       	jnz	$+6      	;abs 0x8a0e
    8a0a:	3a 41       	pop	r10		;
    8a0c:	30 41       	ret			

00008a0e <.L3>:
    8a0e:	8c 12       	call	r12		;
    8a10:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    8a14:	30 40 04 8a 	br	#0x8a04		;

00008a18 <__msp430_init>:
    8a18:	b0 12 7a 82 	call	#33402		;#0x827a
    8a1c:	b0 12 fe 89 	call	#35326		;#0x89fe

00008a20 <L0>:
    8a20:	b0 12 b6 81 	call	#33206		;#0x81b6

00008a24 <.Loc.19.1>:
    8a24:	b0 12 a8 81 	call	#33192		;#0x81a8

00008a28 <.Loc.20.1>:
    8a28:	30 41       	ret			

00008a2a <__msp430_fini>:
    8a2a:	b0 12 c4 81 	call	#33220		;#0x81c4

00008a2e <L0>:
    8a2e:	b0 12 2c 82 	call	#33324		;#0x822c

00008a32 <L0>:
    8a32:	30 41       	ret			


leds.elf:     file format elf32-msp430

SYMBOL TABLE:
0000ffe8 l    d  __interrupt_vector_5	00000000 __interrupt_vector_5
0000fff0 l    d  __interrupt_vector_9	00000000 __interrupt_vector_9
0000fffe l    d  __reset_vector	00000000 __reset_vector
00008000 l    d  .rodata	00000000 .rodata
0000807c l    d  .text	00000000 .text
00004000 l    d  .data	00000000 .data
0000407c l    d  .bss	00000000 .bss
00004116 l    d  .noinit	00000000 .noinit
00000000 l    d  .MP430.attributes	00000000 .MP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 qwark.c
000080b8 l       .text	00000000 __qwark_retry_1st_setup
000080ac l       .text	00000000 __qwark_restore_2nd_setup
000080cc l       .text	00000000 __qwark_retry_2nd_setup
000080a0 l       .text	00000000 __qwark_restore_1st_setup
0000815a l       .text	00000000 __system_restore
000080dc l       .text	00000000 __second_stage_retry
0000811a l       .text	00000000 _stack_write_back_retry
000080e4 l       .text	00000000 _retry_second_phase_commit_strt
00008100 l       .text	00000000 _retry_byte_copy
0000811a l       .text	00000000 __retry_complete
00008144 l       .text	00000000 _second_phase_retry_finished
00008132 l       .text	00000000 _second_phase_retry_stack_cpy
00008154 l       .text	00000000 __set_flag_complete
0000818c l       .text	00000000 __erase_stack
0000819c l       .text	00000000 __deletion_stack_complete
000081f6 l       .text	00000000 __Second_buffer_restore_stack
000081a4 l       .text	00000000 __First_buffer_restore_stack
00008fee l       .text	00000000 __second_buffer_init
00008ff2 l       .text	00000000 __first_phase_commit
00009004 l       .text	00000000 __continue_first_phase_commit
0000909c l       .text	00000000 __seg_logic
00009090 l       .text	00000000 _scratchpad_addr_cpy
000090be l       .text	00000000 __segmentation_isr
000090c6 l       .text	00000000 __commit_th
000090d4 l       .text	00000000 __commit_on_2nd
000090d8 l       .text	00000000 _chkpt_stack
000090e0 l       .text	00000000 __first_stack_chkpt_setup
000090f2 l       .text	00000000 __segmentation_logic
0000914a l       .text	00000000 __copy_stack
00009104 l       .text	00000000 __sp_seg_define
00009110 l       .text	00000000 __sp_overlap
0000915a l       .text	00000000 __stack_chkpt_end
00009142 l       .text	00000000 __sp_pre_copy
0000912e l       .text	00000000 __overlap_copy
0000913e l       .text	00000000 __sp_ovl_copy
00009168 l       .text	00000000 __set_flag_2nd
0000916c l       .text	00000000 _WAR_commit
000091ba l       .text	00000000 _stack_write_back
00009182 l       .text	00000000 _second_phase_commit_strt
000091a0 l       .text	00000000 _byte_copy
00009194 l       .text	00000000 _pre_end_copy
000091e4 l       .text	00000000 _chkpt_finished
000091d2 l       .text	00000000 _second_phase_stack_cpy
0000921e l       .text	00000000 __pre_finish_2nd_buffer
0000924e l       .text	00000000 _finish
00000000 l    df *ABS*	00000000 timerA.c
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
000082a2 l       .text	00000000 _msp430_run_array
000082b0 l       .text	00000000 _msp430_run_done
00000000 l    df *ABS*	00000000 main.c
00004002 l     O .data	00000002 _v_seed.2309
00000000 l    df *ABS*	00000000 lib_a-impure.o
00004004 l     O .data	00000078 impure_data
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtbegin.o
00008074 l     O .rodata	00000000 __CTOR_LIST__
00008078 l     O .rodata	00000000 __DTOR_LIST__
0000806c l     O .rodata	00000000 __EH_FRAME_BEGIN__
0000984c l     O .text	00000000 __TMC_LIST__
000082b2 l     F .text	00000000 deregister_tm_clones
000082cc l     F .text	00000000 register_tm_clones
000082fa l     F .text	00000000 __do_global_dtors_aux
0000407c l     O .bss	00000000 completed.3056
0000407e l     O .bss	00000000 dtor_idx.3058
00008348 l     F .text	00000000 frame_dummy
00004080 l     O .bss	00000000 object.3071
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/430/crtend.o
00008076 l     O .rodata	00000000 __CTOR_END__
0000806c l     O .rodata	00000000 __FRAME_END__
00009816 l     F .text	00000000 __do_global_ctors_aux
00000000 l    df *ABS*	00000000 crt_bss.o
00000000 l    df *ABS*	00000000 crt_movedata.o
00000000 l    df *ABS*	00000000 crt_main.o
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 lib2divHI.o
00000000 l    df *ABS*	00000000 srli.o
00000000 l    df *ABS*	00000000 lib2hw_mul_16.o
00000130 l       *ABS*	00000000 MPY_OP1
00000132 l       *ABS*	00000000 MPY_OP1_S
00000134 l       *ABS*	00000000 MAC_OP1
00000138 l       *ABS*	00000000 MPY_OP2
00000138 l       *ABS*	00000000 MAC_OP2
0000013a l       *ABS*	00000000 RESULT_LO
0000013c l       *ABS*	00000000 RESULT_HI
00000000 l    df *ABS*	00000000 lib_a-exit.o
00000000 l    df *ABS*	00000000 lib_a-__call_atexit.o
00000000 l    df *ABS*	00000000 slli.o
00000000 l    df *ABS*	00000000 ciosyscalls.o
00000000 l    df *ABS*	00000000 lib_a-memmove.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 /opt/ti/ccsv8/tools/compiler/msp430-gcc-7.3.1.24_linux64/bin/../lib/gcc/msp430-elf/7.3.1/../../../../msp430-elf/lib/430/crtn.o
00000000 l    df *ABS*	00000000 
0000807c l       .text	00000000 _start
000095cc g     F .text	00000000 __mspabi_mpyl
00009794 g       .text	00000000 .hidden __mspabi_slll_9
00009784 g       .text	00000000 .hidden __mspabi_slll_13
00008d0c g     F .text	00000016 end_of_benchmark
0000951c g       .text	00000000 .hidden __mspabi_srli_9
0000956c g       .text	00000000 .hidden __mspabi_srll_10
00008534 g     F .text	000000d6 transform
00009518 g       .text	00000000 .hidden __mspabi_srli_10
00008c08 g     F .text	0000008a train
0000975e g       .text	00000000 .hidden __mspabi_slli_9
00009504 g       .text	00000000 .hidden __mspabi_srli_15
000097ca g     F .text	00000038 memmove
00009530 g       .text	00000000 .hidden __mspabi_srli_4
00009758 g       .text	00000000 .hidden __mspabi_slli_12
00009426 g     F .text	00000040 .hidden udivmodhi4
00009524 g       .text	00000000 .hidden __mspabi_srli_7
0000957e g       .text	00000000 .hidden __mspabi_srll_7
00009596 g       .text	00000000 .hidden __mspabi_srll_3
000095cc g     F .text	0000002e __mulsi2
000094f6 g       .text	00000000 .hidden __mspabi_func_epilog_6
0000984c g     O .text	00000000 .hidden __TMC_END__
0000955a g       .text	00000000 .hidden __mspabi_srll_13
0000807a g     O .rodata	00000000 .hidden __DTOR_END__
00008070 g       .rodata	00000000 __fini_array_end
00008aea g     F .text	000000f0 print_stats
00009510 g       .text	00000000 .hidden __mspabi_srli_12
0000408e g     O .bss	00000002 sum
000095cc g     F .text	00000000 __mspabi_mpyl_hw
0000807c g     F .text	00000004 __crt0_start
0000978c g       .text	00000000 .hidden __mspabi_slll_11
0000977c g       .text	00000000 .hidden __mspabi_slll_15
00009754 g       .text	00000000 .hidden __mspabi_slli_14
00009768 g       .text	00000000 .hidden __mspabi_slli_4
0000824a g     F .text	0000000e __crt0_init_bss
0000009a g       *ABS*	00000000 __bsssize
000097b0 g       .text	00000000 .hidden __mspabi_slll_2
000094b2 g     F .text	00000032 .hidden __mspabi_remi
0000826c g     F .text	0000000a __crt0_call_init_then_main
00009500 g       .text	00000000 .hidden __mspabi_func_epilog_1
00009776 g       .text	00000000 .hidden __mspabi_slli
00004090 g     O .bss	00000080 model
000094fc g       .text	00000000 .hidden __mspabi_func_epilog_3
00008068 g     O .rodata	00000002 _global_impure_ptr
0000958a g       .text	00000000 .hidden __mspabi_srll_5
00008eaa g     F .text	000000c4 init_stationary
00009548 g       .text	00000000 .hidden __mspabi_srli
000095b8 g     F .text	00000000 __mspabi_mpyi_hw
000095b8 g     F .text	00000014 __mulhi2
00009566 g       .text	00000000 .hidden __mspabi_srll_11
000097a4 g       .text	00000000 .hidden __mspabi_slll_5
0000975a g       .text	00000000 .hidden __mspabi_slli_11
0000976a g       .text	00000000 .hidden __mspabi_slli_3
00008de6 g     F .text	000000c4 init_moving
0000952c g       .text	00000000 .hidden __mspabi_srli_5
0000860a g     F .text	000002c6 featurize
00000000  w      *UND*	00000000 __sf_fake_stderr
00009340 g     F .text	000000b2 UART_WriteNumber
00000000  w      *UND*	00000000 __deregister_frame_info
00004116 g       .noinit	00000000 end
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
0000976c g       .text	00000000 .hidden __mspabi_slli_2
00004110 g     O .bss	00000002 resultStationaryPct
000094ec g     F .text	00000008 .hidden __mspabi_remu
00009584 g       .text	00000000 .hidden __mspabi_srll_6
00009618 g     F .text	0000013a __call_exitprocs
000097a0 g       .text	00000000 .hidden __mspabi_slll_6
000097a8 g       .text	00000000 .hidden __mspabi_slll_4
00009798 g       .text	00000000 .hidden __mspabi_slll_8
00008292 g     F .text	00000000 _msp430_run_fini_array
0000931c g     F .text	00000024 UART_WriteChar
0000953c g       .text	00000000 .hidden __mspabi_srli_1
00009554 g       .text	00000000 .hidden __mspabi_srll_14
00009764 g       .text	00000000 .hidden __mspabi_slli_6
000095b8 g     F .text	00000000 __mspabi_mpyi
00004112 g     O .bss	00000002 resultMovingPct
00008080 g     F .text	000001ca qwark_restore
00009508 g       .text	00000000 .hidden __mspabi_srli_14
0000007c g       *ABS*	00000000 __romdatacopysize
00008dba g     F .text	0000002c init
00009780 g       .text	00000000 .hidden __mspabi_slll_14
00009514 g       .text	00000000 .hidden __mspabi_srli_11
0000979c g       .text	00000000 .hidden __mspabi_slll_7
00004114 g     O .bss	00000002 periodic_val
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
00008070 g       .rodata	00000000 __fini_array_start
00009466 g     F .text	0000004c .hidden __mspabi_divi
00000000  w      *UND*	00000000 __sf_fake_stdin
00000000  w      *ABS*	00000000 __rom_highdatacopysize
00009830 g       .text	00000000 __msp430_init
00009802 g     F .text	00000014 memset
00009788 g       .text	00000000 .hidden __mspabi_slll_12
00008f6e g     F .text	00000066 main
000092b8 g     F .text	00000022 ta_wait
00009590 g       .text	00000000 .hidden __mspabi_srll_4
00008070 g       .rodata	00000000 __init_array_end
00009538 g       .text	00000000 .hidden __mspabi_srli_2
0000976e g       .text	00000000 .hidden __mspabi_slli_1
000094e4 g     F .text	00000008 .hidden __mspabi_divu
00000000  w      *ABS*	00000000 __high_bsssize
000097ac g       .text	00000000 .hidden __mspabi_slll_3
00000000  w      *ABS*	00000000 __rom_highdatastart
000092da g     F .text	00000042 INT_timerA1
0000984c g       .text	00000000 __msp430_fini_end
00008a8c g     F .text	0000005e record_stats
00008d22 g     F .text	00000004 count_error
00004000 g     O .data	00000002 count
00009560 g       .text	00000000 .hidden __mspabi_srll_12
00009766 g       .text	00000000 .hidden __mspabi_slli_5
00008bda g     F .text	0000002e warmup_sensor
0000984c g       *ABS*	00000000 __romdatastart
000093f2 g     F .text	00000034 UART_WriteString
00009756 g       .text	00000000 .hidden __mspabi_slli_13
00008360 g     F .text	00000114 sqrt16
00008276 g     F .text	00000000 _msp430_run_init_array
00009296 g     F .text	00000022 ta_wait_no_lpm
00009528 g       .text	00000000 .hidden __mspabi_srli_6
00008070 g       .rodata	00000000 __preinit_array_end
00008474 g     F .text	00000074 ACCEL_singleSample
0000975c g       .text	00000000 .hidden __mspabi_slli_10
00009534 g       .text	00000000 .hidden __mspabi_srli_3
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
0000407c g       .bss	00000000 __bssstart
000088d0 g     F .text	000001bc classify
00008d26 g     F .text	00000094 select_mode
000094f8 g       .text	00000000 .hidden __mspabi_func_epilog_5
000097c0 g       .text	00000000 .hidden __mspabi_slll
00008000 g       .noinit	00000000 __stack
00008fd4 g     F .text	000002c2 INT_Qwark
00009572 g       .text	00000000 .hidden __mspabi_srll_9
0000407c g       .data	00000000 _edata
00009842 g       .text	00000000 __msp430_init_end
000095b2 g       .text	00000000 .hidden __mspabi_srll
000095fa g     F .text	0000001e exit
00000000  w      *ABS*	00000000 __high_bssstart
00009760 g       .text	00000000 .hidden __mspabi_slli_8
0000954e g       .text	00000000 .hidden __mspabi_srll_15
00009790 g       .text	00000000 .hidden __mspabi_slll_10
00000000  w      *UND*	00000000 __sf_fake_stdout
00009752 g       .text	00000000 .hidden __mspabi_slli_15
00008070 g       .rodata	00000000 __init_array_start
000097c6  w    F .text	00000004 _exit
0000950c g       .text	00000000 .hidden __mspabi_srli_13
00004000 g       .data	00000000 __datastart
000097b4 g       .text	00000000 .hidden __mspabi_slll_1
00009578 g       .text	00000000 .hidden __mspabi_srll_8
000095a2 g       .text	00000000 .hidden __mspabi_srll_1
00009762 g       .text	00000000 .hidden __mspabi_slli_7
00008070 g       .rodata	00000000 __preinit_array_start
00008258 g     F .text	00000014 __crt0_movedata
000094fe g       .text	00000000 .hidden __mspabi_func_epilog_2
00000000  w      *UND*	00000000 __register_frame_info
00008284 g     F .text	00000000 _msp430_run_preinit_array
000084e8 g     F .text	0000004c acquire_window
000094f4 g       .text	00000000 .hidden __mspabi_func_epilog_7
000094fa g       .text	00000000 .hidden __mspabi_func_epilog_4
0000959c g       .text	00000000 .hidden __mspabi_srll_2
00009842 g       .text	00000000 __msp430_fini
00009520 g       .text	00000000 .hidden __mspabi_srli_8
00008c92 g     F .text	0000007a recognize
00000000  w      *UND*	00000000 free



Disassembly of section __interrupt_vector_5:

0000ffe8 <__interrupt_vector_5>:
    ffe8:	d4 8f       	interrupt service routine at 0x8fd4

Disassembly of section __interrupt_vector_9:

0000fff0 <__interrupt_vector_9>:
    fff0:	da 92       	interrupt service routine at 0x92da

Disassembly of section .text:

0000807c <__crt0_start>:
    807c:	31 40 00 80 	mov	#32768,	r1	;#0x8000

00008080 <qwark_restore>:
	//    RESTORE HANDLING LOGIC																  				   //
	//	  W.C 30 CYCLES																							   //
	//-------------------------------------------------------------------------------------------------------------//

	/* Disable Qwark */
	asm ("mov #0x0000, &0x02A0");				// 4 cycles
    8080:	82 43 a0 02 	mov	#0,	&0x02a0	;r3 As==00

00008084 <.Loc.30.1>:

	asm ("cmp.b #0x02, &0x6074");				// 2 cycles
    8084:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

00008088 <.Loc.31.1>:
	asm ("jz __qwark_retry_1st_setup");		    // 2 cycles
    8088:	17 24       	jz	$+48     	;abs 0x80b8

0000808a <.Loc.33.1>:

	asm ("cmp.b #0x03, &0x6075");				// 3 cycles
    808a:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    808e:	75 60 

00008090 <.Loc.34.1>:
	asm ("jz __qwark_restore_2nd_setup");		// 2 cycles
    8090:	0d 24       	jz	$+28     	;abs 0x80ac

00008092 <.Loc.35.1>:
	asm ("cmp.b #0x03, &0x6074");				// 3 cycles
    8092:	f2 90 03 00 	cmp.b	#3,	&0x6074	;
    8096:	74 60 

00008098 <.Loc.36.1>:
	asm ("jnz __crt0_init_bss");				// 2 cycles
    8098:	d8 20       	jnz	$+434    	;abs 0x824a

0000809a <.Loc.38.1>:

	asm ("cmp.b #0x02, &0x6075");				// 2 cycles
    809a:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

0000809e <.Loc.39.1>:
	asm ("jz  __qwark_retry_2nd_setup");		// 2 cycles
    809e:	16 24       	jz	$+46     	;abs 0x80cc

000080a0 <__qwark_restore_1st_setup>:

	asm ("__qwark_restore_1st_setup:");

	asm ("mov &0X6012,   r12 ");				// 3 cycles
    80a0:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

000080a4 <.Loc.44.1>:
    asm ("mov #0x6FFE,   r13 ");				// 2 cycles
    80a4:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

000080a8 <.Loc.45.1>:
	asm ("br  #__system_restore");				// 2 cycles
    80a8:	30 40 5a 81 	br	#0x815a		;

000080ac <__qwark_restore_2nd_setup>:

	asm ("__qwark_restore_2nd_setup:");

	asm ("mov &0X6042, r12   ");				// 3 cycles
    80ac:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

000080b0 <.Loc.50.1>:
    asm ("mov #0x6BFE, r13   ");				// 2 cycles
    80b0:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

000080b4 <.Loc.51.1>:
	asm ("br  #__system_restore");				// 2 cycles
    80b4:	30 40 5a 81 	br	#0x815a		;

000080b8 <__qwark_retry_1st_setup>:

	asm ("__qwark_retry_1st_setup:");

	asm ("mov  #0x6030,   r10 ");				// 2 cycles
    80b8:	3a 40 30 60 	mov	#24624,	r10	;#0x6030

000080bc <.Loc.56.1>:
	asm ("mov  &0X6012,   r12 ");				// 3 cycles
    80bc:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

000080c0 <.Loc.57.1>:
    asm ("mov  #0x6FFE,   r13 ");				// 2 cycles
    80c0:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

000080c4 <.Loc.58.1>:
	asm ("mov  &0x602E,   r15 ");				// 3 cycles
    80c4:	1f 42 2e 60 	mov	&0x602e,r15	;0x602e

000080c8 <.Loc.59.1>:
	asm ("br  #__second_stage_retry");			// 2 cycles
    80c8:	30 40 dc 80 	br	#0x80dc		;

000080cc <__qwark_retry_2nd_setup>:

	asm ("__qwark_retry_2nd_setup:");

	asm ("mov #0x6060,   r10 ");				// 2 cycles
    80cc:	3a 40 60 60 	mov	#24672,	r10	;#0x6060

000080d0 <.Loc.64.1>:
	asm ("mov &0X6042,   r12 ");				// 3 cycles
    80d0:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

000080d4 <.Loc.65.1>:
    asm ("mov #0x6BFE,   r13 ");				// 2 cycles
    80d4:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

000080d8 <.Loc.66.1>:
	asm ("mov &0x605E,   r15 ");				// 3 cycles
    80d8:	1f 42 5e 60 	mov	&0x605e,r15	;0x605e

000080dc <__second_stage_retry>:
	//-------------------------------------------------------------------------------------------------------------//
	//    RETRY SECOND PHASE OF THE COMMIT PROCESS	: 148 cycles												   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("__second_stage_retry:");

	asm ("tst r15 ");     		            // 1 cycles
    80dc:	0f 93       	cmp	#0,	r15	;r3 As==00

000080de <.Loc.74.1>:
	asm ("jz  _stack_write_back_retry");	// 2 cycles
    80de:	1d 24       	jz	$+60     	;abs 0x811a

000080e0 <.Loc.76.1>:

	asm ("mov #0x6000,  r14");			    // 2 cycles
    80e0:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

000080e4 <_retry_second_phase_commit_strt>:

	asm ("_retry_second_phase_commit_strt:");  // Worst case

	asm ("mov @r10+2,  r9 ");   			// 2 cycles
    80e4:	39 4a       	mov	@r10+,	r9	;

000080e6 <.Loc.82.1>:

	asm ("mov r9,  r11 ");   			    // 1 cycle
    80e6:	0b 49       	mov	r9,	r11	;

000080e8 <.Loc.84.1>:

	asm ("and #0x8000,  r11 ");   			// 2 cycles
    80e8:	3b f0 00 80 	and	#32768,	r11	;#0x8000

000080ec <.Loc.85.1>:
	asm ("cmp #0x8000,  r11 ");   			// 2 cycles
    80ec:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

000080f0 <.Loc.86.1>:
	asm ("jeq _retry_byte_copy ");   		// 2 cycles
    80f0:	07 24       	jz	$+16     	;abs 0x8100

000080f2 <.Loc.88.1>:

	asm ("mov @r14+2, @r9 ");    			// 5 cycles
    80f2:	b9 4e 00 00 	mov	@r14+,	0(r9)	;

000080f6 <.Loc.90.1>:

	asm ("dec r15");    					// 1 cycles
    80f6:	1f 83       	dec	r15		;

000080f8 <.Loc.91.1>:
	asm ("tst r15");    					// 1 cycles
    80f8:	0f 93       	cmp	#0,	r15	;r3 As==00

000080fa <.Loc.93.1>:

	asm ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    80fa:	f4 23       	jnz	$-22     	;abs 0x80e4

000080fc <.Loc.94.1>:
	asm ("br #__retry_complete");		    // 2 cycle
    80fc:	30 40 1a 81 	br	#0x811a		;

00008100 <_retry_byte_copy>:

	asm ("_retry_byte_copy: ");
	asm ("and #0x7FFF,  r9  ");   			// mask the highest bit 2 cycles
    8100:	39 f0 ff 7f 	and	#32767,	r9	;#0x7fff

00008104 <.Loc.98.1>:
	asm ("mov r9,      r11  ");   			// 1 cycle
    8104:	0b 49       	mov	r9,	r11	;

00008106 <.Loc.99.1>:
	asm ("and #0x01,    r11 ");   			// detect if its a byte write - 2 cycles
    8106:	1b f3       	and	#1,	r11	;r3 As==01

00008108 <.Loc.100.1>:
	asm ("bis  r11,     r14 ");   			// detect if its a byte write - 2 cycles
    8108:	0e db       	bis	r11,	r14	;

0000810a <.Loc.102.1>:

	asm ("mov.b @r14, @r9  ");    			// 5 cycles
    810a:	e9 4e 00 00 	mov.b	@r14,	0(r9)	;

0000810e <.Loc.103.1>:
	asm ("and #0xFFFE, r14 ");    			// 1 cycle
    810e:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

00008112 <.Loc.104.1>:
	asm ("incd r14 ");    					// 1 cycle
    8112:	2e 53       	incd	r14		;

00008114 <.Loc.106.1>:

	asm ("dec r15");    					// 1 cycles
    8114:	1f 83       	dec	r15		;

00008116 <.Loc.107.1>:
	asm ("tst r15");    					// 1 cycles
    8116:	0f 93       	cmp	#0,	r15	;r3 As==00

00008118 <.Loc.108.1>:
	asm ("jnz  _retry_second_phase_commit_strt");// 2 cycles
    8118:	e5 23       	jnz	$-52     	;abs 0x80e4

0000811a <__retry_complete>:
	//-------------------------------------------------------------------------------------------------------------//
	//   COPY BACK THE 2BLE BUFFER	RETRY				       				       	      						   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("_stack_write_back_retry:");

	asm ("cmp #0x0000,  &0x6BFE");	
    811a:	82 93 fe 6b 	cmp	#0,	&0x6bfe	;r3 As==00

0000811e <.Loc.118.1>:
	asm ("jeq _second_phase_retry_finished");
    811e:	12 24       	jz	$+38     	;abs 0x8144

00008120 <.Loc.120.1>:

	asm ("mov &0x6BFE,  r13 ");		 // 2 cycles - get the upper limit		
    8120:	1d 42 fe 6b 	mov	&0x6bfe,r13	;0x6bfe

00008124 <.Loc.121.1>:
	asm ("mov &0x6BFC,  r12 ");		 // 2 cycles - get the down limit 
    8124:	1c 42 fc 6b 	mov	&0x6bfc,r12	;0x6bfc

00008128 <.Loc.123.1>:

	asm ("mov r13,  r14 ");		 	 // 2 cycles - 
    8128:	0e 4d       	mov	r13,	r14	;

0000812a <.Loc.124.1>:
	asm ("sub #0x1000,  r14 ");		 // 2 cycles - get the down limit 
    812a:	3e 80 00 10 	sub	#4096,	r14	;#0x1000

0000812e <.Loc.125.1>:
	asm ("mov #0x6BFA,  r10 ");
    812e:	3a 40 fa 6b 	mov	#27642,	r10	;#0x6bfa

00008132 <_second_phase_retry_stack_cpy>:

	asm ("_second_phase_retry_stack_cpy:");
	asm ("mov @r10,@r14");				 // 5 cycles
    8132:	ae 4a 00 00 	mov	@r10,	0(r14)	;

00008136 <.Loc.130.1>:
	
	asm ("cmp r13, r12");	
    8136:	0c 9d       	cmp	r13,	r12	;

00008138 <.Loc.131.1>:
   	asm ("jeq _second_phase_retry_finished");	 	 // 2 cycles
    8138:	05 24       	jz	$+12     	;abs 0x8144

0000813a <.Loc.132.1>:
	asm ("decd r10");
    813a:	2a 83       	decd	r10		;

0000813c <.Loc.133.1>:
	asm ("decd r13");	   	
    813c:	2d 83       	decd	r13		;

0000813e <.Loc.134.1>:
	asm ("decd r14");	   	
    813e:	2e 83       	decd	r14		;

00008140 <.Loc.135.1>:
	asm ("br # _second_phase_retry_stack_cpy");	 	// 2 cycles
    8140:	30 40 32 81 	br	#0x8132		;

00008144 <_second_phase_retry_finished>:
	//    END OF THE RETRY-SECOND PHASE	: Atomic Flag Set														   //
	//	  W.C 18 Cycles																							   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("_second_phase_retry_finished:");

	asm ("cmp.b #0x02, &0x6074");		// 4 cycles
    8144:	e2 93 74 60 	cmp.b	#2,	&0x6074	;r3 As==10

00008148 <.Loc.144.1>:
	asm ("jz __set_flag_complete");	// 2 cycles
    8148:	05 24       	jz	$+12     	;abs 0x8154

0000814a <.Loc.146.1>:

	asm ("mov #0x0301, &0x6074 ");		// 5 cycles
    814a:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    814e:	74 60 

00008150 <.Loc.147.1>:
	asm ("br #__system_restore:");		// 2 cycles
    8150:	30 40 5a 81 	br	#0x815a		;

00008154 <__set_flag_complete>:

	asm ("__set_flag_complete:");
	asm ("mov #0x0103, &0x6074 ");		// 5 cycles
    8154:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    8158:	74 60 

0000815a <__system_restore>:
	//	 12 CYCLES																								   //
	//-------------------------------------------------------------------------------------------------------------//
	asm ("__system_restore:");

	/* Disable The Watchdog */
	asm ("mov #288, r8");		// 2 cycles
    815a:	38 40 20 01 	mov	#288,	r8	;#0x0120

0000815e <.Loc.160.1>:
	asm ("mov #23168, 0(r8)");	// 2 cycles
    815e:	b8 40 80 5a 	mov	#23168,	0(r8)	;#0x5a80
    8162:	00 00 

00008164 <.Loc.163.1>:

	/* Enable and Configure the UART */
	asm ("mov.b #130, r8");	// 2 cycles
    8164:	78 40 82 00 	mov.b	#130,	r8	;#0x0082

00008168 <.Loc.164.1>:
	asm ("mov   #8, 0(r8)");	// 2 cycles
    8168:	b8 42 00 00 	mov	#8,	0(r8)	;r2 As==11

0000816c <.Loc.166.1>:

	asm ("mov.b #128, r8");	// 2 cycles
    816c:	78 40 80 00 	mov.b	#128,	r8	;#0x0080

00008170 <.Loc.167.1>:
	asm ("mov.b   #1, 0(r8)"); // 2 cycles
    8170:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01

00008174 <.Loc.173.1>:

	/* Configure the timer */


#ifdef TIMER_TEST
	asm ("mov  #370, r8");		    // 2 cycles
    8174:	38 40 72 01 	mov	#370,	r8	;#0x0172

00008178 <.Loc.174.1>:
	asm ("mov  #4980, 0(r8)");	// 2 cycles
    8178:	b8 40 74 13 	mov	#4980,	0(r8)	;#0x1374
    817c:	00 00 

0000817e <.Loc.176.1>:

	asm ("mov  #352, r8");		    // 2 cycles
    817e:	38 40 60 01 	mov	#352,	r8	;#0x0160

00008182 <.Loc.177.1>:
	asm ("mov  #534, 0(r8)");	    // 2 cycles
    8182:	b8 40 16 02 	mov	#534,	0(r8)	;#0x0216
    8186:	00 00 

00008188 <.Loc.185.1>:
	//-------------------------------------------------------------------------------------------------------------//
	//   TESTING ONLY: Wipe out the stack to simulate a real power outage										   //
	//	 N.A.																								       //
	//-------------------------------------------------------------------------------------------------------------//

	asm ("mov #0x7FFE, r14");
    8188:	3e 40 fe 7f 	mov	#32766,	r14	;#0x7ffe

0000818c <__erase_stack>:

	asm ("__erase_stack:");

	asm ("cmp #0x7FA0,r14");
    818c:	3e 90 a0 7f 	cmp	#32672,	r14	;#0x7fa0

00008190 <.Loc.190.1>:
	asm ("jz __deletion_stack_complete");
    8190:	05 24       	jz	$+12     	;abs 0x819c

00008192 <.Loc.192.1>:

	asm ("mov #0x00000,@r14");
    8192:	8e 43 00 00 	mov	#0,	0(r14)	;r3 As==00

00008196 <.Loc.193.1>:
	asm ("decd r14");
    8196:	2e 83       	decd	r14		;

00008198 <.Loc.194.1>:
	asm ("br #__erase_stack");
    8198:	30 40 8c 81 	br	#0x818c		;

0000819c <__deletion_stack_complete>:
	//-------------------------------------------------------------------------------------------------------------//
	//   REGISTERS RESTORE: VERIFY WHICH REGISTERS SHOULD BE RESTORED					   						   //
	//	 																										   //
	//-------------------------------------------------------------------------------------------------------------//

	asm ("cmp.b #0x03,&0x6075");				// 5 cycles
    819c:	f2 90 03 00 	cmp.b	#3,	&0x6075	;
    81a0:	75 60 

000081a2 <.Loc.205.1>:
	asm ("jeq __Second_buffer_restore_stack"); // 2 cycles
    81a2:	29 24       	jz	$+84     	;abs 0x81f6

000081a4 <__First_buffer_restore_stack>:
	/* EDE -> Rm  : 3 cycles each 											  				  			  */
	/* EDE -> PC  : 4 cycles (1 extra cycle penalty) for openMSP430 		  				  			  */
	/* Register time: 14x3 = 42 cycles + 4 cycles (PC) = 49 Cycles + 4(Qwark enable) = 53 cycles 		  */
	asm ("__First_buffer_restore_stack:");

	asm ("mov &0x6016,r4"); 		//R4
    81a4:	14 42 16 60 	mov	&0x6016,r4	;0x6016

000081a8 <.Loc.215.1>:
	asm ("mov &0x6018,r5"); 		//R5
    81a8:	15 42 18 60 	mov	&0x6018,r5	;0x6018

000081ac <.Loc.216.1>:
	asm ("mov &0x601A,r6"); 		//R6
    81ac:	16 42 1a 60 	mov	&0x601a,r6	;0x601a

000081b0 <.Loc.217.1>:
	asm ("mov &0x601C,r7"); 		//R7
    81b0:	17 42 1c 60 	mov	&0x601c,r7	;0x601c

000081b4 <.Loc.218.1>:
	asm ("mov &0x601E,r8"); 		//R8
    81b4:	18 42 1e 60 	mov	&0x601e,r8	;0x601e

000081b8 <.Loc.219.1>:
	asm ("mov &0x6020,r9"); 		//R9
    81b8:	19 42 20 60 	mov	&0x6020,r9	;0x6020

000081bc <.Loc.220.1>:
	asm ("mov &0x6022,r10"); 		//R10
    81bc:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

000081c0 <.Loc.221.1>:
	asm ("mov &0x6024,r11"); 		//R11
    81c0:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

000081c4 <.Loc.222.1>:
	asm ("mov &0x6026,r12"); 		//R12
    81c4:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

000081c8 <.Loc.223.1>:
	asm ("mov &0x6028,r13"); 	    //R13
    81c8:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

000081cc <.Loc.224.1>:
	asm ("mov &0x602A,r14"); 		//R14
    81cc:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

000081d0 <.Loc.225.1>:
	asm ("mov &0x602C,r15"); 		//R15
    81d0:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

000081d4 <.Loc.226.1>:
	asm ("mov &0x6012,r1");   		//SP/R1
    81d4:	11 42 12 60 	mov	&0x6012,r1	;0x6012

000081d8 <.Loc.227.1>:
	asm ("mov &0x6014,r2"); 	    //SR/R2
    81d8:	12 42 14 60 	mov	&0x6014,r2	;0x6014

000081dc <.Loc.228.1>:
	asm ("mov &0x6076,&0x02B2"); 	    //3 cycles
    81dc:	92 42 76 60 	mov	&0x6076,&0x02b2	;0x6076
    81e0:	b2 02 

000081e2 <.Loc.229.1>:
	asm ("mov &0x6076,&0x02B4"); 	    //3 cycles
    81e2:	92 42 76 60 	mov	&0x6076,&0x02b4	;0x6076
    81e6:	b4 02 

000081e8 <.Loc.230.1>:
	asm ("mov &0x6076,&0x02B6"); 	    //3 cycles
    81e8:	92 42 76 60 	mov	&0x6076,&0x02b6	;0x6076
    81ec:	b6 02 

000081ee <.Loc.234.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */

	asm ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    81ee:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

000081f2 <.Loc.237.1>:

	/*Restore program Counter */
	asm ("mov &0x6010, pc"); 	    //PC/R0
    81f2:	10 42 10 60 	br	&0x6010		;

000081f6 <__Second_buffer_restore_stack>:

	asm ("__Second_buffer_restore_stack:");

	asm ("mov &0x6046,r4"); 		//R4
    81f6:	14 42 46 60 	mov	&0x6046,r4	;0x6046

000081fa <.Loc.242.1>:
	asm ("mov &0x6048,r5"); 		//R5
    81fa:	15 42 48 60 	mov	&0x6048,r5	;0x6048

000081fe <.Loc.243.1>:
	asm ("mov &0x604A,r6"); 		//R6
    81fe:	16 42 4a 60 	mov	&0x604a,r6	;0x604a

00008202 <.Loc.244.1>:
	asm ("mov &0x604C,r7"); 		//R7
    8202:	17 42 4c 60 	mov	&0x604c,r7	;0x604c

00008206 <.Loc.245.1>:
	asm ("mov &0x604E,r8"); 		//R8
    8206:	18 42 4e 60 	mov	&0x604e,r8	;0x604e

0000820a <.Loc.246.1>:
	asm ("mov &0x6050,r9"); 		//R9
    820a:	19 42 50 60 	mov	&0x6050,r9	;0x6050

0000820e <.Loc.247.1>:
	asm ("mov &0x6052,r10"); 		//R10
    820e:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

00008212 <.Loc.248.1>:
	asm ("mov &0x6054,r11"); 		//R11
    8212:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

00008216 <.Loc.249.1>:
	asm ("mov &0x6056,r12"); 		//R12
    8216:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

0000821a <.Loc.250.1>:
	asm ("mov &0x6058,r13"); 	    //R13
    821a:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

0000821e <.Loc.251.1>:
	asm ("mov &0x605A,r14"); 		//R14
    821e:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

00008222 <.Loc.252.1>:
	asm ("mov &0x605C,r15"); 		//R15
    8222:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

00008226 <.Loc.253.1>:
	asm ("mov &0x6042,r1");   		//SP/R1
    8226:	11 42 42 60 	mov	&0x6042,r1	;0x6042

0000822a <.Loc.254.1>:
	asm ("mov &0x6044,r2"); 	    //SR/R2
    822a:	12 42 44 60 	mov	&0x6044,r2	;0x6044

0000822e <.Loc.257.1>:

	/* Enable Idempotency Tracking before restarting operation 		 				  	  */
	asm ("mov &0x6078,&0x02B2"); 	    //3 cycles
    822e:	92 42 78 60 	mov	&0x6078,&0x02b2	;0x6078
    8232:	b2 02 

00008234 <.Loc.258.1>:
	asm ("mov &0x6078,&0x02B4"); 	    //3 cycles
    8234:	92 42 78 60 	mov	&0x6078,&0x02b4	;0x6078
    8238:	b4 02 

0000823a <.Loc.259.1>:
	asm ("mov &0x6078,&0x02B6"); 	    //3 cycles
    823a:	92 42 78 60 	mov	&0x6078,&0x02b6	;0x6078
    823e:	b6 02 

00008240 <.Loc.260.1>:
	asm ("mov #0x0001 , &0x02A0");	/* QWARK_CTL Enable 4 cycles 		  */
    8240:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00008244 <.Loc.263.1>:

	/*Restore program Counter */
	asm ("mov &0x6040, pc"); 	    //PC/R0
    8244:	10 42 40 60 	br	&0x6040		;

00008248 <.Loc.265.1>:

}
    8248:	03 43       	nop			

0000824a <__crt0_init_bss>:
    824a:	3c 40 7c 40 	mov	#16508,	r12	;#0x407c

0000824e <.Loc.74.1>:
    824e:	0d 43       	clr	r13		;

00008250 <.Loc.75.1>:
    8250:	3e 40 9a 00 	mov	#154,	r14	;#0x009a

00008254 <.Loc.79.1>:
    8254:	b0 12 02 98 	call	#38914		;#0x9802

00008258 <__crt0_movedata>:
    8258:	3c 40 00 40 	mov	#16384,	r12	;#0x4000

0000825c <.Loc.116.1>:
    825c:	3d 40 4c 98 	mov	#38988,	r13	;#0x984c

00008260 <.Loc.119.1>:
    8260:	0d 9c       	cmp	r12,	r13	;

00008262 <.Loc.120.1>:
    8262:	04 24       	jz	$+10     	;abs 0x826c

00008264 <.Loc.122.1>:
    8264:	3e 40 7c 00 	mov	#124,	r14	;#0x007c

00008268 <.Loc.124.1>:
    8268:	b0 12 ca 97 	call	#38858		;#0x97ca

0000826c <__crt0_call_init_then_main>:
    826c:	b0 12 30 98 	call	#38960		;#0x9830

00008270 <.Loc.196.1>:
    8270:	0c 43       	clr	r12		;

00008272 <.Loc.197.1>:
    8272:	b0 12 6e 8f 	call	#36718		;#0x8f6e

00008276 <_msp430_run_init_array>:
    8276:	34 40 70 80 	mov	#32880,	r4	;#0x8070

0000827a <.Loc.224.1>:
    827a:	35 40 70 80 	mov	#32880,	r5	;#0x8070

0000827e <.Loc.225.1>:
    827e:	26 43       	mov	#2,	r6	;r3 As==10

00008280 <.Loc.226.1>:
    8280:	30 40 a2 82 	br	#0x82a2		;

00008284 <_msp430_run_preinit_array>:
    8284:	34 40 70 80 	mov	#32880,	r4	;#0x8070

00008288 <.Loc.232.1>:
    8288:	35 40 70 80 	mov	#32880,	r5	;#0x8070

0000828c <.Loc.233.1>:
    828c:	26 43       	mov	#2,	r6	;r3 As==10

0000828e <.Loc.234.1>:
    828e:	30 40 a2 82 	br	#0x82a2		;

00008292 <_msp430_run_fini_array>:
    8292:	34 40 70 80 	mov	#32880,	r4	;#0x8070

00008296 <.Loc.240.1>:
    8296:	35 40 70 80 	mov	#32880,	r5	;#0x8070

0000829a <.Loc.241.1>:
    829a:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe

0000829e <.Loc.242.1>:
    829e:	30 40 a2 82 	br	#0x82a2		;

000082a2 <_msp430_run_array>:
    82a2:	05 94       	cmp	r4,	r5	;

000082a4 <.Loc.246.1>:
    82a4:	05 24       	jz	$+12     	;abs 0x82b0

000082a6 <.Loc.247.1>:
    82a6:	27 44       	mov	@r4,	r7	;

000082a8 <.Loc.248.1>:
    82a8:	04 56       	add	r6,	r4	;

000082aa <.Loc.249.1>:
    82aa:	a7 12       	call	@r7		;

000082ac <.Loc.250.1>:
    82ac:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x82a2

000082b0 <_msp430_run_done>:
    82b0:	30 41       	ret			

000082b2 <deregister_tm_clones>:
    82b2:	3c 40 4c 98 	mov	#38988,	r12	;#0x984c
    82b6:	3c 90 4c 98 	cmp	#38988,	r12	;#0x984c
    82ba:	07 24       	jz	$+16     	;abs 0x82ca
    82bc:	3d 40 00 00 	mov	#0,	r13	;
    82c0:	0d 93       	cmp	#0,	r13	;r3 As==00
    82c2:	03 24       	jz	$+8      	;abs 0x82ca
    82c4:	3c 40 4c 98 	mov	#38988,	r12	;#0x984c
    82c8:	8d 12       	call	r13		;

000082ca <.L1>:
    82ca:	30 41       	ret			

000082cc <register_tm_clones>:
    82cc:	0a 12       	push	r10		;
    82ce:	3a 40 4c 98 	mov	#38988,	r10	;#0x984c
    82d2:	3a 80 4c 98 	sub	#38988,	r10	;#0x984c
    82d6:	0a 11       	rra	r10		;
    82d8:	0c 4a       	mov	r10,	r12	;
    82da:	b0 12 04 95 	call	#38148		;#0x9504
    82de:	0c 5a       	add	r10,	r12	;
    82e0:	0d 4c       	mov	r12,	r13	;
    82e2:	0d 11       	rra	r13		;
    82e4:	0d 93       	cmp	#0,	r13	;r3 As==00
    82e6:	07 24       	jz	$+16     	;abs 0x82f6
    82e8:	3e 40 00 00 	mov	#0,	r14	;
    82ec:	0e 93       	cmp	#0,	r14	;r3 As==00
    82ee:	03 24       	jz	$+8      	;abs 0x82f6
    82f0:	3c 40 4c 98 	mov	#38988,	r12	;#0x984c
    82f4:	8e 12       	call	r14		;

000082f6 <.L9>:
    82f6:	3a 41       	pop	r10		;
    82f8:	30 41       	ret			

000082fa <__do_global_dtors_aux>:
    82fa:	0a 12       	push	r10		;
    82fc:	09 12       	push	r9		;
    82fe:	c2 93 7c 40 	cmp.b	#0,	&0x407c	;r3 As==00
    8302:	17 20       	jnz	$+48     	;abs 0x8332
    8304:	3a 40 7a 80 	mov	#32890,	r10	;#0x807a
    8308:	3a 80 78 80 	sub	#32888,	r10	;#0x8078
    830c:	0a 11       	rra	r10		;
    830e:	3a 53       	add	#-1,	r10	;r3 As==11
    8310:	39 40 78 80 	mov	#32888,	r9	;#0x8078

00008314 <.L19>:
    8314:	1c 42 7e 40 	mov	&0x407e,r12	;0x407e
    8318:	0c 9a       	cmp	r10,	r12	;
    831a:	0d 28       	jnc	$+28     	;abs 0x8336
    831c:	b0 12 b2 82 	call	#33458		;#0x82b2
    8320:	3d 40 00 00 	mov	#0,	r13	;
    8324:	0d 93       	cmp	#0,	r13	;r3 As==00
    8326:	03 24       	jz	$+8      	;abs 0x832e
    8328:	3c 40 6c 80 	mov	#32876,	r12	;#0x806c
    832c:	8d 12       	call	r13		;

0000832e <.L21>:
    832e:	d2 43 7c 40 	mov.b	#1,	&0x407c	;r3 As==01

00008332 <.L17>:
    8332:	30 40 fe 94 	br	#0x94fe		;

00008336 <.L20>:
    8336:	1c 53       	inc	r12		;
    8338:	82 4c 7e 40 	mov	r12,	&0x407e	;
    833c:	0c 5c       	rla	r12		;
    833e:	0c 59       	add	r9,	r12	;
    8340:	2c 4c       	mov	@r12,	r12	;
    8342:	8c 12       	call	r12		;
    8344:	30 40 14 83 	br	#0x8314		;

00008348 <frame_dummy>:
    8348:	3e 40 00 00 	mov	#0,	r14	;
    834c:	0e 93       	cmp	#0,	r14	;r3 As==00
    834e:	05 24       	jz	$+12     	;abs 0x835a
    8350:	3d 40 80 40 	mov	#16512,	r13	;#0x4080
    8354:	3c 40 6c 80 	mov	#32876,	r12	;#0x806c
    8358:	8e 12       	call	r14		;

0000835a <.L27>:
    835a:	b0 12 cc 82 	call	#33484		;#0x82cc
    835e:	30 41       	ret			

00008360 <sqrt16>:


/* Sqrt.c */
/* Square root by Newton's method */
uint16_t sqrt16(uint32_t x)
{
    8360:	0a 12       	push	r10		;

00008362 <.LCFI0>:
    8362:	09 12       	push	r9		;

00008364 <.LCFI1>:
    8364:	08 12       	push	r8		;

00008366 <.LCFI2>:
    8366:	07 12       	push	r7		;

00008368 <.LCFI3>:
    8368:	06 12       	push	r6		;

0000836a <.LCFI4>:
    836a:	05 12       	push	r5		;

0000836c <.LCFI5>:
    836c:	31 80 1e 00 	sub	#30,	r1	;#0x001e

00008370 <.LCFI6>:
    8370:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    8374:	81 4d 12 00 	mov	r13,	18(r1)	; 0x0012

00008378 <.Loc.31.1>:
    uint16_t hi = 0xffff;
    8378:	b1 43 1c 00 	mov	#-1,	28(r1)	;r3 As==11, 0x001c

0000837c <.Loc.32.1>:
    uint16_t lo = 0;
    837c:	81 43 1a 00 	mov	#0,	26(r1)	;r3 As==00, 0x001a

00008380 <.Loc.33.1>:
    uint16_t mid = ((uint32_t)hi + (uint32_t)lo) >> 1;
    8380:	1c 41 1c 00 	mov	28(r1),	r12	;0x0001c
    8384:	05 4c       	mov	r12,	r5	;
    8386:	46 43       	clr.b	r6		;
    8388:	1c 41 1a 00 	mov	26(r1),	r12	;0x0001a
    838c:	0e 4c       	mov	r12,	r14	;
    838e:	4f 43       	clr.b	r15		;
    8390:	0c 45       	mov	r5,	r12	;
    8392:	0c 5e       	add	r14,	r12	;
    8394:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    8398:	0c 46       	mov	r6,	r12	;
    839a:	0c 6f       	addc	r15,	r12	;
    839c:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    83a0:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    83a4:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    83a8:	12 c3       	clrc			
    83aa:	0d 10       	rrc	r13		;
    83ac:	0c 10       	rrc	r12		;
    83ae:	81 4c 18 00 	mov	r12,	24(r1)	; 0x0018

000083b2 <.Loc.34.1>:
    uint32_t s = 0;
    83b2:	81 43 14 00 	mov	#0,	20(r1)	;r3 As==00, 0x0014
    83b6:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

000083ba <.Loc.36.1>:

    while (s != x && hi - lo > 1) {
    83ba:	30 40 4a 84 	br	#0x844a		;

000083be <.L7>:
        mid = ((uint32_t)hi + (uint32_t)lo) >> 1;
    83be:	1c 41 1c 00 	mov	28(r1),	r12	;0x0001c
    83c2:	09 4c       	mov	r12,	r9	;
    83c4:	4a 43       	clr.b	r10		;
    83c6:	1c 41 1a 00 	mov	26(r1),	r12	;0x0001a
    83ca:	07 4c       	mov	r12,	r7	;
    83cc:	48 43       	clr.b	r8		;
    83ce:	0c 49       	mov	r9,	r12	;
    83d0:	0c 57       	add	r7,	r12	;
    83d2:	81 4c 08 00 	mov	r12,	8(r1)	;
    83d6:	0c 4a       	mov	r10,	r12	;
    83d8:	0c 68       	addc	r8,	r12	;
    83da:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    83de:	1c 41 08 00 	mov	8(r1),	r12	;
    83e2:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    83e6:	12 c3       	clrc			
    83e8:	0d 10       	rrc	r13		;
    83ea:	0c 10       	rrc	r12		;
    83ec:	81 4c 18 00 	mov	r12,	24(r1)	; 0x0018

000083f0 <.Loc.38.1>:
        s = (uint32_t)mid* (uint32_t)mid;
    83f0:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    83f4:	81 4c 04 00 	mov	r12,	4(r1)	;
    83f8:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    83fc:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    8400:	81 4c 00 00 	mov	r12,	0(r1)	;
    8404:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8408:	2e 41       	mov	@r1,	r14	;
    840a:	1f 41 02 00 	mov	2(r1),	r15	;
    840e:	1c 41 04 00 	mov	4(r1),	r12	;
    8412:	1d 41 06 00 	mov	6(r1),	r13	;
    8416:	b0 12 cc 95 	call	#38348		;#0x95cc
    841a:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    841e:	81 4d 16 00 	mov	r13,	22(r1)	; 0x0016

00008422 <.Loc.39.1>:
        if (s < x)
    8422:	91 91 12 00 	cmp	18(r1),	22(r1)	;0x00012, 0x0016
    8426:	16 00 
    8428:	08 28       	jnc	$+18     	;abs 0x843a
    842a:	91 91 16 00 	cmp	22(r1),	18(r1)	;0x00016, 0x0012
    842e:	12 00 
    8430:	09 20       	jnz	$+20     	;abs 0x8444
    8432:	91 91 10 00 	cmp	16(r1),	20(r1)	;0x00010, 0x0014
    8436:	14 00 
    8438:	05 2c       	jc	$+12     	;abs 0x8444

0000843a <.L9>:
            lo = mid;
    843a:	91 41 18 00 	mov	24(r1),	26(r1)	;0x00018, 0x001a
    843e:	1a 00 
    8440:	30 40 4a 84 	br	#0x844a		;

00008444 <.L3>:
        else
            hi = mid;
    8444:	91 41 18 00 	mov	24(r1),	28(r1)	;0x00018, 0x001c
    8448:	1c 00 

0000844a <.L2>:
    uint16_t hi = 0xffff;
    uint16_t lo = 0;
    uint16_t mid = ((uint32_t)hi + (uint32_t)lo) >> 1;
    uint32_t s = 0;

    while (s != x && hi - lo > 1) {
    844a:	91 91 10 00 	cmp	16(r1),	20(r1)	;0x00010, 0x0014
    844e:	14 00 
    8450:	04 20       	jnz	$+10     	;abs 0x845a
    8452:	91 91 12 00 	cmp	18(r1),	22(r1)	;0x00012, 0x0016
    8456:	16 00 
    8458:	07 24       	jz	$+16     	;abs 0x8468

0000845a <.L10>:
    845a:	1d 41 1c 00 	mov	28(r1),	r13	;0x0001c
    845e:	1d 81 1a 00 	sub	26(r1),	r13	;0x0001a
    8462:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8464:	0c 9d       	cmp	r13,	r12	;
    8466:	ab 2b       	jnc	$-168    	;abs 0x83be

00008468 <.L5>:
            lo = mid;
        else
            hi = mid;
    }

    return mid;
    8468:	1c 41 18 00 	mov	24(r1),	r12	;0x00018

0000846c <.Loc.46.1>:
}
    846c:	31 50 1e 00 	add	#30,	r1	;#0x001e
    8470:	30 40 f6 94 	br	#0x94f6		;

00008474 <ACCEL_singleSample>:
//NVM model_t model;

unsigned int count = 1;
model_t model;

void ACCEL_singleSample(threeAxis_t_8* result){
    8474:	21 82       	sub	#4,	r1	;r2 As==10

00008476 <.LCFI7>:
    8476:	81 4c 00 00 	mov	r12,	0(r1)	;

0000847a <.Loc.136.1>:

    //NVM static unsigned int _v_seed = 1;
    static unsigned int _v_seed = 1;

    unsigned int seed = _v_seed;
    847a:	91 42 02 40 	mov	&0x4002,2(r1)	;0x4002
    847e:	02 00 

00008480 <.Loc.138.1>:

    result->x = (seed*17)%85;
    8480:	1d 41 02 00 	mov	2(r1),	r13	;
    8484:	0c 4d       	mov	r13,	r12	;
    8486:	0c 5c       	rla	r12		;
    8488:	0c 5c       	rla	r12		;
    848a:	0c 5c       	rla	r12		;
    848c:	0c 5c       	rla	r12		;
    848e:	0c 5d       	add	r13,	r12	;
    8490:	7d 40 55 00 	mov.b	#85,	r13	;#0x0055
    8494:	b0 12 ec 94 	call	#38124		;#0x94ec
    8498:	4d 4c       	mov.b	r12,	r13	;
    849a:	2c 41       	mov	@r1,	r12	;
    849c:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000084a0 <.Loc.139.1>:
    result->y = (seed*17*17)%85;
    84a0:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    84a4:	1c 41 02 00 	mov	2(r1),	r12	;
    84a8:	b0 12 b8 95 	call	#38328		;#0x95b8
    84ac:	7d 40 55 00 	mov.b	#85,	r13	;#0x0055
    84b0:	b0 12 ec 94 	call	#38124		;#0x94ec
    84b4:	4d 4c       	mov.b	r12,	r13	;
    84b6:	2c 41       	mov	@r1,	r12	;
    84b8:	cc 4d 01 00 	mov.b	r13,	1(r12)	;

000084bc <.Loc.140.1>:
    result->z = (seed*17*17*17)%85;
    84bc:	3d 40 31 13 	mov	#4913,	r13	;#0x1331
    84c0:	1c 41 02 00 	mov	2(r1),	r12	;
    84c4:	b0 12 b8 95 	call	#38328		;#0x95b8
    84c8:	7d 40 55 00 	mov.b	#85,	r13	;#0x0055
    84cc:	b0 12 ec 94 	call	#38124		;#0x94ec
    84d0:	4d 4c       	mov.b	r12,	r13	;
    84d2:	2c 41       	mov	@r1,	r12	;
    84d4:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

000084d8 <.Loc.141.1>:
    _v_seed = ++seed;
    84d8:	91 53 02 00 	inc	2(r1)		;
    84dc:	92 41 02 00 	mov	2(r1),	&0x4002	;
    84e0:	02 40 

000084e2 <.Loc.142.1>:
}
    84e2:	03 43       	nop			
    84e4:	21 52       	add	#4,	r1	;r2 As==10
    84e6:	30 41       	ret			

000084e8 <acquire_window>:


#define accel_sample ACCEL_singleSample

void acquire_window(accelWindow window)
{
    84e8:	31 82       	sub	#8,	r1	;r2 As==11

000084ea <.LCFI8>:
    84ea:	81 4c 00 00 	mov	r12,	0(r1)	;

000084ee <.Loc.150.1>:
    accelReading sample;
    unsigned samplesInWindow = 0;
    84ee:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

000084f2 <.Loc.154.1>:

    TASK_CHECKPOINT();

    while (samplesInWindow < ACCEL_WINDOW_SIZE) {
    84f2:	30 40 26 85 	br	#0x8526		;

000084f6 <.L14>:
        accel_sample(&sample);
    84f6:	0c 41       	mov	r1,	r12	;
    84f8:	3c 50 03 00 	add	#3,	r12	;
    84fc:	b0 12 74 84 	call	#33908		;#0x8474

00008500 <.Loc.158.1>:
        LOG("acquire: sample %u %u %u\r\n", sample.x, sample.y, sample.z);

        window[samplesInWindow++] = sample;
    8500:	1d 41 06 00 	mov	6(r1),	r13	;
    8504:	0c 4d       	mov	r13,	r12	;
    8506:	1c 53       	inc	r12		;
    8508:	81 4c 06 00 	mov	r12,	6(r1)	;
    850c:	0c 4d       	mov	r13,	r12	;
    850e:	0c 5c       	rla	r12		;
    8510:	0c 5d       	add	r13,	r12	;
    8512:	2c 51       	add	@r1,	r12	;
    8514:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    8518:	00 00 
    851a:	dc 41 04 00 	mov.b	4(r1),	1(r12)	;
    851e:	01 00 
    8520:	dc 41 05 00 	mov.b	5(r1),	2(r12)	;
    8524:	02 00 

00008526 <.L13>:
    accelReading sample;
    unsigned samplesInWindow = 0;

    TASK_CHECKPOINT();

    while (samplesInWindow < ACCEL_WINDOW_SIZE) {
    8526:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8528:	1c 91 06 00 	cmp	6(r1),	r12	;
    852c:	e4 2f       	jc	$-54     	;abs 0x84f6

0000852e <.Loc.160.1>:
        accel_sample(&sample);
        LOG("acquire: sample %u %u %u\r\n", sample.x, sample.y, sample.z);

        window[samplesInWindow++] = sample;
    }
}
    852e:	03 43       	nop			
    8530:	31 52       	add	#8,	r1	;r2 As==11
    8532:	30 41       	ret			

00008534 <transform>:

void transform(accelWindow window)
{
    8534:	31 80 06 00 	sub	#6,	r1	;

00008538 <.LCFI9>:
    8538:	81 4c 00 00 	mov	r12,	0(r1)	;

0000853c <.Loc.164.1>:
    unsigned i = 0;
    853c:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00008540 <.Loc.168.1>:

    LOG("transform\r\n");

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    8540:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    8544:	30 40 fa 85 	br	#0x85fa		;

00008548 <.L25>:
        accelReading *sample = &window[i];
    8548:	1d 41 04 00 	mov	4(r1),	r13	;
    854c:	0c 4d       	mov	r13,	r12	;
    854e:	0c 5c       	rla	r12		;
    8550:	0c 5d       	add	r13,	r12	;
    8552:	2d 41       	mov	@r1,	r13	;
    8554:	0d 5c       	add	r12,	r13	;
    8556:	81 4d 02 00 	mov	r13,	2(r1)	;

0000855a <.Loc.171.1>:

        if (sample->x < SAMPLE_NOISE_FLOOR ||
    855a:	1c 41 02 00 	mov	2(r1),	r12	;
    855e:	6c 4c       	mov.b	@r12,	r12	;
    8560:	7d 40 09 00 	mov.b	#9,	r13	;
    8564:	4d 9c       	cmp.b	r12,	r13	;
    8566:	10 2c       	jc	$+34     	;abs 0x8588

00008568 <.Loc.172.1>:
            sample->y < SAMPLE_NOISE_FLOOR ||
    8568:	1c 41 02 00 	mov	2(r1),	r12	;
    856c:	5c 4c 01 00 	mov.b	1(r12),	r12	;

00008570 <.Loc.171.1>:
    LOG("transform\r\n");

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        accelReading *sample = &window[i];

        if (sample->x < SAMPLE_NOISE_FLOOR ||
    8570:	7d 40 09 00 	mov.b	#9,	r13	;
    8574:	4d 9c       	cmp.b	r12,	r13	;
    8576:	08 2c       	jc	$+18     	;abs 0x8588

00008578 <.Loc.173.1>:
            sample->y < SAMPLE_NOISE_FLOOR ||
            sample->z < SAMPLE_NOISE_FLOOR) {
    8578:	1c 41 02 00 	mov	2(r1),	r12	;
    857c:	5c 4c 02 00 	mov.b	2(r12),	r12	;

00008580 <.Loc.172.1>:

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        accelReading *sample = &window[i];

        if (sample->x < SAMPLE_NOISE_FLOOR ||
            sample->y < SAMPLE_NOISE_FLOOR ||
    8580:	7d 40 09 00 	mov.b	#9,	r13	;
    8584:	4d 9c       	cmp.b	r12,	r13	;
    8586:	37 28       	jnc	$+112    	;abs 0x85f6

00008588 <.L17>:
            sample->z < SAMPLE_NOISE_FLOOR) {

            LOG("transform: sample %u %u %u\r\n",
                sample->x, sample->y, sample->z);

            sample->x = (sample->x > SAMPLE_NOISE_FLOOR) ? sample->x : 0;
    8588:	1c 41 02 00 	mov	2(r1),	r12	;
    858c:	6c 4c       	mov.b	@r12,	r12	;
    858e:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8592:	4d 9c       	cmp.b	r12,	r13	;
    8594:	05 2c       	jc	$+12     	;abs 0x85a0

00008596 <.Loc.178.1>:
    8596:	1c 41 02 00 	mov	2(r1),	r12	;
    859a:	6c 4c       	mov.b	@r12,	r12	;
    859c:	30 40 a2 85 	br	#0x85a2		;

000085a0 <.L19>:
    85a0:	4c 43       	clr.b	r12		;

000085a2 <.L20>:
    85a2:	1d 41 02 00 	mov	2(r1),	r13	;
    85a6:	cd 4c 00 00 	mov.b	r12,	0(r13)	;

000085aa <.Loc.179.1>:
            sample->y = (sample->y > SAMPLE_NOISE_FLOOR) ? sample->y : 0;
    85aa:	1c 41 02 00 	mov	2(r1),	r12	;
    85ae:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    85b2:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    85b6:	4d 9c       	cmp.b	r12,	r13	;
    85b8:	06 2c       	jc	$+14     	;abs 0x85c6

000085ba <.Loc.179.1>:
    85ba:	1c 41 02 00 	mov	2(r1),	r12	;
    85be:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    85c2:	30 40 c8 85 	br	#0x85c8		;

000085c6 <.L21>:
    85c6:	4c 43       	clr.b	r12		;

000085c8 <.L22>:
    85c8:	1d 41 02 00 	mov	2(r1),	r13	;
    85cc:	cd 4c 01 00 	mov.b	r12,	1(r13)	;

000085d0 <.Loc.180.1>:
            sample->z = (sample->z > SAMPLE_NOISE_FLOOR) ? sample->z : 0;
    85d0:	1c 41 02 00 	mov	2(r1),	r12	;
    85d4:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    85d8:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    85dc:	4d 9c       	cmp.b	r12,	r13	;
    85de:	06 2c       	jc	$+14     	;abs 0x85ec

000085e0 <.Loc.180.1>:
    85e0:	1c 41 02 00 	mov	2(r1),	r12	;
    85e4:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    85e8:	30 40 ee 85 	br	#0x85ee		;

000085ec <.L23>:
    85ec:	4c 43       	clr.b	r12		;

000085ee <.L24>:
    85ee:	1d 41 02 00 	mov	2(r1),	r13	;
    85f2:	cd 4c 02 00 	mov.b	r12,	2(r13)	;

000085f6 <.L18>:
{
    unsigned i = 0;

    LOG("transform\r\n");

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    85f6:	91 53 04 00 	inc	4(r1)		;

000085fa <.L16>:
    85fa:	6c 43       	mov.b	#2,	r12	;r3 As==10
    85fc:	1c 91 04 00 	cmp	4(r1),	r12	;
    8600:	a3 2f       	jc	$-184    	;abs 0x8548

00008602 <.Loc.183.1>:
            sample->x = (sample->x > SAMPLE_NOISE_FLOOR) ? sample->x : 0;
            sample->y = (sample->y > SAMPLE_NOISE_FLOOR) ? sample->y : 0;
            sample->z = (sample->z > SAMPLE_NOISE_FLOOR) ? sample->z : 0;
        }
    }
}
    8602:	03 43       	nop			
    8604:	31 50 06 00 	add	#6,	r1	;
    8608:	30 41       	ret			

0000860a <featurize>:

void featurize(features_t *features, accelWindow aWin)
{
    860a:	0a 12       	push	r10		;

0000860c <.LCFI10>:
    860c:	09 12       	push	r9		;

0000860e <.LCFI11>:
    860e:	08 12       	push	r8		;

00008610 <.LCFI12>:
    8610:	07 12       	push	r7		;

00008612 <.LCFI13>:
    8612:	06 12       	push	r6		;

00008614 <.LCFI14>:
    8614:	31 80 10 00 	sub	#16,	r1	;#0x0010

00008618 <.LCFI15>:
    8618:	81 4c 02 00 	mov	r12,	2(r1)	;
    861c:	81 4d 00 00 	mov	r13,	0(r1)	;

00008620 <.Loc.192.1>:
    TASK_CHECKPOINT();

    accelReading mean;
    accelReading stddev;

    mean.x = mean.y = mean.z = 0;
    8620:	c1 43 09 00 	mov.b	#0,	9(r1)	;r3 As==00
    8624:	5c 41 09 00 	mov.b	9(r1),	r12	;
    8628:	c1 4c 08 00 	mov.b	r12,	8(r1)	;
    862c:	5c 41 08 00 	mov.b	8(r1),	r12	;
    8630:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

00008634 <.Loc.193.1>:
    stddev.x = stddev.y = stddev.z = 0;
    8634:	c1 43 06 00 	mov.b	#0,	6(r1)	;r3 As==00
    8638:	5c 41 06 00 	mov.b	6(r1),	r12	;
    863c:	c1 4c 05 00 	mov.b	r12,	5(r1)	;
    8640:	5c 41 05 00 	mov.b	5(r1),	r12	;
    8644:	c1 4c 04 00 	mov.b	r12,	4(r1)	;

00008648 <.Loc.195.1>:
    int i;
    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    8648:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    864c:	30 40 ac 86 	br	#0x86ac		;

00008650 <.L28>:
        mean.x += aWin[i].x;  // x
    8650:	5e 41 07 00 	mov.b	7(r1),	r14	;
    8654:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8658:	0c 4d       	mov	r13,	r12	;
    865a:	0c 5c       	rla	r12		;
    865c:	0c 5d       	add	r13,	r12	;
    865e:	2c 51       	add	@r1,	r12	;
    8660:	6c 4c       	mov.b	@r12,	r12	;
    8662:	4c 5e       	add.b	r14,	r12	;
    8664:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8668:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

0000866c <.Loc.197.1>:
        mean.y += aWin[i].y;  // y
    866c:	5e 41 08 00 	mov.b	8(r1),	r14	;
    8670:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8674:	0c 4d       	mov	r13,	r12	;
    8676:	0c 5c       	rla	r12		;
    8678:	0c 5d       	add	r13,	r12	;
    867a:	2c 51       	add	@r1,	r12	;
    867c:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8680:	4c 5e       	add.b	r14,	r12	;
    8682:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8686:	c1 4c 08 00 	mov.b	r12,	8(r1)	;

0000868a <.Loc.198.1>:
        mean.z += aWin[i].z;  // z
    868a:	5e 41 09 00 	mov.b	9(r1),	r14	;
    868e:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8692:	0c 4d       	mov	r13,	r12	;
    8694:	0c 5c       	rla	r12		;
    8696:	0c 5d       	add	r13,	r12	;
    8698:	2c 51       	add	@r1,	r12	;
    869a:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    869e:	4c 5e       	add.b	r14,	r12	;
    86a0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86a4:	c1 4c 09 00 	mov.b	r12,	9(r1)	;

000086a8 <.Loc.195.1>:
    accelReading stddev;

    mean.x = mean.y = mean.z = 0;
    stddev.x = stddev.y = stddev.z = 0;
    int i;
    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    86a8:	91 53 0e 00 	inc	14(r1)		;

000086ac <.L27>:
    86ac:	6c 43       	mov.b	#2,	r12	;r3 As==10
    86ae:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    86b2:	ce 37       	jge	$-98     	;abs 0x8650

000086b4 <.Loc.205.1>:
    /*
       mean.x = mean.x / ACCEL_WINDOW_SIZE;
       mean.y = mean.y / ACCEL_WINDOW_SIZE;
       mean.z = mean.z / ACCEL_WINDOW_SIZE;
       */
    mean.x >>= 2;
    86b4:	5c 41 07 00 	mov.b	7(r1),	r12	;
    86b8:	b0 12 38 95 	call	#38200		;#0x9538
    86bc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86c0:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

000086c4 <.Loc.206.1>:
    mean.y >>= 2;
    86c4:	5c 41 08 00 	mov.b	8(r1),	r12	;
    86c8:	b0 12 38 95 	call	#38200		;#0x9538
    86cc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86d0:	c1 4c 08 00 	mov.b	r12,	8(r1)	;

000086d4 <.Loc.207.1>:
    mean.z >>= 2;
    86d4:	5c 41 09 00 	mov.b	9(r1),	r12	;
    86d8:	b0 12 38 95 	call	#38200		;#0x9538
    86dc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86e0:	c1 4c 09 00 	mov.b	r12,	9(r1)	;

000086e4 <.Loc.209.1>:

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    86e4:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    86e8:	30 40 fe 87 	br	#0x87fe		;

000086ec <.L36>:
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
    86ec:	5e 41 04 00 	mov.b	4(r1),	r14	;
    86f0:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    86f4:	0c 4d       	mov	r13,	r12	;
    86f6:	0c 5c       	rla	r12		;
    86f8:	0c 5d       	add	r13,	r12	;
    86fa:	2c 51       	add	@r1,	r12	;
    86fc:	6c 4c       	mov.b	@r12,	r12	;
    86fe:	5d 41 07 00 	mov.b	7(r1),	r13	;
    8702:	4d 9c       	cmp.b	r12,	r13	;
    8704:	0d 2c       	jc	$+28     	;abs 0x8720

00008706 <.Loc.210.1>:
    8706:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    870a:	0c 4d       	mov	r13,	r12	;
    870c:	0c 5c       	rla	r12		;
    870e:	0c 5d       	add	r13,	r12	;
    8710:	2c 51       	add	@r1,	r12	;
    8712:	6d 4c       	mov.b	@r12,	r13	;
    8714:	5c 41 07 00 	mov.b	7(r1),	r12	;
    8718:	4d 8c       	sub.b	r12,	r13	;
    871a:	4c 4d       	mov.b	r13,	r12	;
    871c:	30 40 38 87 	br	#0x8738		;

00008720 <.L30>:
            : mean.x - aWin[i].x;  // x
    8720:	5f 41 07 00 	mov.b	7(r1),	r15	;
    8724:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8728:	0c 4d       	mov	r13,	r12	;
    872a:	0c 5c       	rla	r12		;
    872c:	0c 5d       	add	r13,	r12	;
    872e:	2c 51       	add	@r1,	r12	;
    8730:	6c 4c       	mov.b	@r12,	r12	;

00008732 <.Loc.210.1>:
    mean.x >>= 2;
    mean.y >>= 2;
    mean.z >>= 2;

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
    8732:	4d 4f       	mov.b	r15,	r13	;
    8734:	4d 8c       	sub.b	r12,	r13	;
    8736:	4c 4d       	mov.b	r13,	r12	;

00008738 <.L31>:
    8738:	4c 5e       	add.b	r14,	r12	;
    873a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    873e:	c1 4c 04 00 	mov.b	r12,	4(r1)	;

00008742 <.Loc.212.1>:
            : mean.x - aWin[i].x;  // x
        stddev.y += aWin[i].y > mean.y ? aWin[i].y - mean.y
    8742:	5e 41 05 00 	mov.b	5(r1),	r14	;
    8746:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    874a:	0c 4d       	mov	r13,	r12	;
    874c:	0c 5c       	rla	r12		;
    874e:	0c 5d       	add	r13,	r12	;
    8750:	2c 51       	add	@r1,	r12	;
    8752:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8756:	5d 41 08 00 	mov.b	8(r1),	r13	;
    875a:	4d 9c       	cmp.b	r12,	r13	;
    875c:	0e 2c       	jc	$+30     	;abs 0x877a

0000875e <.Loc.212.1>:
    875e:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8762:	0c 4d       	mov	r13,	r12	;
    8764:	0c 5c       	rla	r12		;
    8766:	0c 5d       	add	r13,	r12	;
    8768:	2c 51       	add	@r1,	r12	;
    876a:	5d 4c 01 00 	mov.b	1(r12),	r13	;
    876e:	5c 41 08 00 	mov.b	8(r1),	r12	;
    8772:	4d 8c       	sub.b	r12,	r13	;
    8774:	4c 4d       	mov.b	r13,	r12	;
    8776:	30 40 94 87 	br	#0x8794		;

0000877a <.L32>:
            : mean.y - aWin[i].y;  // y
    877a:	5f 41 08 00 	mov.b	8(r1),	r15	;
    877e:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8782:	0c 4d       	mov	r13,	r12	;
    8784:	0c 5c       	rla	r12		;
    8786:	0c 5d       	add	r13,	r12	;
    8788:	2c 51       	add	@r1,	r12	;
    878a:	5c 4c 01 00 	mov.b	1(r12),	r12	;

0000878e <.Loc.212.1>:
    mean.z >>= 2;

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
            : mean.x - aWin[i].x;  // x
        stddev.y += aWin[i].y > mean.y ? aWin[i].y - mean.y
    878e:	4d 4f       	mov.b	r15,	r13	;
    8790:	4d 8c       	sub.b	r12,	r13	;
    8792:	4c 4d       	mov.b	r13,	r12	;

00008794 <.L33>:
    8794:	4c 5e       	add.b	r14,	r12	;
    8796:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    879a:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

0000879e <.Loc.214.1>:
            : mean.y - aWin[i].y;  // y
        stddev.z += aWin[i].z > mean.z ? aWin[i].z - mean.z
    879e:	5e 41 06 00 	mov.b	6(r1),	r14	;
    87a2:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    87a6:	0c 4d       	mov	r13,	r12	;
    87a8:	0c 5c       	rla	r12		;
    87aa:	0c 5d       	add	r13,	r12	;
    87ac:	2c 51       	add	@r1,	r12	;
    87ae:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    87b2:	5d 41 09 00 	mov.b	9(r1),	r13	;
    87b6:	4d 9c       	cmp.b	r12,	r13	;
    87b8:	0e 2c       	jc	$+30     	;abs 0x87d6

000087ba <.Loc.214.1>:
    87ba:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    87be:	0c 4d       	mov	r13,	r12	;
    87c0:	0c 5c       	rla	r12		;
    87c2:	0c 5d       	add	r13,	r12	;
    87c4:	2c 51       	add	@r1,	r12	;
    87c6:	5d 4c 02 00 	mov.b	2(r12),	r13	;
    87ca:	5c 41 09 00 	mov.b	9(r1),	r12	;
    87ce:	4d 8c       	sub.b	r12,	r13	;
    87d0:	4c 4d       	mov.b	r13,	r12	;
    87d2:	30 40 f0 87 	br	#0x87f0		;

000087d6 <.L34>:
            : mean.z - aWin[i].z;  // z
    87d6:	5f 41 09 00 	mov.b	9(r1),	r15	;
    87da:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    87de:	0c 4d       	mov	r13,	r12	;
    87e0:	0c 5c       	rla	r12		;
    87e2:	0c 5d       	add	r13,	r12	;
    87e4:	2c 51       	add	@r1,	r12	;
    87e6:	5c 4c 02 00 	mov.b	2(r12),	r12	;

000087ea <.Loc.214.1>:
    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
        stddev.x += aWin[i].x > mean.x ? aWin[i].x - mean.x
            : mean.x - aWin[i].x;  // x
        stddev.y += aWin[i].y > mean.y ? aWin[i].y - mean.y
            : mean.y - aWin[i].y;  // y
        stddev.z += aWin[i].z > mean.z ? aWin[i].z - mean.z
    87ea:	4d 4f       	mov.b	r15,	r13	;
    87ec:	4d 8c       	sub.b	r12,	r13	;
    87ee:	4c 4d       	mov.b	r13,	r12	;

000087f0 <.L35>:
    87f0:	4c 5e       	add.b	r14,	r12	;
    87f2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    87f6:	c1 4c 06 00 	mov.b	r12,	6(r1)	;

000087fa <.Loc.209.1>:
       */
    mean.x >>= 2;
    mean.y >>= 2;
    mean.z >>= 2;

    for (i = 0; i < ACCEL_WINDOW_SIZE; i++) {
    87fa:	91 53 0e 00 	inc	14(r1)		;

000087fe <.L29>:
    87fe:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8800:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    8804:	73 37       	jge	$-280    	;abs 0x86ec

00008806 <.Loc.222.1>:
    /*
       stddev.x = stddev.x / (ACCEL_WINDOW_SIZE - 1);
       stddev.y = stddev.y / (ACCEL_WINDOW_SIZE - 1);
       stddev.z = stddev.z / (ACCEL_WINDOW_SIZE - 1);
       */
    stddev.x >>= 2;
    8806:	5c 41 04 00 	mov.b	4(r1),	r12	;
    880a:	b0 12 38 95 	call	#38200		;#0x9538
    880e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8812:	c1 4c 04 00 	mov.b	r12,	4(r1)	;

00008816 <.Loc.223.1>:
    stddev.y >>= 2;
    8816:	5c 41 05 00 	mov.b	5(r1),	r12	;
    881a:	b0 12 38 95 	call	#38200		;#0x9538
    881e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8822:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00008826 <.Loc.224.1>:
    stddev.z >>= 2;
    8826:	5c 41 06 00 	mov.b	6(r1),	r12	;
    882a:	b0 12 38 95 	call	#38200		;#0x9538
    882e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8832:	c1 4c 06 00 	mov.b	r12,	6(r1)	;

00008836 <.Loc.226.1>:

    unsigned meanmag = mean.x*mean.x + mean.y*mean.y + mean.z*mean.z;
    8836:	5c 41 07 00 	mov.b	7(r1),	r12	;
    883a:	5d 41 07 00 	mov.b	7(r1),	r13	;
    883e:	b0 12 b8 95 	call	#38328		;#0x95b8
    8842:	06 4c       	mov	r12,	r6	;
    8844:	5c 41 08 00 	mov.b	8(r1),	r12	;
    8848:	5d 41 08 00 	mov.b	8(r1),	r13	;
    884c:	b0 12 b8 95 	call	#38328		;#0x95b8
    8850:	06 5c       	add	r12,	r6	;
    8852:	5c 41 09 00 	mov.b	9(r1),	r12	;
    8856:	5d 41 09 00 	mov.b	9(r1),	r13	;
    885a:	b0 12 b8 95 	call	#38328		;#0x95b8
    885e:	0c 56       	add	r6,	r12	;
    8860:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

00008864 <.Loc.227.1>:
    unsigned stddevmag = stddev.x*stddev.x + stddev.y*stddev.y + stddev.z*stddev.z;
    8864:	5c 41 04 00 	mov.b	4(r1),	r12	;
    8868:	5d 41 04 00 	mov.b	4(r1),	r13	;
    886c:	b0 12 b8 95 	call	#38328		;#0x95b8
    8870:	06 4c       	mov	r12,	r6	;
    8872:	5c 41 05 00 	mov.b	5(r1),	r12	;
    8876:	5d 41 05 00 	mov.b	5(r1),	r13	;
    887a:	b0 12 b8 95 	call	#38328		;#0x95b8
    887e:	06 5c       	add	r12,	r6	;
    8880:	5c 41 06 00 	mov.b	6(r1),	r12	;
    8884:	5d 41 06 00 	mov.b	6(r1),	r13	;
    8888:	b0 12 b8 95 	call	#38328		;#0x95b8
    888c:	0c 56       	add	r6,	r12	;
    888e:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00008892 <.Loc.229.1>:

    features->meanmag   = sqrt16(meanmag);
    8892:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    8896:	07 4c       	mov	r12,	r7	;
    8898:	48 43       	clr.b	r8		;
    889a:	0c 47       	mov	r7,	r12	;
    889c:	0d 48       	mov	r8,	r13	;
    889e:	b0 12 60 83 	call	#33632		;#0x8360
    88a2:	0d 4c       	mov	r12,	r13	;
    88a4:	1c 41 02 00 	mov	2(r1),	r12	;
    88a8:	8c 4d 00 00 	mov	r13,	0(r12)	;

000088ac <.Loc.230.1>:
    features->stddevmag = sqrt16(stddevmag);
    88ac:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    88b0:	09 4c       	mov	r12,	r9	;
    88b2:	4a 43       	clr.b	r10		;
    88b4:	0c 49       	mov	r9,	r12	;
    88b6:	0d 4a       	mov	r10,	r13	;
    88b8:	b0 12 60 83 	call	#33632		;#0x8360
    88bc:	0d 4c       	mov	r12,	r13	;
    88be:	1c 41 02 00 	mov	2(r1),	r12	;
    88c2:	8c 4d 02 00 	mov	r13,	2(r12)	;

000088c6 <.Loc.233.1>:

    LOG("featurize: mean %u sd %u\r\n", features->meanmag, features->stddevmag);
}
    88c6:	03 43       	nop			
    88c8:	31 50 10 00 	add	#16,	r1	;#0x0010
    88cc:	30 40 f8 94 	br	#0x94f8		;

000088d0 <classify>:

class_t classify(features_t *features, model_t *model)
{
    88d0:	31 80 1e 00 	sub	#30,	r1	;#0x001e

000088d4 <.LCFI16>:
    88d4:	81 4c 02 00 	mov	r12,	2(r1)	;
    88d8:	81 4d 00 00 	mov	r13,	0(r1)	;

000088dc <.Loc.237.1>:
    int move_less_error = 0;
    88dc:	81 43 1c 00 	mov	#0,	28(r1)	;r3 As==00, 0x001c

000088e0 <.Loc.238.1>:
    int stat_less_error = 0;
    88e0:	81 43 1a 00 	mov	#0,	26(r1)	;r3 As==00, 0x001a

000088e4 <.Loc.244.1>:
    features_t *model_features;
    int i;

    TASK_CHECKPOINT();

    for (i = 0; i < MODEL_SIZE; ++i) {
    88e4:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018
    88e8:	30 40 64 8a 	br	#0x8a64		;

000088ec <.L53>:
        model_features = &model->stationary[i];
    88ec:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    88f0:	0c 5c       	rla	r12		;
    88f2:	0c 5c       	rla	r12		;
    88f4:	2d 41       	mov	@r1,	r13	;
    88f6:	0d 5c       	add	r12,	r13	;
    88f8:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

000088fc <.Loc.247.1>:

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
    88fc:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8900:	2d 4c       	mov	@r12,	r13	;
    8902:	1c 41 02 00 	mov	2(r1),	r12	;
    8906:	2c 4c       	mov	@r12,	r12	;

00008908 <.Loc.249.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);
    8908:	0c 9d       	cmp	r13,	r12	;
    890a:	0a 2c       	jc	$+22     	;abs 0x8920

0000890c <.Loc.248.1>:

    for (i = 0; i < MODEL_SIZE; ++i) {
        model_features = &model->stationary[i];

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
    890c:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8910:	2e 4c       	mov	@r12,	r14	;
    8912:	1c 41 02 00 	mov	2(r1),	r12	;
    8916:	2d 4c       	mov	@r12,	r13	;

00008918 <.Loc.249.1>:
            : (features->meanmag - model_features->meanmag);
    8918:	0c 4e       	mov	r14,	r12	;
    891a:	0c 8d       	sub	r13,	r12	;
    891c:	30 40 30 89 	br	#0x8930		;

00008920 <.L39>:
    8920:	1c 41 02 00 	mov	2(r1),	r12	;
    8924:	2e 4c       	mov	@r12,	r14	;
    8926:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    892a:	2d 4c       	mov	@r12,	r13	;
    892c:	0c 4e       	mov	r14,	r12	;
    892e:	0c 8d       	sub	r13,	r12	;

00008930 <.L40>:
    TASK_CHECKPOINT();

    for (i = 0; i < MODEL_SIZE; ++i) {
        model_features = &model->stationary[i];

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
    8930:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    8934:	81 43 12 00 	mov	#0,	18(r1)	;r3 As==00, 0x0012

00008938 <.Loc.251.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int stat_sd_err = (model_features->stddevmag > features->stddevmag)
    8938:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    893c:	1d 4c 02 00 	mov	2(r12),	r13	;
    8940:	1c 41 02 00 	mov	2(r1),	r12	;
    8944:	1c 4c 02 00 	mov	2(r12),	r12	;

00008948 <.Loc.253.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);
    8948:	0c 9d       	cmp	r13,	r12	;
    894a:	0c 2c       	jc	$+26     	;abs 0x8964

0000894c <.Loc.252.1>:
        long int stat_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int stat_sd_err = (model_features->stddevmag > features->stddevmag)
            ? (model_features->stddevmag - features->stddevmag)
    894c:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8950:	1e 4c 02 00 	mov	2(r12),	r14	;
    8954:	1c 41 02 00 	mov	2(r1),	r12	;
    8958:	1d 4c 02 00 	mov	2(r12),	r13	;

0000895c <.Loc.253.1>:
            : (features->stddevmag - model_features->stddevmag);
    895c:	0c 4e       	mov	r14,	r12	;
    895e:	0c 8d       	sub	r13,	r12	;
    8960:	30 40 78 89 	br	#0x8978		;

00008964 <.L41>:
    8964:	1c 41 02 00 	mov	2(r1),	r12	;
    8968:	1e 4c 02 00 	mov	2(r12),	r14	;
    896c:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8970:	1d 4c 02 00 	mov	2(r12),	r13	;
    8974:	0c 4e       	mov	r14,	r12	;
    8976:	0c 8d       	sub	r13,	r12	;

00008978 <.L42>:

        long int stat_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int stat_sd_err = (model_features->stddevmag > features->stddevmag)
    8978:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    897c:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e

00008980 <.Loc.255.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);

        model_features = &model->moving[i];
    8980:	1c 41 18 00 	mov	24(r1),	r12	;0x00018
    8984:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8988:	0c 5c       	rla	r12		;
    898a:	0c 5c       	rla	r12		;
    898c:	2d 41       	mov	@r1,	r13	;
    898e:	0d 5c       	add	r12,	r13	;
    8990:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

00008994 <.Loc.257.1>:

        long int move_mean_err = (model_features->meanmag > features->meanmag)
    8994:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8998:	2d 4c       	mov	@r12,	r13	;
    899a:	1c 41 02 00 	mov	2(r1),	r12	;
    899e:	2c 4c       	mov	@r12,	r12	;

000089a0 <.Loc.259.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);
    89a0:	0c 9d       	cmp	r13,	r12	;
    89a2:	0a 2c       	jc	$+22     	;abs 0x89b8

000089a4 <.Loc.258.1>:
            : (features->stddevmag - model_features->stddevmag);

        model_features = &model->moving[i];

        long int move_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
    89a4:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    89a8:	2e 4c       	mov	@r12,	r14	;
    89aa:	1c 41 02 00 	mov	2(r1),	r12	;
    89ae:	2d 4c       	mov	@r12,	r13	;

000089b0 <.Loc.259.1>:
            : (features->meanmag - model_features->meanmag);
    89b0:	0c 4e       	mov	r14,	r12	;
    89b2:	0c 8d       	sub	r13,	r12	;
    89b4:	30 40 c8 89 	br	#0x89c8		;

000089b8 <.L43>:
    89b8:	1c 41 02 00 	mov	2(r1),	r12	;
    89bc:	2e 4c       	mov	@r12,	r14	;
    89be:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    89c2:	2d 4c       	mov	@r12,	r13	;
    89c4:	0c 4e       	mov	r14,	r12	;
    89c6:	0c 8d       	sub	r13,	r12	;

000089c8 <.L44>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);

        model_features = &model->moving[i];

        long int move_mean_err = (model_features->meanmag > features->meanmag)
    89c8:	81 4c 08 00 	mov	r12,	8(r1)	;
    89cc:	81 43 0a 00 	mov	#0,	10(r1)	;r3 As==00, 0x000a

000089d0 <.Loc.261.1>:
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int move_sd_err = (model_features->stddevmag > features->stddevmag)
    89d0:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    89d4:	1d 4c 02 00 	mov	2(r12),	r13	;
    89d8:	1c 41 02 00 	mov	2(r1),	r12	;
    89dc:	1c 4c 02 00 	mov	2(r12),	r12	;

000089e0 <.Loc.263.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);
    89e0:	0c 9d       	cmp	r13,	r12	;
    89e2:	0c 2c       	jc	$+26     	;abs 0x89fc

000089e4 <.Loc.262.1>:
        long int move_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int move_sd_err = (model_features->stddevmag > features->stddevmag)
            ? (model_features->stddevmag - features->stddevmag)
    89e4:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    89e8:	1e 4c 02 00 	mov	2(r12),	r14	;
    89ec:	1c 41 02 00 	mov	2(r1),	r12	;
    89f0:	1d 4c 02 00 	mov	2(r12),	r13	;

000089f4 <.Loc.263.1>:
            : (features->stddevmag - model_features->stddevmag);
    89f4:	0c 4e       	mov	r14,	r12	;
    89f6:	0c 8d       	sub	r13,	r12	;
    89f8:	30 40 10 8a 	br	#0x8a10		;

000089fc <.L45>:
    89fc:	1c 41 02 00 	mov	2(r1),	r12	;
    8a00:	1e 4c 02 00 	mov	2(r12),	r14	;
    8a04:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8a08:	1d 4c 02 00 	mov	2(r12),	r13	;
    8a0c:	0c 4e       	mov	r14,	r12	;
    8a0e:	0c 8d       	sub	r13,	r12	;

00008a10 <.L46>:

        long int move_mean_err = (model_features->meanmag > features->meanmag)
            ? (model_features->meanmag - features->meanmag)
            : (features->meanmag - model_features->meanmag);

        long int move_sd_err = (model_features->stddevmag > features->stddevmag)
    8a10:	81 4c 04 00 	mov	r12,	4(r1)	;
    8a14:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00008a18 <.Loc.265.1>:
            ? (model_features->stddevmag - features->stddevmag)
            : (features->stddevmag - model_features->stddevmag);

        if (move_mean_err < stat_mean_err) {
    8a18:	91 91 12 00 	cmp	18(r1),	10(r1)	;0x00012, 0x000a
    8a1c:	0a 00 
    8a1e:	08 38       	jl	$+18     	;abs 0x8a30
    8a20:	91 91 0a 00 	cmp	10(r1),	18(r1)	;0x0000a, 0x0012
    8a24:	12 00 
    8a26:	08 20       	jnz	$+18     	;abs 0x8a38
    8a28:	91 91 10 00 	cmp	16(r1),	8(r1)	;0x00010
    8a2c:	08 00 
    8a2e:	04 2c       	jc	$+10     	;abs 0x8a38

00008a30 <.L56>:
            move_less_error++;
    8a30:	91 53 1c 00 	inc	28(r1)		;
    8a34:	30 40 3c 8a 	br	#0x8a3c		;

00008a38 <.L47>:
        } else {
            stat_less_error++;
    8a38:	91 53 1a 00 	inc	26(r1)		;

00008a3c <.L49>:
        }

        if (move_sd_err < stat_sd_err) {
    8a3c:	91 91 0e 00 	cmp	14(r1),	6(r1)	;0x0000e
    8a40:	06 00 
    8a42:	08 38       	jl	$+18     	;abs 0x8a54
    8a44:	91 91 06 00 	cmp	6(r1),	14(r1)	; 0x000e
    8a48:	0e 00 
    8a4a:	08 20       	jnz	$+18     	;abs 0x8a5c
    8a4c:	91 91 0c 00 	cmp	12(r1),	4(r1)	;0x0000c
    8a50:	04 00 
    8a52:	04 2c       	jc	$+10     	;abs 0x8a5c

00008a54 <.L57>:
            move_less_error++;
    8a54:	91 53 1c 00 	inc	28(r1)		;
    8a58:	30 40 60 8a 	br	#0x8a60		;

00008a5c <.L50>:
        } else {
            stat_less_error++;
    8a5c:	91 53 1a 00 	inc	26(r1)		;

00008a60 <.L52>:
    features_t *model_features;
    int i;

    TASK_CHECKPOINT();

    for (i = 0; i < MODEL_SIZE; ++i) {
    8a60:	91 53 18 00 	inc	24(r1)		;

00008a64 <.L38>:
    8a64:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f
    8a68:	1c 91 18 00 	cmp	24(r1),	r12	;0x00018
    8a6c:	3f 37       	jge	$-384    	;abs 0x88ec

00008a6e <.Loc.279.1>:
            stat_less_error++;
        }
    }

    class_t class = move_less_error > stat_less_error ?
                        CLASS_MOVING : CLASS_STATIONARY;
    8a6e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8a70:	91 91 1c 00 	cmp	28(r1),	26(r1)	;0x0001c, 0x001a
    8a74:	1a 00 
    8a76:	01 38       	jl	$+4      	;abs 0x8a7a
    8a78:	4c 43       	clr.b	r12		;

00008a7a <.L54>:
    8a7a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008a7e <.Loc.278.1>:
        } else {
            stat_less_error++;
        }
    }

    class_t class = move_less_error > stat_less_error ?
    8a7e:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016

00008a82 <.Loc.282.1>:
                        CLASS_MOVING : CLASS_STATIONARY;
    LOG("classify: class %u\r\n", class);

    return class;
    8a82:	1c 41 16 00 	mov	22(r1),	r12	;0x00016

00008a86 <.Loc.283.1>:
}
    8a86:	31 50 1e 00 	add	#30,	r1	;#0x001e
    8a8a:	30 41       	ret			

00008a8c <record_stats>:

void record_stats(stats_t *stats, class_t class)
{
    8a8c:	21 82       	sub	#4,	r1	;r2 As==10

00008a8e <.LCFI17>:
    8a8e:	81 4c 02 00 	mov	r12,	2(r1)	;
    8a92:	81 4d 00 00 	mov	r13,	0(r1)	;

00008a96 <.Loc.292.1>:
    TASK_CHECKPOINT();

    /* stats->totalCount, stats->movingCount, and stats->stationaryCount have an
     * nv-internal consistency requirement.  This code should be atomic. */

    stats->totalCount++;
    8a96:	1c 41 02 00 	mov	2(r1),	r12	;
    8a9a:	2c 4c       	mov	@r12,	r12	;
    8a9c:	0d 4c       	mov	r12,	r13	;
    8a9e:	1d 53       	inc	r13		;
    8aa0:	1c 41 02 00 	mov	2(r1),	r12	;
    8aa4:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008aa8 <.Loc.294.1>:

    switch (class) {
    8aa8:	2c 41       	mov	@r1,	r12	;
    8aaa:	0c 93       	cmp	#0,	r12	;r3 As==00
    8aac:	10 24       	jz	$+34     	;abs 0x8ace
    8aae:	1c 93       	cmp	#1,	r12	;r3 As==01
    8ab0:	02 24       	jz	$+6      	;abs 0x8ab6

00008ab2 <.Loc.306.1>:
            break;
    }

    LOG("stats: s %u m %u t %u\r\n",
        stats->stationaryCount, stats->movingCount, stats->totalCount);
}
    8ab2:	30 40 e4 8a 	br	#0x8ae4		;

00008ab6 <.L61>:

    stats->totalCount++;

    switch (class) {
        case CLASS_MOVING:
            stats->movingCount++;
    8ab6:	1c 41 02 00 	mov	2(r1),	r12	;
    8aba:	1c 4c 02 00 	mov	2(r12),	r12	;
    8abe:	0d 4c       	mov	r12,	r13	;
    8ac0:	1d 53       	inc	r13		;
    8ac2:	1c 41 02 00 	mov	2(r1),	r12	;
    8ac6:	8c 4d 02 00 	mov	r13,	2(r12)	;

00008aca <.Loc.297.1>:
            break;
    8aca:	30 40 e4 8a 	br	#0x8ae4		;

00008ace <.L60>:

        case CLASS_STATIONARY:
            stats->stationaryCount++;
    8ace:	1c 41 02 00 	mov	2(r1),	r12	;
    8ad2:	1c 4c 04 00 	mov	4(r12),	r12	;
    8ad6:	0d 4c       	mov	r12,	r13	;
    8ad8:	1d 53       	inc	r13		;
    8ada:	1c 41 02 00 	mov	2(r1),	r12	;
    8ade:	8c 4d 04 00 	mov	r13,	4(r12)	;

00008ae2 <.Loc.301.1>:
            break;
    8ae2:	03 43       	nop			

00008ae4 <.L59>:
    }

    LOG("stats: s %u m %u t %u\r\n",
        stats->stationaryCount, stats->movingCount, stats->totalCount);
}
    8ae4:	03 43       	nop			
    8ae6:	21 52       	add	#4,	r1	;r2 As==10
    8ae8:	30 41       	ret			

00008aea <print_stats>:
 unsigned resultStationaryPct;
 unsigned resultMovingPct;
 unsigned sum;

void print_stats(stats_t *stats)
{
    8aea:	21 83       	decd	r1		;

00008aec <.LCFI18>:
    8aec:	81 4c 00 00 	mov	r12,	0(r1)	;

00008af0 <.Loc.318.1>:
   // unsigned resultStationaryPct = stats->stationaryCount * 100 / stats->totalCount;
   // unsigned resultMovingPct = stats->movingCount * 100 / stats->totalCount;
   // unsigned sum = stats->stationaryCount + stats->movingCount;

  resultStationaryPct = stats->stationaryCount * 100 / stats->totalCount;
    8af0:	2c 41       	mov	@r1,	r12	;
    8af2:	1c 4c 04 00 	mov	4(r12),	r12	;
    8af6:	7d 40 64 00 	mov.b	#100,	r13	;#0x0064
    8afa:	b0 12 b8 95 	call	#38328		;#0x95b8
    8afe:	2d 41       	mov	@r1,	r13	;
    8b00:	2d 4d       	mov	@r13,	r13	;
    8b02:	b0 12 e4 94 	call	#38116		;#0x94e4
    8b06:	82 4c 10 41 	mov	r12,	&0x4110	;

00008b0a <.Loc.319.1>:
  resultMovingPct = stats->movingCount * 100 / stats->totalCount;
    8b0a:	2c 41       	mov	@r1,	r12	;
    8b0c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8b10:	7d 40 64 00 	mov.b	#100,	r13	;#0x0064
    8b14:	b0 12 b8 95 	call	#38328		;#0x95b8
    8b18:	2d 41       	mov	@r1,	r13	;
    8b1a:	2d 4d       	mov	@r13,	r13	;
    8b1c:	b0 12 e4 94 	call	#38116		;#0x94e4
    8b20:	82 4c 12 41 	mov	r12,	&0x4112	;

00008b24 <.Loc.320.1>:
  sum = stats->stationaryCount + stats->movingCount;
    8b24:	2c 41       	mov	@r1,	r12	;
    8b26:	1d 4c 04 00 	mov	4(r12),	r13	;
    8b2a:	2c 41       	mov	@r1,	r12	;
    8b2c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8b30:	0c 5d       	add	r13,	r12	;
    8b32:	82 4c 8e 40 	mov	r12,	&0x408e	;

00008b36 <.Loc.330.1>:
           stats->totalCount, sum,
           sum == stats->totalCount && sum == SAMPLES_TO_COLLECT ? 'V' : 'X');

       // QWARK_CHECKPOINT();
    #ifdef UART_DBG
    UART_WriteString("stats: s ");
    8b36:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    8b3a:	b0 12 f2 93 	call	#37874		;#0x93f2

00008b3e <.Loc.332.1>:

    UART_WriteNumber(stats->stationaryCount);
    8b3e:	2c 41       	mov	@r1,	r12	;
    8b40:	1c 4c 04 00 	mov	4(r12),	r12	;
    8b44:	b0 12 40 93 	call	#37696		;#0x9340

00008b48 <.Loc.334.1>:

    UART_WriteString(" (");
    8b48:	3c 40 0a 80 	mov	#32778,	r12	;#0x800a
    8b4c:	b0 12 f2 93 	call	#37874		;#0x93f2

00008b50 <.Loc.336.1>:

    UART_WriteNumber(resultStationaryPct);
    8b50:	1c 42 10 41 	mov	&0x4110,r12	;0x4110
    8b54:	b0 12 40 93 	call	#37696		;#0x9340

00008b58 <.Loc.338.1>:

    UART_WriteString("%) m ");
    8b58:	3c 40 0d 80 	mov	#32781,	r12	;#0x800d
    8b5c:	b0 12 f2 93 	call	#37874		;#0x93f2

00008b60 <.Loc.340.1>:

    UART_WriteNumber(stats->movingCount);
    8b60:	2c 41       	mov	@r1,	r12	;
    8b62:	1c 4c 02 00 	mov	2(r12),	r12	;
    8b66:	b0 12 40 93 	call	#37696		;#0x9340

00008b6a <.Loc.342.1>:

    UART_WriteString(" (");
    8b6a:	3c 40 0a 80 	mov	#32778,	r12	;#0x800a
    8b6e:	b0 12 f2 93 	call	#37874		;#0x93f2

00008b72 <.Loc.344.1>:

    UART_WriteNumber(resultMovingPct);
    8b72:	1c 42 12 41 	mov	&0x4112,r12	;0x4112
    8b76:	b0 12 40 93 	call	#37696		;#0x9340

00008b7a <.Loc.346.1>:

    UART_WriteString("%)");
    8b7a:	3c 40 13 80 	mov	#32787,	r12	;#0x8013
    8b7e:	b0 12 f2 93 	call	#37874		;#0x93f2

00008b82 <.Loc.348.1>:

    UART_WriteString(" sum/tot ");
    8b82:	3c 40 16 80 	mov	#32790,	r12	;#0x8016
    8b86:	b0 12 f2 93 	call	#37874		;#0x93f2

00008b8a <.Loc.350.1>:

    UART_WriteNumber(stats->totalCount);
    8b8a:	2c 41       	mov	@r1,	r12	;
    8b8c:	2c 4c       	mov	@r12,	r12	;
    8b8e:	b0 12 40 93 	call	#37696		;#0x9340

00008b92 <.Loc.352.1>:

    UART_WriteString("/");
    8b92:	3c 40 20 80 	mov	#32800,	r12	;#0x8020
    8b96:	b0 12 f2 93 	call	#37874		;#0x93f2

00008b9a <.Loc.354.1>:

    UART_WriteNumber(sum);
    8b9a:	1c 42 8e 40 	mov	&0x408e,r12	;0x408e
    8b9e:	b0 12 40 93 	call	#37696		;#0x9340

00008ba2 <.Loc.356.1>:

    if(sum == stats->totalCount && sum == SAMPLES_TO_COLLECT)
    8ba2:	2c 41       	mov	@r1,	r12	;
    8ba4:	2d 4c       	mov	@r12,	r13	;
    8ba6:	1c 42 8e 40 	mov	&0x408e,r12	;0x408e
    8baa:	0d 9c       	cmp	r12,	r13	;
    8bac:	0b 20       	jnz	$+24     	;abs 0x8bc4

00008bae <.Loc.356.1>:
    8bae:	1c 42 8e 40 	mov	&0x408e,r12	;0x408e
    8bb2:	3c 90 80 00 	cmp	#128,	r12	;#0x0080
    8bb6:	06 20       	jnz	$+14     	;abs 0x8bc4

00008bb8 <.Loc.357.1>:
    UART_WriteString(" V");
    8bb8:	3c 40 22 80 	mov	#32802,	r12	;#0x8022
    8bbc:	b0 12 f2 93 	call	#37874		;#0x93f2
    8bc0:	30 40 cc 8b 	br	#0x8bcc		;

00008bc4 <.L64>:
    else
    UART_WriteString(" X");
    8bc4:	3c 40 25 80 	mov	#32805,	r12	;#0x8025
    8bc8:	b0 12 f2 93 	call	#37874		;#0x93f2

00008bcc <.L65>:


    UART_WriteString("\r\n");
    8bcc:	3c 40 28 80 	mov	#32808,	r12	;#0x8028
    8bd0:	b0 12 f2 93 	call	#37874		;#0x93f2

00008bd4 <.Loc.368.1>:

  #else

  #endif

}
    8bd4:	03 43       	nop			
    8bd6:	21 53       	incd	r1		;
    8bd8:	30 41       	ret			

00008bda <warmup_sensor>:

void warmup_sensor(void)
{
    8bda:	31 80 06 00 	sub	#6,	r1	;

00008bde <.LCFI19>:
    unsigned discardedSamplesCount = 0;
    8bde:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00008be2 <.Loc.379.1>:

    TASK_CHECKPOINT();

    LOG("warmup\r\n");

    while (discardedSamplesCount++ < NUM_WARMUP_SAMPLES) {
    8be2:	30 40 ee 8b 	br	#0x8bee		;

00008be6 <.L68>:
        accel_sample(&sample);
    8be6:	0c 41       	mov	r1,	r12	;
    8be8:	1c 53       	inc	r12		;
    8bea:	b0 12 74 84 	call	#33908		;#0x8474

00008bee <.L67>:

    TASK_CHECKPOINT();

    LOG("warmup\r\n");

    while (discardedSamplesCount++ < NUM_WARMUP_SAMPLES) {
    8bee:	1c 41 04 00 	mov	4(r1),	r12	;
    8bf2:	0d 4c       	mov	r12,	r13	;
    8bf4:	1d 53       	inc	r13		;
    8bf6:	81 4d 04 00 	mov	r13,	4(r1)	;
    8bfa:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8bfc:	0d 9c       	cmp	r12,	r13	;
    8bfe:	f3 2f       	jc	$-24     	;abs 0x8be6

00008c00 <.Loc.382.1>:
        accel_sample(&sample);
    }
}
    8c00:	03 43       	nop			
    8c02:	31 50 06 00 	add	#6,	r1	;
    8c06:	30 41       	ret			

00008c08 <train>:

void train(features_t *classModel)
{
    8c08:	31 80 12 00 	sub	#18,	r1	;#0x0012

00008c0c <.LCFI20>:
    8c0c:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c10 <.Loc.390.1>:
    accelWindow sampleWindow;
    features_t features;
    unsigned i;

    warmup_sensor();
    8c10:	b0 12 da 8b 	call	#35802		;#0x8bda

00008c14 <.Loc.392.1>:

    for (i = 0; i < MODEL_SIZE; ++i) {
    8c14:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010
    8c18:	30 40 58 8c 	br	#0x8c58		;

00008c1c <.L71>:
        acquire_window(sampleWindow);
    8c1c:	0c 41       	mov	r1,	r12	;
    8c1e:	3c 50 07 00 	add	#7,	r12	;
    8c22:	b0 12 e8 84 	call	#34024		;#0x84e8

00008c26 <.Loc.394.1>:
        transform(sampleWindow);
    8c26:	0c 41       	mov	r1,	r12	;
    8c28:	3c 50 07 00 	add	#7,	r12	;
    8c2c:	b0 12 34 85 	call	#34100		;#0x8534

00008c30 <.Loc.395.1>:
        featurize(&features, sampleWindow);
    8c30:	0d 41       	mov	r1,	r13	;
    8c32:	3d 50 07 00 	add	#7,	r13	;
    8c36:	0c 41       	mov	r1,	r12	;
    8c38:	2c 53       	incd	r12		;
    8c3a:	b0 12 0a 86 	call	#34314		;#0x860a

00008c3e <.Loc.399.1>:

        TASK_CHECKPOINT();

        classModel[i] = features;
    8c3e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8c42:	0c 5c       	rla	r12		;
    8c44:	0c 5c       	rla	r12		;
    8c46:	2c 51       	add	@r1,	r12	;
    8c48:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    8c4c:	00 00 
    8c4e:	9c 41 04 00 	mov	4(r1),	2(r12)	;
    8c52:	02 00 

00008c54 <.Loc.392.1>:
    features_t features;
    unsigned i;

    warmup_sensor();

    for (i = 0; i < MODEL_SIZE; ++i) {
    8c54:	91 53 10 00 	inc	16(r1)		;

00008c58 <.L70>:
    8c58:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f
    8c5c:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8c60:	dd 2f       	jc	$-68     	;abs 0x8c1c

00008c62 <.Loc.405.1>:
    }

    PRINTF("train: done: mn %u sd %u\r\n",
           features.meanmag, features.stddevmag);
#ifdef UART_DBG
    UART_WriteString("train: done: mn ");
    8c62:	3c 40 2b 80 	mov	#32811,	r12	;#0x802b
    8c66:	b0 12 f2 93 	call	#37874		;#0x93f2

00008c6a <.Loc.406.1>:
    UART_WriteNumber(features.meanmag);
    8c6a:	1c 41 02 00 	mov	2(r1),	r12	;
    8c6e:	b0 12 40 93 	call	#37696		;#0x9340

00008c72 <.Loc.407.1>:
    UART_WriteString(" sd ");
    8c72:	3c 40 3c 80 	mov	#32828,	r12	;#0x803c
    8c76:	b0 12 f2 93 	call	#37874		;#0x93f2

00008c7a <.Loc.408.1>:
    UART_WriteNumber(features.stddevmag);
    8c7a:	1c 41 04 00 	mov	4(r1),	r12	;
    8c7e:	b0 12 40 93 	call	#37696		;#0x9340

00008c82 <.Loc.409.1>:
    UART_WriteString("\r\n");
    8c82:	3c 40 28 80 	mov	#32808,	r12	;#0x8028
    8c86:	b0 12 f2 93 	call	#37874		;#0x93f2

00008c8a <.Loc.414.1>:
#else

#endif

}
    8c8a:	03 43       	nop			
    8c8c:	31 50 12 00 	add	#18,	r1	;#0x0012
    8c90:	30 41       	ret			

00008c92 <recognize>:

void recognize(model_t *model)
{
    8c92:	31 80 1a 00 	sub	#26,	r1	;#0x001a

00008c96 <.LCFI21>:
    8c96:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c9a <.Loc.429.1>:
    accelWindow sampleWindow;
    features_t features;
    class_t class;
    unsigned i;

    stats.totalCount = 0;
    8c9a:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00008c9e <.Loc.430.1>:
    stats.stationaryCount = 0;
    8c9e:	81 43 14 00 	mov	#0,	20(r1)	;r3 As==00, 0x0014

00008ca2 <.Loc.431.1>:
    stats.movingCount = 0;
    8ca2:	81 43 12 00 	mov	#0,	18(r1)	;r3 As==00, 0x0012

00008ca6 <.Loc.433.1>:

    for (i = 0; i < SAMPLES_TO_COLLECT; ++i) {
    8ca6:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018
    8caa:	30 40 f0 8c 	br	#0x8cf0		;

00008cae <.L74>:
        acquire_window(sampleWindow);
    8cae:	0c 41       	mov	r1,	r12	;
    8cb0:	3c 50 07 00 	add	#7,	r12	;
    8cb4:	b0 12 e8 84 	call	#34024		;#0x84e8

00008cb8 <.Loc.435.1>:
        transform(sampleWindow);
    8cb8:	0c 41       	mov	r1,	r12	;
    8cba:	3c 50 07 00 	add	#7,	r12	;
    8cbe:	b0 12 34 85 	call	#34100		;#0x8534

00008cc2 <.Loc.436.1>:
        featurize(&features, sampleWindow);
    8cc2:	0d 41       	mov	r1,	r13	;
    8cc4:	3d 50 07 00 	add	#7,	r13	;
    8cc8:	0c 41       	mov	r1,	r12	;
    8cca:	2c 53       	incd	r12		;
    8ccc:	b0 12 0a 86 	call	#34314		;#0x860a

00008cd0 <.Loc.437.1>:
        class = classify(&features, model);
    8cd0:	0c 41       	mov	r1,	r12	;
    8cd2:	2c 53       	incd	r12		;
    8cd4:	2d 41       	mov	@r1,	r13	;
    8cd6:	b0 12 d0 88 	call	#35024		;#0x88d0
    8cda:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016

00008cde <.Loc.438.1>:
        record_stats(&stats, class);
    8cde:	0c 41       	mov	r1,	r12	;
    8ce0:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8ce4:	1d 41 16 00 	mov	22(r1),	r13	;0x00016
    8ce8:	b0 12 8c 8a 	call	#35468		;#0x8a8c

00008cec <.Loc.433.1>:

    stats.totalCount = 0;
    stats.stationaryCount = 0;
    stats.movingCount = 0;

    for (i = 0; i < SAMPLES_TO_COLLECT; ++i) {
    8cec:	91 53 18 00 	inc	24(r1)		;

00008cf0 <.L73>:
    8cf0:	7c 40 7f 00 	mov.b	#127,	r12	;#0x007f
    8cf4:	1c 91 18 00 	cmp	24(r1),	r12	;0x00018
    8cf8:	da 2f       	jc	$-74     	;abs 0x8cae

00008cfa <.Loc.440.1>:
        transform(sampleWindow);
        featurize(&features, sampleWindow);
        class = classify(&features, model);
        record_stats(&stats, class);
    }
    print_stats(&stats);
    8cfa:	0c 41       	mov	r1,	r12	;
    8cfc:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8d00:	b0 12 ea 8a 	call	#35562		;#0x8aea

00008d04 <.Loc.441.1>:
}
    8d04:	03 43       	nop			
    8d06:	31 50 1a 00 	add	#26,	r1	;#0x001a
    8d0a:	30 41       	ret			

00008d0c <end_of_benchmark>:

void end_of_benchmark(void)
{
    LED_CTRL = 0x00;
    8d0c:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8d10:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

00008d14 <.Loc.448.1>:
    PRINTF("This is the end of the AR benchmark\n");
#ifdef UART_DBG
    UART_WriteString("This is the end of the AR benchmark\n\r");
    8d14:	3c 40 41 80 	mov	#32833,	r12	;#0x8041
    8d18:	b0 12 f2 93 	call	#37874		;#0x93f2

00008d1c <.Loc.450.1>:
#endif
    exit(0);
    8d1c:	4c 43       	clr.b	r12		;
    8d1e:	b0 12 fa 95 	call	#38394		;#0x95fa

00008d22 <count_error>:
}

void count_error(void)
{
    PRINTF("An error occured during count, count = %d\n", count);
}
    8d22:	03 43       	nop			
    8d24:	30 41       	ret			

00008d26 <select_mode>:


run_mode_t select_mode(uint8_t *prev_pin_state)
{
    8d26:	21 82       	sub	#4,	r1	;r2 As==10

00008d28 <.LCFI22>:
    8d28:	81 4c 00 00 	mov	r12,	0(r1)	;

00008d2c <.Loc.466.1>:
    uint8_t pin_state;

    TASK_CHECKPOINT();

    count = count + 1;
    8d2c:	1c 42 00 40 	mov	&0x4000,r12	;0x4000
    8d30:	1c 53       	inc	r12		;
    8d32:	82 4c 00 40 	mov	r12,	&0x4000	;

00008d36 <.Loc.475.1>:
     *      1,2 = MODE_TRAIN_MOVING
     *      3,4 = MODE_TRAIN_STATIONARY
     *      5,6 = MODE_RECOGNIZE
     *      7   = END OF BENCHMARK
     */
    switch(count) {
    8d36:	1c 42 00 40 	mov	&0x4000,r12	;0x4000
    8d3a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8d3c:	0d 9c       	cmp	r12,	r13	;
    8d3e:	07 28       	jnc	$+16     	;abs 0x8d4e
    8d40:	3c 90 03 00 	cmp	#3,	r12	;
    8d44:	11 2c       	jc	$+36     	;abs 0x8d68
    8d46:	1c 93       	cmp	#1,	r12	;r3 As==01
    8d48:	1b 28       	jnc	$+56     	;abs 0x8d80
    8d4a:	30 40 60 8d 	br	#0x8d60		;

00008d4e <.L79>:
    8d4e:	7d 40 06 00 	mov.b	#6,	r13	;
    8d52:	0d 9c       	cmp	r12,	r13	;
    8d54:	0d 2c       	jc	$+28     	;abs 0x8d70
    8d56:	3c 90 07 00 	cmp	#7,	r12	;
    8d5a:	0e 24       	jz	$+30     	;abs 0x8d78
    8d5c:	30 40 80 8d 	br	#0x8d80		;

00008d60 <.L89>:
        case 1:
        case 2:
            pin_state = MODE_TRAIN_MOVING;
    8d60:	d1 43 03 00 	mov.b	#1,	3(r1)	;r3 As==01

00008d64 <.Loc.479.1>:
            break;
    8d64:	30 40 8a 8d 	br	#0x8d8a		;

00008d68 <.L80>:
        case 3:
        case 4:
            pin_state = MODE_TRAIN_STATIONARY;
    8d68:	e1 43 03 00 	mov.b	#2,	3(r1)	;r3 As==10

00008d6c <.Loc.483.1>:
            break;
    8d6c:	30 40 8a 8d 	br	#0x8d8a		;

00008d70 <.L82>:
        case 5:
        case 6:
            pin_state = MODE_RECOGNIZE;
    8d70:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00008d74 <.Loc.487.1>:
            break;
    8d74:	30 40 8a 8d 	br	#0x8d8a		;

00008d78 <.L83>:
        case 7:
            end_of_benchmark();
    8d78:	b0 12 0c 8d 	call	#36108		;#0x8d0c

00008d7c <.Loc.490.1>:
            break;
    8d7c:	30 40 8a 8d 	br	#0x8d8a		;

00008d80 <.L78>:
        default:
            pin_state = MODE_IDLE;
    8d80:	f1 40 03 00 	mov.b	#3,	3(r1)	;
    8d84:	03 00 

00008d86 <.Loc.493.1>:
            count_error();
    8d86:	b0 12 22 8d 	call	#36130		;#0x8d22

00008d8a <.L84>:

    //pin_state = GPIO(PORT_AUX, IN) & (BIT(PIN_AUX_1) | BIT(PIN_AUX_2));

    // Don't re-launch training after finishing training
    // Vito: could have done this while assigning pin_state. But keep is the same as the original
    if ((pin_state == MODE_TRAIN_STATIONARY ||
    8d8a:	e1 93 03 00 	cmp.b	#2,	3(r1)	;r3 As==10
    8d8e:	03 24       	jz	$+8      	;abs 0x8d96

00008d90 <.Loc.500.1>:
    8d90:	d1 93 03 00 	cmp.b	#1,	3(r1)	;r3 As==01
    8d94:	0a 20       	jnz	$+22     	;abs 0x8daa

00008d96 <.L85>:
        pin_state == MODE_TRAIN_MOVING) &&
        pin_state == *prev_pin_state) {
    8d96:	2c 41       	mov	@r1,	r12	;
    8d98:	6c 4c       	mov.b	@r12,	r12	;

00008d9a <.Loc.501.1>:
    //pin_state = GPIO(PORT_AUX, IN) & (BIT(PIN_AUX_1) | BIT(PIN_AUX_2));

    // Don't re-launch training after finishing training
    // Vito: could have done this while assigning pin_state. But keep is the same as the original
    if ((pin_state == MODE_TRAIN_STATIONARY ||
        pin_state == MODE_TRAIN_MOVING) &&
    8d9a:	c1 9c 03 00 	cmp.b	r12,	3(r1)	;
    8d9e:	05 20       	jnz	$+12     	;abs 0x8daa

00008da0 <.Loc.503.1>:
        pin_state == *prev_pin_state) {
        pin_state = MODE_IDLE;
    8da0:	f1 40 03 00 	mov.b	#3,	3(r1)	;
    8da4:	03 00 
    8da6:	30 40 b2 8d 	br	#0x8db2		;

00008daa <.L86>:
    } else {
        *prev_pin_state = pin_state;
    8daa:	2c 41       	mov	@r1,	r12	;
    8dac:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    8db0:	00 00 

00008db2 <.L87>:
    }

    LOG("selectMode: pins %04x\r\n", pin_state);

    return (run_mode_t)pin_state;
    8db2:	5c 41 03 00 	mov.b	3(r1),	r12	;

00008db6 <.Loc.511.1>:
}
    8db6:	21 52       	add	#4,	r1	;r2 As==10
    8db8:	30 41       	ret			

00008dba <init>:

void init()
{
    WDTCTL = WDTPW | WDTHOLD; // Stop WDT
    8dba:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    8dbe:	bc 40 80 5a 	mov	#23168,	0(r12)	;#0x5a80
    8dc2:	00 00 

00008dc4 <.Loc.516.1>:
   __asm__ __volatile__ ("nop");
    8dc4:	03 43       	nop			

00008dc6 <.Loc.517.1>:
    eint();
    8dc6:	32 d2       	eint			
    8dc8:	03 43       	nop			

00008dca <.Loc.518.1>:
  UART_BAUD = BAUD;                   // Init UART
    8dca:	7c 40 82 00 	mov.b	#130,	r12	;#0x0082
    8dce:	bc 42 00 00 	mov	#8,	0(r12)	;r2 As==11

00008dd2 <.Loc.519.1>:
    UART_CTL  = UART_EN;
    8dd2:	7c 40 80 00 	mov.b	#128,	r12	;#0x0080
    8dd6:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00008dda <.Loc.521.1>:
    //Enable QWARK
    QWARK_CTL = QWARK_EN;
    8dda:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    8dde:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00008de2 <.Loc.529.1>:
    // init timer
#ifdef CHECKPOINT_TIMER
    checkpoint_timer_init();
#endif

}
    8de2:	03 43       	nop			
    8de4:	30 41       	ret			

00008de6 <init_moving>:
void init_moving (void){

   model.moving[0].meanmag = 36;
    8de6:	b2 40 24 00 	mov	#36,	&0x40d0	;#0x0024
    8dea:	d0 40 

00008dec <.Loc.533.1>:
   model.moving[0].stddevmag = 30;
    8dec:	b2 40 1e 00 	mov	#30,	&0x40d2	;#0x001e
    8df0:	d2 40 

00008df2 <.Loc.535.1>:

   model.moving[1].meanmag = 56;
    8df2:	b2 40 38 00 	mov	#56,	&0x40d4	;#0x0038
    8df6:	d4 40 

00008df8 <.Loc.536.1>:
   model.moving[1].stddevmag = 22;
    8df8:	b2 40 16 00 	mov	#22,	&0x40d6	;#0x0016
    8dfc:	d6 40 

00008dfe <.Loc.538.1>:

   model.moving[2].meanmag = 40;
    8dfe:	b2 40 28 00 	mov	#40,	&0x40d8	;#0x0028
    8e02:	d8 40 

00008e04 <.Loc.539.1>:
   model.moving[2].stddevmag = 30;
    8e04:	b2 40 1e 00 	mov	#30,	&0x40da	;#0x001e
    8e08:	da 40 

00008e0a <.Loc.541.1>:

   model.moving[3].meanmag = 48;
    8e0a:	b2 40 30 00 	mov	#48,	&0x40dc	;#0x0030
    8e0e:	dc 40 

00008e10 <.Loc.542.1>:
   model.moving[3].stddevmag = 30;
    8e10:	b2 40 1e 00 	mov	#30,	&0x40de	;#0x001e
    8e14:	de 40 

00008e16 <.Loc.544.1>:

   model.moving[4].meanmag = 54;
    8e16:	b2 40 36 00 	mov	#54,	&0x40e0	;#0x0036
    8e1a:	e0 40 

00008e1c <.Loc.545.1>:
   model.moving[4].stddevmag = 20;
    8e1c:	b2 40 14 00 	mov	#20,	&0x40e2	;#0x0014
    8e20:	e2 40 

00008e22 <.Loc.547.1>:

   model.moving[5].meanmag = 50;
    8e22:	b2 40 32 00 	mov	#50,	&0x40e4	;#0x0032
    8e26:	e4 40 

00008e28 <.Loc.548.1>:
   model.moving[5].stddevmag = 34;
    8e28:	b2 40 22 00 	mov	#34,	&0x40e6	;#0x0022
    8e2c:	e6 40 

00008e2e <.Loc.550.1>:

   model.moving[6].meanmag = 56;
    8e2e:	b2 40 38 00 	mov	#56,	&0x40e8	;#0x0038
    8e32:	e8 40 

00008e34 <.Loc.551.1>:
   model.moving[6].stddevmag = 22;
    8e34:	b2 40 16 00 	mov	#22,	&0x40ea	;#0x0016
    8e38:	ea 40 

00008e3a <.Loc.553.1>:

   model.moving[7].meanmag = 58;
    8e3a:	b2 40 3a 00 	mov	#58,	&0x40ec	;#0x003a
    8e3e:	ec 40 

00008e40 <.Loc.554.1>:
   model.moving[7].stddevmag = 24;
    8e40:	b2 40 18 00 	mov	#24,	&0x40ee	;#0x0018
    8e44:	ee 40 

00008e46 <.Loc.556.1>:

   model.moving[8].meanmag = 46;
    8e46:	b2 40 2e 00 	mov	#46,	&0x40f0	;#0x002e
    8e4a:	f0 40 

00008e4c <.Loc.557.1>:
   model.moving[8].stddevmag = 30;
    8e4c:	b2 40 1e 00 	mov	#30,	&0x40f2	;#0x001e
    8e50:	f2 40 

00008e52 <.Loc.559.1>:

   model.moving[9].meanmag = 52;
    8e52:	b2 40 34 00 	mov	#52,	&0x40f4	;#0x0034
    8e56:	f4 40 

00008e58 <.Loc.560.1>:
   model.moving[9].stddevmag = 20;
    8e58:	b2 40 14 00 	mov	#20,	&0x40f6	;#0x0014
    8e5c:	f6 40 

00008e5e <.Loc.562.1>:

   model.moving[10].meanmag = 50;
    8e5e:	b2 40 32 00 	mov	#50,	&0x40f8	;#0x0032
    8e62:	f8 40 

00008e64 <.Loc.563.1>:
   model.moving[10].stddevmag = 34;
    8e64:	b2 40 22 00 	mov	#34,	&0x40fa	;#0x0022
    8e68:	fa 40 

00008e6a <.Loc.565.1>:

   model.moving[11].meanmag = 56;
    8e6a:	b2 40 38 00 	mov	#56,	&0x40fc	;#0x0038
    8e6e:	fc 40 

00008e70 <.Loc.566.1>:
   model.moving[11].stddevmag = 22;
    8e70:	b2 40 16 00 	mov	#22,	&0x40fe	;#0x0016
    8e74:	fe 40 

00008e76 <.Loc.568.1>:

   model.moving[12].meanmag = 56;
    8e76:	b2 40 38 00 	mov	#56,	&0x4100	;#0x0038
    8e7a:	00 41 

00008e7c <.Loc.569.1>:
   model.moving[12].stddevmag = 24;
    8e7c:	b2 40 18 00 	mov	#24,	&0x4102	;#0x0018
    8e80:	02 41 

00008e82 <.Loc.571.1>:

   model.moving[13].meanmag = 46;
    8e82:	b2 40 2e 00 	mov	#46,	&0x4104	;#0x002e
    8e86:	04 41 

00008e88 <.Loc.572.1>:
   model.moving[13].stddevmag = 30;
    8e88:	b2 40 1e 00 	mov	#30,	&0x4106	;#0x001e
    8e8c:	06 41 

00008e8e <.Loc.574.1>:

   model.moving[14].meanmag = 52;
    8e8e:	b2 40 34 00 	mov	#52,	&0x4108	;#0x0034
    8e92:	08 41 

00008e94 <.Loc.575.1>:
   model.moving[14].stddevmag = 20;
    8e94:	b2 40 14 00 	mov	#20,	&0x410a	;#0x0014
    8e98:	0a 41 

00008e9a <.Loc.577.1>:

   model.moving[15].meanmag = 50;
    8e9a:	b2 40 32 00 	mov	#50,	&0x410c	;#0x0032
    8e9e:	0c 41 

00008ea0 <.Loc.578.1>:
   model.moving[15].stddevmag = 34;
    8ea0:	b2 40 22 00 	mov	#34,	&0x410e	;#0x0022
    8ea4:	0e 41 

00008ea6 <.Loc.579.1>:
}
    8ea6:	03 43       	nop			
    8ea8:	30 41       	ret			

00008eaa <init_stationary>:
void init_stationary(void){

      model.stationary[0].meanmag = 56;
    8eaa:	b2 40 38 00 	mov	#56,	&0x4090	;#0x0038
    8eae:	90 40 

00008eb0 <.Loc.583.1>:
      model.stationary[0].stddevmag = 24;
    8eb0:	b2 40 18 00 	mov	#24,	&0x4092	;#0x0018
    8eb4:	92 40 

00008eb6 <.Loc.585.1>:

      model.stationary[1].meanmag = 46;
    8eb6:	b2 40 2e 00 	mov	#46,	&0x4094	;#0x002e
    8eba:	94 40 

00008ebc <.Loc.586.1>:
      model.stationary[1].stddevmag = 30;
    8ebc:	b2 40 1e 00 	mov	#30,	&0x4096	;#0x001e
    8ec0:	96 40 

00008ec2 <.Loc.588.1>:

      model.stationary[2].meanmag = 52;
    8ec2:	b2 40 34 00 	mov	#52,	&0x4098	;#0x0034
    8ec6:	98 40 

00008ec8 <.Loc.589.1>:
      model.stationary[2].stddevmag = 20;
    8ec8:	b2 40 14 00 	mov	#20,	&0x409a	;#0x0014
    8ecc:	9a 40 

00008ece <.Loc.591.1>:

      model.stationary[3].meanmag = 50;
    8ece:	b2 40 32 00 	mov	#50,	&0x409c	;#0x0032
    8ed2:	9c 40 

00008ed4 <.Loc.592.1>:
      model.stationary[3].stddevmag = 34;
    8ed4:	b2 40 22 00 	mov	#34,	&0x409e	;#0x0022
    8ed8:	9e 40 

00008eda <.Loc.594.1>:

      model.stationary[4].meanmag = 56;
    8eda:	b2 40 38 00 	mov	#56,	&0x40a0	;#0x0038
    8ede:	a0 40 

00008ee0 <.Loc.595.1>:
      model.stationary[4].stddevmag = 22;
    8ee0:	b2 40 16 00 	mov	#22,	&0x40a2	;#0x0016
    8ee4:	a2 40 

00008ee6 <.Loc.597.1>:

      model.stationary[5].meanmag = 54;
    8ee6:	b2 40 36 00 	mov	#54,	&0x40a4	;#0x0036
    8eea:	a4 40 

00008eec <.Loc.598.1>:
      model.stationary[5].stddevmag = 24;
    8eec:	b2 40 18 00 	mov	#24,	&0x40a6	;#0x0018
    8ef0:	a6 40 

00008ef2 <.Loc.600.1>:

      model.stationary[6].meanmag = 46;
    8ef2:	b2 40 2e 00 	mov	#46,	&0x40a8	;#0x002e
    8ef6:	a8 40 

00008ef8 <.Loc.601.1>:
      model.stationary[6].stddevmag = 30;
    8ef8:	b2 40 1e 00 	mov	#30,	&0x40aa	;#0x001e
    8efc:	aa 40 

00008efe <.Loc.603.1>:

      model.stationary[7].meanmag = 52;
    8efe:	b2 40 34 00 	mov	#52,	&0x40ac	;#0x0034
    8f02:	ac 40 

00008f04 <.Loc.604.1>:
      model.stationary[7].stddevmag = 20;
    8f04:	b2 40 14 00 	mov	#20,	&0x40ae	;#0x0014
    8f08:	ae 40 

00008f0a <.Loc.606.1>:

      model.stationary[8].meanmag = 48;
    8f0a:	b2 40 30 00 	mov	#48,	&0x40b0	;#0x0030
    8f0e:	b0 40 

00008f10 <.Loc.607.1>:
      model.stationary[8].stddevmag = 34;
    8f10:	b2 40 22 00 	mov	#34,	&0x40b2	;#0x0022
    8f14:	b2 40 

00008f16 <.Loc.609.1>:

      model.stationary[9].meanmag = 56;
    8f16:	b2 40 38 00 	mov	#56,	&0x40b4	;#0x0038
    8f1a:	b4 40 

00008f1c <.Loc.610.1>:
      model.stationary[9].stddevmag = 22;
    8f1c:	b2 40 16 00 	mov	#22,	&0x40b6	;#0x0016
    8f20:	b6 40 

00008f22 <.Loc.612.1>:

      model.stationary[10].meanmag = 54;
    8f22:	b2 40 36 00 	mov	#54,	&0x40b8	;#0x0036
    8f26:	b8 40 

00008f28 <.Loc.613.1>:
      model.stationary[10].stddevmag = 24;
    8f28:	b2 40 18 00 	mov	#24,	&0x40ba	;#0x0018
    8f2c:	ba 40 

00008f2e <.Loc.615.1>:

      model.stationary[11].meanmag = 44;
    8f2e:	b2 40 2c 00 	mov	#44,	&0x40bc	;#0x002c
    8f32:	bc 40 

00008f34 <.Loc.616.1>:
      model.stationary[11].stddevmag = 30;
    8f34:	b2 40 1e 00 	mov	#30,	&0x40be	;#0x001e
    8f38:	be 40 

00008f3a <.Loc.618.1>:

      model.stationary[12].meanmag = 50;
    8f3a:	b2 40 32 00 	mov	#50,	&0x40c0	;#0x0032
    8f3e:	c0 40 

00008f40 <.Loc.619.1>:
      model.stationary[12].stddevmag = 20;
    8f40:	b2 40 14 00 	mov	#20,	&0x40c2	;#0x0014
    8f44:	c2 40 

00008f46 <.Loc.621.1>:

      model.stationary[13].meanmag = 48;
    8f46:	b2 40 30 00 	mov	#48,	&0x40c4	;#0x0030
    8f4a:	c4 40 

00008f4c <.Loc.622.1>:
      model.stationary[13].stddevmag = 34;
    8f4c:	b2 40 22 00 	mov	#34,	&0x40c6	;#0x0022
    8f50:	c6 40 

00008f52 <.Loc.624.1>:

      model.stationary[14].meanmag = 54;
    8f52:	b2 40 36 00 	mov	#54,	&0x40c8	;#0x0036
    8f56:	c8 40 

00008f58 <.Loc.625.1>:
      model.stationary[14].stddevmag = 22;
    8f58:	b2 40 16 00 	mov	#22,	&0x40ca	;#0x0016
    8f5c:	ca 40 

00008f5e <.Loc.627.1>:

      model.stationary[15].meanmag = 52;
    8f5e:	b2 40 34 00 	mov	#52,	&0x40cc	;#0x0034
    8f62:	cc 40 

00008f64 <.Loc.628.1>:
      model.stationary[15].stddevmag = 24;
    8f64:	b2 40 18 00 	mov	#24,	&0x40ce	;#0x0018
    8f68:	ce 40 

00008f6a <.Loc.630.1>:

}
    8f6a:	03 43       	nop			
    8f6c:	30 41       	ret			

00008f6e <main>:

int main()
{
    8f6e:	21 82       	sub	#4,	r1	;r2 As==10

00008f70 <.LCFI23>:
    // "Globals" must be on the stack because Mementos doesn't handle real
    // globals correctly
    uint8_t prev_pin_state = MODE_IDLE;
    8f70:	f1 40 03 00 	mov.b	#3,	1(r1)	;
    8f74:	01 00 

00008f76 <.Loc.642.1>:
  //uint8_t prev_pin_state = MODE_TRAIN_MOVING;

    //init_stationary();
    //init_moving();

    init();
    8f76:	b0 12 ba 8d 	call	#36282		;#0x8dba

00008f7a <.Loc.643.1>:
    ta_wait(4980);
    8f7a:	3c 40 74 13 	mov	#4980,	r12	;#0x1374
    8f7e:	b0 12 b8 92 	call	#37560		;#0x92b8

00008f82 <.Loc.645.1>:

    count = 1;
    8f82:	92 43 00 40 	mov	#1,	&0x4000	;r3 As==01

00008f86 <.Loc.646.1>:
    LED_CTRL = 0xFF;
    8f86:	7c 40 90 00 	mov.b	#144,	r12	;#0x0090
    8f8a:	fc 43 00 00 	mov.b	#-1,	0(r12)	;r3 As==11

00008f8e <.L99>:
    while (1)
    {
        run_mode_t mode = select_mode(&prev_pin_state);
    8f8e:	0c 41       	mov	r1,	r12	;
    8f90:	1c 53       	inc	r12		;
    8f92:	b0 12 26 8d 	call	#36134		;#0x8d26
    8f96:	81 4c 02 00 	mov	r12,	2(r1)	;

00008f9a <.Loc.652.1>:
      // run_mode_t mode = MODE_RECOGNIZE;

        switch (mode) {
    8f9a:	1c 41 02 00 	mov	2(r1),	r12	;
    8f9e:	1c 93       	cmp	#1,	r12	;r3 As==01
    8fa0:	0c 24       	jz	$+26     	;abs 0x8fba
    8fa2:	1c 93       	cmp	#1,	r12	;r3 As==01
    8fa4:	10 28       	jnc	$+34     	;abs 0x8fc6
    8fa6:	2c 93       	cmp	#2,	r12	;r3 As==10
    8fa8:	02 24       	jz	$+6      	;abs 0x8fae

00008faa <.Loc.667.1>:
                LOG("mode: recognize\r\n");
                recognize(&model);
                break;
            default:
                LOG("mode: idle\r\n");
                break;
    8faa:	30 40 d0 8f 	br	#0x8fd0		;

00008fae <.L97>:
      // run_mode_t mode = MODE_RECOGNIZE;

        switch (mode) {
            case MODE_TRAIN_STATIONARY:
                LOG("mode: stationary\r\n");
                train(model.stationary);
    8fae:	3c 40 90 40 	mov	#16528,	r12	;#0x4090
    8fb2:	b0 12 08 8c 	call	#35848		;#0x8c08

00008fb6 <.Loc.656.1>:
                break;
    8fb6:	30 40 d0 8f 	br	#0x8fd0		;

00008fba <.L95>:
            case MODE_TRAIN_MOVING:
                LOG("mode: moving\r\n");
                train(model.moving);
    8fba:	3c 40 d0 40 	mov	#16592,	r12	;#0x40d0
    8fbe:	b0 12 08 8c 	call	#35848		;#0x8c08

00008fc2 <.Loc.660.1>:
                break;
    8fc2:	30 40 d0 8f 	br	#0x8fd0		;

00008fc6 <.L96>:
            case MODE_RECOGNIZE:
                LOG("mode: recognize\r\n");
                recognize(&model);
    8fc6:	3c 40 90 40 	mov	#16528,	r12	;#0x4090
    8fca:	b0 12 92 8c 	call	#35986		;#0x8c92

00008fce <.Loc.664.1>:
                break;
    8fce:	03 43       	nop			

00008fd0 <.L98>:
    ta_wait(4980);

    count = 1;
    LED_CTRL = 0xFF;
    while (1)
    {
    8fd0:	30 40 8e 8f 	br	#0x8f8e		;

00008fd4 <INT_Qwark>:
	//---------------------------------------------------------------------------------------------------------------------------------//
	//    CHECKPOINT SETUP: Identify which of the 2 checkpoint buffers should be written, one should always be consistent		       //
	//	  W.C. 18 CYCLES  													   														   //	 
	//	  B.C. 10 CYCLES 													   														   //
	//---------------------------------------------------------------------------------------------------------------------------------//
		asm ("mov r13, &0x6070"); 		//temporal r13: 4 cycles
    8fd4:	82 4d 70 60 	mov	r13,	&0x6070	;

00008fd8 <.Loc.283.1>:
		asm ("mov r12, &0x6072"); 		//temporal r12: 4 cycles
    8fd8:	82 4c 72 60 	mov	r12,	&0x6072	;

00008fdc <.Loc.285.1>:

		asm ("cmp.b #0x01,&0x6075"); 		//4 cycles
    8fdc:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

00008fe0 <.Loc.286.1>:
		asm ("jz __second_buffer_init");	//2 cycles
    8fe0:	06 24       	jz	$+14     	;abs 0x8fee

00008fe2 <.Loc.288.1>:

		asm ("mov #0x6010, r12"); 		//Load the base pointer of the first checkpoint buffer: 2 cycles
    8fe2:	3c 40 10 60 	mov	#24592,	r12	;#0x6010

00008fe6 <.Loc.289.1>:
		asm ("mov.b #0x01,&0x6074");		//4 cycles
    8fe6:	d2 43 74 60 	mov.b	#1,	&0x6074	;r3 As==01

00008fea <.Loc.290.1>:
		asm ("br #__first_phase_commit");	//2 cycles
    8fea:	30 40 f2 8f 	br	#0x8ff2		;

00008fee <__second_buffer_init>:

		asm ("__second_buffer_init:");

		asm ("mov #0x6040, r12"); 		//Load the base pointer of the second checkpoint buffer: 2 cycles
    8fee:	3c 40 40 60 	mov	#24640,	r12	;#0x6040

00008ff2 <__first_phase_commit>:
		//-------------------------------------------------------------------------------------------------------------//
		

		asm ("__first_phase_commit:");
		//Verify readjustments on the PC
		asm ("mov 2(r1),@r12"); 	//PC/R0   6 cycles
    8ff2:	9c 41 02 00 	mov	2(r1),	0(r12)	;
    8ff6:	00 00 

00008ff8 <.Loc.310.1>:

		asm ("cmp #0x0000,&0x02B8"); 	//PC/R0   6 cycles
    8ff8:	82 93 b8 02 	cmp	#0,	&0x02b8	;r3 As==00

00008ffc <.Loc.311.1>:
		asm ("jeq __continue_first_phase_commit"); 	//PC/R0   6 cycles
    8ffc:	03 24       	jz	$+8      	;abs 0x9004

00008ffe <.Loc.312.1>:
		asm ("sub &0x02B8,@r12");
    8ffe:	9c 82 b8 02 	sub	&0x02b8,0(r12)	;0x02b8
    9002:	00 00 

00009004 <__continue_first_phase_commit>:

		asm ("__continue_first_phase_commit:");

		asm ("incd r12");		//	  1 cycle
    9004:	2c 53       	incd	r12		;

00009006 <.Loc.318.1>:

		asm ("mov r1,@r12");   	//SP/R1   4 cycles
    9006:	8c 41 00 00 	mov	r1,	0(r12)	;

0000900a <.Loc.319.1>:
		asm ("add #0x04,@r12");	//	  5 cycles
    900a:	ac 52 00 00 	add	#4,	0(r12)	;r2 As==10

0000900e <.Loc.320.1>:
		asm ("incd r12");		// 	  1 cycle
    900e:	2c 53       	incd	r12		;

00009010 <.Loc.322.1>:

		asm ("mov 0(r1),@r12"); 	//SR/R2   6 cycles
    9010:	ac 41 00 00 	mov	@r1,	0(r12)	;

00009014 <.Loc.323.1>:
		asm ("incd r12");		// 	  1 cycle
    9014:	2c 53       	incd	r12		;

00009016 <.Loc.325.1>:

		asm ("mov &0x02A0,r13"); 	//Disable Qwark and signal a buffer reset without modifying the data - 3 cycles
    9016:	1d 42 a0 02 	mov	&0x02a0,r13	;0x02a0

0000901a <.Loc.326.1>:
		asm ("and #0x3E,r13"); 	//	  2 cycles
    901a:	3d f0 3e 00 	and	#62,	r13	;#0x003e

0000901e <.Loc.327.1>:
		asm ("bis #0x40,r13"); 	//	  2 cycles
    901e:	3d d0 40 00 	bis	#64,	r13	;#0x0040

00009022 <.Loc.328.1>:
		asm ("mov r13,&0x02A0");	//	  4 cycles		
    9022:	82 4d a0 02 	mov	r13,	&0x02a0	;

00009026 <.Loc.329.1>:
		asm ("and #0xBF,r13"); 	//	  2 cycles
    9026:	3d f0 bf 00 	and	#191,	r13	;#0x00bf

0000902a <.Loc.330.1>:
		asm ("mov r13,&0x02A0");	//	  4 cycles		
    902a:	82 4d a0 02 	mov	r13,	&0x02a0	;

0000902e <.Loc.332.1>:

		asm ("mov r4,@r12"); 		//R4	  4 cycles
    902e:	8c 44 00 00 	mov	r4,	0(r12)	;

00009032 <.Loc.333.1>:
		asm ("incd r12");		// 	  1 cycle
    9032:	2c 53       	incd	r12		;

00009034 <.Loc.335.1>:

		asm ("mov r5,@r12"); 		//R5	  4 cycles
    9034:	8c 45 00 00 	mov	r5,	0(r12)	;

00009038 <.Loc.336.1>:
		asm ("incd r12");		// 		  1 cycle
    9038:	2c 53       	incd	r12		;

0000903a <.Loc.338.1>:

		asm ("mov r6,@r12"); 		//R6	  4 cycles
    903a:	8c 46 00 00 	mov	r6,	0(r12)	;

0000903e <.Loc.339.1>:
		asm ("incd r12");		// 		  1 cycle
    903e:	2c 53       	incd	r12		;

00009040 <.Loc.341.1>:

		asm ("mov r7,@r12"); 		//R7	  4 cycles
    9040:	8c 47 00 00 	mov	r7,	0(r12)	;

00009044 <.Loc.342.1>:
		asm ("incd r12");			// 		  1 cycle
    9044:	2c 53       	incd	r12		;

00009046 <.Loc.344.1>:

		asm ("mov r8,@r12"); 		//R8	  4 cycles
    9046:	8c 48 00 00 	mov	r8,	0(r12)	;

0000904a <.Loc.345.1>:
		asm ("incd r12");			// 		  1 cycle
    904a:	2c 53       	incd	r12		;

0000904c <.Loc.347.1>:

		asm ("mov r9,@r12"); 		//R9	  4 cycles
    904c:	8c 49 00 00 	mov	r9,	0(r12)	;

00009050 <.Loc.348.1>:
		asm ("incd r12");			// 		  1 cycle
    9050:	2c 53       	incd	r12		;

00009052 <.Loc.350.1>:

		asm ("mov r10,@r12"); 		//R10	  4 cycles
    9052:	8c 4a 00 00 	mov	r10,	0(r12)	;

00009056 <.Loc.351.1>:
		asm ("incd r12");			// 		  1 cycle
    9056:	2c 53       	incd	r12		;

00009058 <.Loc.353.1>:

		asm ("mov r11,@r12"); 		//R11	  4 cycles
    9058:	8c 4b 00 00 	mov	r11,	0(r12)	;

0000905c <.Loc.354.1>:
		asm ("incd r12");			// 		  1 cycle
    905c:	2c 53       	incd	r12		;

0000905e <.Loc.356.1>:

		asm ("mov &0x6072,@r12"); 	//R12	  6 cycles
    905e:	9c 42 72 60 	mov	&0x6072,0(r12)	;0x6072
    9062:	00 00 

00009064 <.Loc.357.1>:
		asm ("incd r12");			// 		  1 cycle
    9064:	2c 53       	incd	r12		;

00009066 <.Loc.359.1>:

		asm ("mov &0x6070,@r12"); 	//R13	  4 cycles
    9066:	9c 42 70 60 	mov	&0x6070,0(r12)	;0x6070
    906a:	00 00 

0000906c <.Loc.360.1>:
		asm ("incd r12");			// 		  1 cycle
    906c:	2c 53       	incd	r12		;

0000906e <.Loc.362.1>:

		asm ("mov r14,@r12"); 		//R14	  4 cycles
    906e:	8c 4e 00 00 	mov	r14,	0(r12)	;

00009072 <.Loc.363.1>:
		asm ("incd r12");			// 		  1 cycle
    9072:	2c 53       	incd	r12		;

00009074 <.Loc.365.1>:

		asm ("mov r15,@r12"); 		//R15	  4 cycles
    9074:	8c 4f 00 00 	mov	r15,	0(r12)	;

00009078 <.Loc.366.1>:
		asm ("incd r12");			// 		  1 cycle
    9078:	2c 53       	incd	r12		;

0000907a <.Loc.374.1>:
	//    WAR VIOLATION INDEX CHECKPOINT: Get the index indicating the amount of violations stored 		           //
	//	  10 CYCLES											       												   //
	//													       													   //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("mov &0x02A0, r14");	// 		  3 cycles
    907a:	1e 42 a0 02 	mov	&0x02a0,r14	;0x02a0

0000907e <.Loc.375.1>:
		asm ("RRA r14");			// 		  1 cycle
    907e:	0e 11       	rra	r14		;

00009080 <.Loc.376.1>:
		asm ("mov.b r14, @r12");	// 		  4 cycles
    9080:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00009084 <.Loc.377.1>:
		asm ("mov r14, r15 ");		// 		  1 cycle (save the index for later)
    9084:	0f 4e       	mov	r14,	r15	;

00009086 <.Loc.378.1>:
		asm ("incd r12");			// 		  1 Cycle
    9086:	2c 53       	incd	r12		;

00009088 <.Loc.388.1>:
	//	  B.C.	 5 CYCLES FOR EMPTY TLB									       									   //
	//-------------------------------------------------------------------------------------------------------------//

		/* Setup registers for copy*/

		asm ("tst r14 ");     	    	// 		  1 cycle
    9088:	0e 93       	cmp	#0,	r14	;r3 As==00

0000908a <.Loc.389.1>:
		asm ("jz  __seg_logic");	// 		  2 cycles
    908a:	08 24       	jz	$+18     	;abs 0x909c

0000908c <.Loc.391.1>:

		asm ("mov #0x02A2, r13");	// 		  2 cycles
    908c:	3d 40 a2 02 	mov	#674,	r13	;#0x02a2

00009090 <_scratchpad_addr_cpy>:

		asm ("_scratchpad_addr_cpy:");   // Each iteration takes 10 cycles - Worst case 70 cycles

		asm ("mov @r13+2, @r12");  // 		  5 cycles
    9090:	bc 4d 00 00 	mov	@r13+,	0(r12)	;

00009094 <.Loc.396.1>:
		asm ("incd r12");  		// 		  1 cycle
    9094:	2c 53       	incd	r12		;

00009096 <.Loc.397.1>:
		asm ("dec r14 ");      	// 		  1 cycle
    9096:	1e 83       	dec	r14		;

00009098 <.Loc.398.1>:
		asm ("tst r14 ");     		// 		  1 cycle
    9098:	0e 93       	cmp	#0,	r14	;r3 As==00

0000909a <.Loc.399.1>:
		asm ("jnz  _scratchpad_addr_cpy");// 2 cycles
    909a:	fa 23       	jnz	$-10     	;abs 0x9090

0000909c <__seg_logic>:
		asm ("__seg_logic:");  
		//asm ("mov #0xAE, &0x0090 ");			 // 4 cycles

		// identify what kind of interruption happened (segmentation or buffer overflow)

		asm ("mov &0x02B2, r12 ");			 // 4 cycles 
    909c:	1c 42 b2 02 	mov	&0x02b2,r12	;0x02b2

000090a0 <.Loc.413.1>:
		asm ("and #0x8000, r12 ");			 // 4 cycles 
    90a0:	3c f0 00 80 	and	#32768,	r12	;#0x8000

000090a4 <.Loc.414.1>:
		asm ("cmp #0x8000, r12 ");			 // 4 cycles 
    90a4:	3c 90 00 80 	cmp	#32768,	r12	;#0x8000

000090a8 <.Loc.417.1>:
		
		//if the comparison is equal, it means that the isr was triggered by a segmentation request
		asm ("jeq __segmentation_isr");		 // 4 cycles - copy segment address to NV location for restore
    90a8:	0a 24       	jz	$+22     	;abs 0x90be

000090aa <.Loc.420.1>:

		//This sequence is for a segmentation based on buffer overflow
		asm ("mov &0X6042, r12"); 			 // Ok, it wasnt a segmentation. Then we should segment based on the current SP
    90aa:	1c 42 42 60 	mov	&0x6042,r12	;0x6042

000090ae <.Loc.422.1>:

		asm ("cmp.b #0x01,&0x6075");			 // 4 cycles
    90ae:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

000090b2 <.Loc.423.1>:
		asm ("jz __commit_th");		 	 // 2 cycles
    90b2:	09 24       	jz	$+20     	;abs 0x90c6

000090b4 <.Loc.426.1>:

		// We know it is not the first time...but which stack shall we use ?
		asm ("mov &0X6012, r12"); 			 // Get the SP from the right buffer
    90b4:	1c 42 12 60 	mov	&0x6012,r12	;0x6012

000090b8 <.Loc.427.1>:
		asm ("cmp.b #0x01,&0x6074");   	 	 // Verify if we are being indicated that we should work with the first 
    90b8:	d2 93 74 60 	cmp.b	#1,	&0x6074	;r3 As==01

000090bc <.Loc.428.1>:
		asm ("jz __commit_th");		 	 // 2 cycles
    90bc:	04 24       	jz	$+10     	;abs 0x90c6

000090be <__segmentation_isr>:

		asm ("__segmentation_isr:");
		asm ("mov &0x02B2, r12 ");			 // 3 cycles - copy segment address to NV location for restore
    90be:	1c 42 b2 02 	mov	&0x02b2,r12	;0x02b2

000090c2 <.Loc.432.1>:
		asm ("and #0x7FFF, r12 ");			 // 2 cycles - copy segment address to NV location for restore
    90c2:	3c f0 ff 7f 	and	#32767,	r12	;#0x7fff

000090c6 <__commit_th>:
	//-------------------------------------------------------------------------------------------------------------//
	//   DOUBLE BUFFER THE NEW SEGMENT LIMIT								       								   //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("__commit_th:");
		asm ("cmp.b #0x01,&0x6075");		 // 4 cycles
    90c6:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

000090ca <.Loc.440.1>:
		asm ("jz  __commit_on_2nd ");		 // 2 cycles
    90ca:	04 24       	jz	$+10     	;abs 0x90d4

000090cc <.Loc.441.1>:
		asm ("mov r12, &0x6076"); 		     // 4 cycles	- save the SP in the NV memory for restore
    90cc:	82 4c 76 60 	mov	r12,	&0x6076	;

000090d0 <.Loc.443.1>:
		
		asm ("br #_chkpt_stack");		     // 2 cycles
    90d0:	30 40 d8 90 	br	#0x90d8		;

000090d4 <__commit_on_2nd>:

		asm ("__commit_on_2nd: ");
		asm ("mov r12, &0x6078 "); 	 	 // 4 cycles		
    90d4:	82 4c 78 60 	mov	r12,	&0x6078	;

000090d8 <_chkpt_stack>:
	//-------------------------------------------------------------------------------------------------------------//

		asm ("_chkpt_stack:");
			
		//asm ("mov #0xAA, &0x0090 ");			 // FOR TESTING
		asm ("mov #0x0000, &0x6BFE");			 // 
    90d8:	82 43 fe 6b 	mov	#0,	&0x6bfe	;r3 As==00

000090dc <.Loc.456.1>:
		asm ("mov #0x0000, &0x6BFC");			 // 
    90dc:	82 43 fc 6b 	mov	#0,	&0x6bfc	;r3 As==00

000090e0 <__first_stack_chkpt_setup>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - FIRST CHECKPOINT: 				       				      							   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__first_stack_chkpt_setup:");	
		asm ("cmp.b #0x00, &0x6075 ");			 // 4 cycles - This is 0 only the first time the code executes, the first time all the stack has to be checkpointed
    90e0:	c2 93 75 60 	cmp.b	#0,	&0x6075	;r3 As==00

000090e4 <.Loc.462.1>:
		asm ("jne __segmentation_logic");	 	 // 2 cycles		
    90e4:	06 20       	jnz	$+14     	;abs 0x90f2

000090e6 <.Loc.466.1>:

		//asm ("mov #0x0A, &0x0090 ");			 // FOR TESTING

		asm ("mov #0x6FFE, r13");			 // 2 cycles - this executes only once
    90e6:	3d 40 fe 6f 	mov	#28670,	r13	;#0x6ffe

000090ea <.Loc.467.1>:
		asm ("mov #0x7FFE, r14");			 // 2 cycles - this executes only once
    90ea:	3e 40 fe 7f 	mov	#32766,	r14	;#0x7ffe

000090ee <.Loc.468.1>:
		asm ("br #__copy_stack");		  	 // 2 cycle  - the first execution is all set, start copy	
    90ee:	30 40 4a 91 	br	#0x914a		;

000090f2 <__segmentation_logic>:
		//   STACK CHECKPOINT - LOGIC TO DETERMINE BOUNDARIES OF SEGMENTATION				      	       			   //
		//-------------------------------------------------------------------------------------------------------------//

		asm ("__segmentation_logic:");			

		asm ("mov &0x02B4, r14");			 // 3 cycles - Get the Max val address -> R14
    90f2:	1e 42 b4 02 	mov	&0x02b4,r14	;0x02b4

000090f6 <.Loc.477.1>:
		asm ("mov &0x6076, r10");			 // Get the previous segment limit     -> R10
    90f6:	1a 42 76 60 	mov	&0x6076,r10	;0x6076

000090fa <.Loc.478.1>:
		asm ("cmp.b #0x01, &0x6075 ");			 // 4 cycles 
    90fa:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

000090fe <.Loc.479.1>:
		asm ("jeq __sp_seg_define ");		 	 // 4 cycles 
    90fe:	02 24       	jz	$+6      	;abs 0x9104

00009100 <.Loc.480.1>:
		asm ("mov &0x6078, r10");
    9100:	1a 42 78 60 	mov	&0x6078,r10	;0x6078

00009104 <__sp_seg_define>:
		//   STACK CHECKPOINT - VERIFY IF THE SEGMENT DIDNT CHANGE OR INCREMENTAL CHECKPOINT			       		   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__sp_seg_define:");
		//asm ("mov #0xCC, &0x0090 ");			 // FOR TESTING

		asm ("cmp r10, r14");			 	 // 3 cycles - compare the old segment and the max value 
    9104:	0e 9a       	cmp	r10,	r14	;

00009106 <.Loc.489.1>:
		asm ("jne __sp_overlap");	 		 // 2 cycles 
    9106:	04 20       	jnz	$+10     	;abs 0x9110

00009108 <.Loc.493.1>:

		//asm ("mov #0x34, &0x0090 ");			 // FOR TESTING

		asm ("cmp r10, r12");			 	 // 3 cycles - compare the new segment and the old segment value 
    9108:	0c 9a       	cmp	r10,	r12	;

0000910a <.Loc.494.1>:
		asm ("jeq __stack_chkpt_end");	 		 // 2 cycles 
    910a:	27 24       	jz	$+80     	;abs 0x915a

0000910c <.Loc.495.1>:
		asm ("br #__sp_pre_copy");		  	 
    910c:	30 40 42 91 	br	#0x9142		;

00009110 <__sp_overlap>:
		//   STACK CHECKPOINT - OVERLAP CHECKPOINT									       							   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__sp_overlap:");
		//asm ("mov #0x12, &0x0090 ");			 // FOR TESTING

		asm ("cmp r14, r12");			 	 // 3 cycles - compare the new segment and the max value 
    9110:	0c 9e       	cmp	r14,	r12	;

00009112 <.Loc.504.1>:
		asm ("jeq __stack_chkpt_end");	 	 	 // 2 cycles
    9112:	23 24       	jz	$+72     	;abs 0x915a

00009114 <.Loc.506.1>:

		asm ("decd r14 ");				 // 1 cycle
    9114:	2e 83       	decd	r14		;

00009116 <.Loc.508.1>:

		asm ("mov #0x6BFE, r13");
    9116:	3d 40 fe 6b 	mov	#27646,	r13	;#0x6bfe

0000911a <.Loc.509.1>:
		asm ("mov r14, @r13 ");			//start address at 0x6BFE
    911a:	8d 4e 00 00 	mov	r14,	0(r13)	;

0000911e <.Loc.510.1>:
		asm ("decd r13 ");
    911e:	2d 83       	decd	r13		;

00009120 <.Loc.511.1>:
		asm ("mov r10, @r13");				//end address at  0x6BFC
    9120:	8d 4a 00 00 	mov	r10,	0(r13)	;

00009124 <.Loc.512.1>:
		asm ("decd r13 ");
    9124:	2d 83       	decd	r13		;

00009126 <.Loc.514.1>:
		
		asm ("mov r12, r11 ");
    9126:	0b 4c       	mov	r12,	r11	;

00009128 <.Loc.515.1>:
		asm ("cmp r10, r12");	   			 //  (new >= old) if true use r12 as the limit 		
    9128:	0c 9a       	cmp	r10,	r12	;

0000912a <.Loc.516.1>:
		asm ("jge __overlap_copy");
    912a:	01 34       	jge	$+4      	;abs 0x912e

0000912c <.Loc.517.1>:
		asm ("mov r10, r11 ");
    912c:	0b 4a       	mov	r10,	r11	;

0000912e <__overlap_copy>:

		asm ("__overlap_copy:");

		asm ("mov @r14, @r13 ");
    912e:	ad 4e 00 00 	mov	@r14,	0(r13)	;

00009132 <.Loc.522.1>:
		asm ("cmp r14,r11");	   		  	 // compare and verify if the LIMIT has been reached - 1 cycle
    9132:	0b 9e       	cmp	r14,	r11	;

00009134 <.Loc.524.1>:

		asm ("jeq __sp_ovl_copy");	 	 	 // 2 cycles
    9134:	04 24       	jz	$+10     	;abs 0x913e

00009136 <.Loc.525.1>:
		asm ("decd r13");				 // 1 cycle
    9136:	2d 83       	decd	r13		;

00009138 <.Loc.526.1>:
		asm ("decd r14");				 // 1 cycle
    9138:	2e 83       	decd	r14		;

0000913a <.Loc.527.1>:
		asm ("br #__overlap_copy");	
    913a:	30 40 2e 91 	br	#0x912e		;

0000913e <__sp_ovl_copy>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - VERIFY IF A COPY IS NECESSARY AFTER THE OVERLAP	       				       			   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__sp_ovl_copy:");
	
		asm ("cmp r10,r12");	   			 // r12 >= r10 ?  new seg >= old ? 		  	 
    913e:	0c 9a       	cmp	r10,	r12	;

00009140 <.Loc.535.1>:
		asm ("jge __stack_chkpt_end");
    9140:	0c 34       	jge	$+26     	;abs 0x915a

00009142 <__sp_pre_copy>:

		asm ("__sp_pre_copy:");

		asm ("decd r14 ");				 	 // 1 cycle
    9142:	2e 83       	decd	r14		;

00009144 <.Loc.540.1>:
		asm ("mov r14, r13");			 	 // 2 cycles
    9144:	0d 4e       	mov	r14,	r13	;

00009146 <.Loc.541.1>:
		asm ("sub #0x1000, r13");			 // 2 cycles - Make the equal stack max offset (e.g., 0x6FCE -> 0x7FCE)
    9146:	3d 80 00 10 	sub	#4096,	r13	;#0x1000

0000914a <__copy_stack>:
		//-------------------------------------------------------------------------------------------------------------//
		//   STACK CHECKPOINT - COPY ROUTINE: 				       				       	       						   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("__copy_stack:");

		asm ("mov @r14,@r13");			 	 // 5 cycles
    914a:	ad 4e 00 00 	mov	@r14,	0(r13)	;

0000914e <.Loc.550.1>:

		asm ("cmp r14,r12");	   		  	 // compare and verify if the base has been reached - 1 cycle
    914e:	0c 9e       	cmp	r14,	r12	;

00009150 <.Loc.551.1>:
		asm ("jz __stack_chkpt_end");	 	 // 2 cycles
    9150:	04 24       	jz	$+10     	;abs 0x915a

00009152 <.Loc.553.1>:

		asm ("decd r13");				 	 // 1 cycle
    9152:	2d 83       	decd	r13		;

00009154 <.Loc.554.1>:
		asm ("decd r14");					 // 1 cycle
    9154:	2e 83       	decd	r14		;

00009156 <.Loc.555.1>:
		asm ("br #__copy_stack");		  	 // 2 cycle
    9156:	30 40 4a 91 	br	#0x914a		;

0000915a <__stack_chkpt_end>:
	//    END OF THE FIRST PHASE: Atomic Flag Handling for halfway through checkpoint			       			   //
	//	  W.C 18 Cycles											       											   //
	//-------------------------------------------------------------------------------------------------------------//
		//asm ("mov #0xAF, &0x0090 ");		 // FOR TESTING

		asm ("cmp.b #0x01,&0x6075");		 // 4 cycles
    915a:	d2 93 75 60 	cmp.b	#1,	&0x6075	;r3 As==01

0000915e <.Loc.566.1>:
		asm ("jz  __set_flag_2nd ");		 // 2 cycles
    915e:	04 24       	jz	$+10     	;abs 0x9168

00009160 <.Loc.568.1>:

		asm ("add.b #0x01, &0x6074 "); 	 //4 cycles
    9160:	d2 53 74 60 	inc.b	&0x6074		;

00009164 <.Loc.569.1>:
		asm ("br  #_WAR_commit "); 	     //4 cycles
    9164:	30 40 6c 91 	br	#0x916c		;

00009168 <__set_flag_2nd>:

		asm ("__set_flag_2nd:");
		asm ("add.b #0x01, &0x6075 "); 	 // 4 cycles		/* THE RESTORE ROUTINE CAN FINALIZE THIS HALFWAY CHECKPOINT  */
    9168:	d2 53 75 60 	inc.b	&0x6075		;

0000916c <_WAR_commit>:
		//-------------------------------------------------------------------------------------------------------------//
		
		asm ("_WAR_commit:");
		//asm ("mov #0xDE, &0x0090 ");		// FOR TESTING

		asm ("tst r15 ");     		         // 1 cycle
    916c:	0f 93       	cmp	#0,	r15	;r3 As==00

0000916e <.Loc.589.1>:
		asm ("jz  _stack_write_back");		 // 2 cycles
    916e:	25 24       	jz	$+76     	;abs 0x91ba

00009170 <.Loc.591.1>:

		asm ("mov #0x6000,  r14 ");		 // 2 cycles
    9170:	3e 40 00 60 	mov	#24576,	r14	;#0x6000

00009174 <.Loc.593.1>:

		asm ("mov #0x6060,  r12 ");		 // 2 cycles
    9174:	3c 40 60 60 	mov	#24672,	r12	;#0x6060

00009178 <.Loc.594.1>:
		asm ("cmp.b #0x02,&0x6075");		 // 4 cycles
    9178:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

0000917c <.Loc.595.1>:
		asm ("jz _second_phase_commit_strt");   // 2 cycles
    917c:	02 24       	jz	$+6      	;abs 0x9182

0000917e <.Loc.597.1>:

		asm ("mov #0x6030,  r12 ");		 // 2 cycles
    917e:	3c 40 30 60 	mov	#24624,	r12	;#0x6030

00009182 <_second_phase_commit_strt>:

		asm ("_second_phase_commit_strt:"); 	 // Worst case

		asm ("mov @r12+2,  r13 ");   		 // 3 cycles
    9182:	3d 4c       	mov	@r12+,	r13	;

00009184 <.Loc.603.1>:

		asm ("mov r13,  r11 ");   		 // 1 cycle
    9184:	0b 4d       	mov	r13,	r11	;

00009186 <.Loc.605.1>:

		asm ("and #0x8000,  r11 ");   		 // 2 cycles
    9186:	3b f0 00 80 	and	#32768,	r11	;#0x8000

0000918a <.Loc.606.1>:
		asm ("cmp #0x8000,  r11 ");   		 // 2 cycles
    918a:	3b 90 00 80 	cmp	#32768,	r11	;#0x8000

0000918e <.Loc.607.1>:
		asm ("jeq _byte_copy ");   		 // 2 cycles
    918e:	08 24       	jz	$+18     	;abs 0x91a0

00009190 <.Loc.609.1>:

		asm ("mov @r14, @r13 ");    		 // 5 cycles
    9190:	ad 4e 00 00 	mov	@r14,	0(r13)	;

00009194 <_pre_end_copy>:

		asm ("_pre_end_copy:");
		asm ("incd r14");    			 // 1 cycle
    9194:	2e 53       	incd	r14		;

00009196 <.Loc.613.1>:
		asm ("dec r15");    			 // 1 cycle
    9196:	1f 83       	dec	r15		;

00009198 <.Loc.614.1>:
		asm ("tst r15");    			 // 1 cycle
    9198:	0f 93       	cmp	#0,	r15	;r3 As==00

0000919a <.Loc.616.1>:

		asm ("jnz  _second_phase_commit_strt"); // 2 cycles
    919a:	f3 23       	jnz	$-24     	;abs 0x9182

0000919c <.Loc.617.1>:
		asm ("br #_stack_write_back");		 // 2 cycles
    919c:	30 40 ba 91 	br	#0x91ba		;

000091a0 <_byte_copy>:

		asm ("_byte_copy:");
		asm ("and #0x7FFF,  r13 ");   		// mask the highest bit - 2 cycles
    91a0:	3d f0 ff 7f 	and	#32767,	r13	;#0x7fff

000091a4 <.Loc.621.1>:
		asm ("mov r13,      r11 ");   		// 1 cycle
    91a4:	0b 4d       	mov	r13,	r11	;

000091a6 <.Loc.622.1>:
		asm ("and #0x01,    r11 ");   		// detect if its a byte write - 1 cycle
    91a6:	1b f3       	and	#1,	r11	;r3 As==01

000091a8 <.Loc.623.1>:
		asm ("bis  r11,     r14 ");   		// detect if its a byte write - 1 cycle
    91a8:	0e db       	bis	r11,	r14	;

000091aa <.Loc.626.1>:


		asm ("mov.b @r14, @r13 ");    			// 5 cycles
    91aa:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

000091ae <.Loc.628.1>:

		asm ("and #0xFFFE, r14");    			// 2 cycles
    91ae:	3e f0 fe ff 	and	#65534,	r14	;#0xfffe

000091b2 <.Loc.629.1>:
		asm ("incd r14");    				// 1 cycle
    91b2:	2e 53       	incd	r14		;

000091b4 <.Loc.630.1>:
		asm ("dec r15");    				// 1 cycles
    91b4:	1f 83       	dec	r15		;

000091b6 <.Loc.631.1>:
		asm ("tst r15");    				// 1 cycles
    91b6:	0f 93       	cmp	#0,	r15	;r3 As==00

000091b8 <.Loc.632.1>:
		asm ("jnz  _second_phase_commit_strt");	// 2 cycles
    91b8:	e4 23       	jnz	$-54     	;abs 0x9182

000091ba <_stack_write_back>:
		//   COPY BACK THE 2BLE BUFFER					       				       	       							   //
		//-------------------------------------------------------------------------------------------------------------//
		asm ("_stack_write_back:");


		asm ("cmp #0x0000,  &0x6BFE");	
    91ba:	82 93 fe 6b 	cmp	#0,	&0x6bfe	;r3 As==00

000091be <.Loc.641.1>:
		asm ("jeq _chkpt_finished");
    91be:	12 24       	jz	$+38     	;abs 0x91e4

000091c0 <.Loc.645.1>:

		//asm ("mov #0xDD, &0x0090 ");		// FOR TESTING	

		asm ("mov &0x6BFE,  r13 ");		 // 2 cycles - get the upper limit		
    91c0:	1d 42 fe 6b 	mov	&0x6bfe,r13	;0x6bfe

000091c4 <.Loc.646.1>:
		asm ("mov &0x6BFC,  r12 ");		 // 2 cycles - get the down limit 
    91c4:	1c 42 fc 6b 	mov	&0x6bfc,r12	;0x6bfc

000091c8 <.Loc.648.1>:

		asm ("mov r13,  r14 ");		     // 2 cycles - 
    91c8:	0e 4d       	mov	r13,	r14	;

000091ca <.Loc.649.1>:
		asm ("sub #0x1000,  r14 ");		 // 2 cycles - get the down limit 
    91ca:	3e 80 00 10 	sub	#4096,	r14	;#0x1000

000091ce <.Loc.650.1>:
		asm ("mov #0x6BFA,  r10 ");
    91ce:	3a 40 fa 6b 	mov	#27642,	r10	;#0x6bfa

000091d2 <_second_phase_stack_cpy>:

		asm ("_second_phase_stack_cpy:");
		asm ("mov @r10,@r14");			     // 5 cycles
    91d2:	ae 4a 00 00 	mov	@r10,	0(r14)	;

000091d6 <.Loc.655.1>:
	
		asm ("cmp r13, r12");	
    91d6:	0c 9d       	cmp	r13,	r12	;

000091d8 <.Loc.656.1>:
   		asm ("jeq _chkpt_finished");	 	 // 2 cycles
    91d8:	05 24       	jz	$+12     	;abs 0x91e4

000091da <.Loc.657.1>:
		asm ("decd r10");
    91da:	2a 83       	decd	r10		;

000091dc <.Loc.658.1>:
		asm ("decd r13");	   	
    91dc:	2d 83       	decd	r13		;

000091de <.Loc.659.1>:
	  	asm ("decd r14");	   	
    91de:	2e 83       	decd	r14		;

000091e0 <.Loc.660.1>:
		asm ("br # _second_phase_stack_cpy");	 	// 2 cycles
    91e0:	30 40 d2 91 	br	#0x91d2		;

000091e4 <_chkpt_finished>:
	//	  25 CYCLES											       												   //
	//-------------------------------------------------------------------------------------------------------------//
		asm ("_chkpt_finished:");

	    /* Set second phase complete Bit - Atomic Flag*/
		asm ("cmp.b #0x02,&0x6075");			//4 cycles
    91e4:	e2 93 75 60 	cmp.b	#2,	&0x6075	;r3 As==10

000091e8 <.Loc.670.1>:
		asm ("jeq  __pre_finish_2nd_buffer "); 	//2 cycles
    91e8:	1a 24       	jz	$+54     	;abs 0x921e

000091ea <.Loc.672.1>:

		asm ("mov #0x0103, &0x6074 "); 		//5 cycles	/* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 1ST CHECKPOINT COMPLETELY  */
    91ea:	b2 40 03 01 	mov	#259,	&0x6074	;#0x0103
    91ee:	74 60 

000091f0 <.Loc.678.1>:

	//-------------------------------------------------------------------------------------------------------------//
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 		           //
	//													       													   //
	//-------------------------------------------------------------------------------------------------------------//
		asm ("mov &0x6022,r10"); 		//3 cycles
    91f0:	1a 42 22 60 	mov	&0x6022,r10	;0x6022

000091f4 <.Loc.679.1>:
		asm ("mov &0x6024,r11"); 		//3 cycles
    91f4:	1b 42 24 60 	mov	&0x6024,r11	;0x6024

000091f8 <.Loc.680.1>:
		asm ("mov &0x6026,r12"); 		//3 cycles
    91f8:	1c 42 26 60 	mov	&0x6026,r12	;0x6026

000091fc <.Loc.681.1>:
		asm ("mov &0x6028,r13"); 	    	//3 cycles
    91fc:	1d 42 28 60 	mov	&0x6028,r13	;0x6028

00009200 <.Loc.682.1>:
		asm ("mov &0x602A,r14"); 	    	//3 cycles
    9200:	1e 42 2a 60 	mov	&0x602a,r14	;0x602a

00009204 <.Loc.683.1>:
		asm ("mov &0x602C,r15"); 	    	//3 cycles
    9204:	1f 42 2c 60 	mov	&0x602c,r15	;0x602c

00009208 <.Loc.684.1>:
		asm ("mov &0x6076,&0x02B2"); 	    	//3 cycles
    9208:	92 42 76 60 	mov	&0x6076,&0x02b2	;0x6076
    920c:	b2 02 

0000920e <.Loc.685.1>:
		asm ("mov &0x6076,&0x02B4"); 	    	//3 cycles
    920e:	92 42 76 60 	mov	&0x6076,&0x02b4	;0x6076
    9212:	b4 02 

00009214 <.Loc.686.1>:
		asm ("mov &0x6076,&0x02B6"); 	    	//3 cycles
    9214:	92 42 76 60 	mov	&0x6076,&0x02b6	;0x6076
    9218:	b6 02 

0000921a <.Loc.687.1>:
		asm ("br #_finish"); 	   		//3 cycles
    921a:	30 40 4e 92 	br	#0x924e		;

0000921e <__pre_finish_2nd_buffer>:
	//    REGISTER RESTORE:	This is to continue operation and restore possibly modified registers 		           //
	//-------------------------------------------------------------------------------------------------------------//

		asm ("__pre_finish_2nd_buffer:");

		asm ("mov #0x0301, &0x6074 "); 	//4 cycles /* After setting this bit, THE RESTORE ROUTINE CAN RE-USE THE 2ND CHECKPOINT COMPLETELY  */
    921e:	b2 40 01 03 	mov	#769,	&0x6074	;#0x0301
    9222:	74 60 

00009224 <.Loc.696.1>:

		asm ("mov &0x6052,r10"); 	    //3 cycles		
    9224:	1a 42 52 60 	mov	&0x6052,r10	;0x6052

00009228 <.Loc.697.1>:
		asm ("mov &0x6054,r11"); 	    //3 cycles
    9228:	1b 42 54 60 	mov	&0x6054,r11	;0x6054

0000922c <.Loc.698.1>:
		asm ("mov &0x6056,r12"); 	    //3 cycles
    922c:	1c 42 56 60 	mov	&0x6056,r12	;0x6056

00009230 <.Loc.699.1>:
		asm ("mov &0x6058,r13"); 	    //3 cycles
    9230:	1d 42 58 60 	mov	&0x6058,r13	;0x6058

00009234 <.Loc.700.1>:
		asm ("mov &0x605A,r14"); 	    //3 cycles
    9234:	1e 42 5a 60 	mov	&0x605a,r14	;0x605a

00009238 <.Loc.701.1>:
		asm ("mov &0x605C,r15"); 	    //3 cycles
    9238:	1f 42 5c 60 	mov	&0x605c,r15	;0x605c

0000923c <.Loc.702.1>:
		asm ("mov &0x6078,&0x02B2"); 	    //3 cycles
    923c:	92 42 78 60 	mov	&0x6078,&0x02b2	;0x6078
    9240:	b2 02 

00009242 <.Loc.703.1>:
		asm ("mov &0x6078,&0x02B4"); 	    //3 cycles
    9242:	92 42 78 60 	mov	&0x6078,&0x02b4	;0x6078
    9246:	b4 02 

00009248 <.Loc.704.1>:
		asm ("mov &0x6078,&0x02B6"); 	    //3 cycles
    9248:	92 42 78 60 	mov	&0x6078,&0x02b6	;0x6078
    924c:	b6 02 

0000924e <_finish>:
		asm ("_finish:");

		/* Clear the counters*/
		asm ("mov #0x0000, &0x6000");	//4 cycles
    924e:	82 43 00 60 	mov	#0,	&0x6000	;r3 As==00

00009252 <.Loc.709.1>:
		asm ("mov #0x0000, &0x6002");	//4 cycles
    9252:	82 43 02 60 	mov	#0,	&0x6002	;r3 As==00

00009256 <.Loc.710.1>:
		asm ("mov #0x0000, &0x6004");	//4 cycles
    9256:	82 43 04 60 	mov	#0,	&0x6004	;r3 As==00

0000925a <.Loc.711.1>:
		asm ("mov #0x0000, &0x6006");	//4 cycles
    925a:	82 43 06 60 	mov	#0,	&0x6006	;r3 As==00

0000925e <.Loc.712.1>:
		asm ("mov #0x0000, &0x6008");	//4 cycles
    925e:	82 43 08 60 	mov	#0,	&0x6008	;r3 As==00

00009262 <.Loc.713.1>:
		asm ("mov #0x0000, &0x600A");	//4 cycles
    9262:	82 43 0a 60 	mov	#0,	&0x600a	;r3 As==00

00009266 <.Loc.714.1>:
		asm ("mov #0x0000, &0x600C");	//4 cycles
    9266:	82 43 0c 60 	mov	#0,	&0x600c	;r3 As==00

0000926a <.Loc.715.1>:
		asm ("mov #0x0000, &0x600E");	//4 cycles
    926a:	82 43 0e 60 	mov	#0,	&0x600e	;r3 As==00

0000926e <.Loc.717.1>:

		asm ("mov #0x0000, &0x02A2");	//4 cycles
    926e:	82 43 a2 02 	mov	#0,	&0x02a2	;r3 As==00

00009272 <.Loc.718.1>:
		asm ("mov #0x0000, &0x02A4");	//4 cycles
    9272:	82 43 a4 02 	mov	#0,	&0x02a4	;r3 As==00

00009276 <.Loc.719.1>:
		asm ("mov #0x0000, &0x02A6");	//4 cycles
    9276:	82 43 a6 02 	mov	#0,	&0x02a6	;r3 As==00

0000927a <.Loc.720.1>:
		asm ("mov #0x0000, &0x02A8");	//4 cycles
    927a:	82 43 a8 02 	mov	#0,	&0x02a8	;r3 As==00

0000927e <.Loc.721.1>:
		asm ("mov #0x0000, &0x02AA");	//4 cycles
    927e:	82 43 aa 02 	mov	#0,	&0x02aa	;r3 As==00

00009282 <.Loc.722.1>:
		asm ("mov #0x0000, &0x02AC");	//4 cycles
    9282:	82 43 ac 02 	mov	#0,	&0x02ac	;r3 As==00

00009286 <.Loc.723.1>:
		asm ("mov #0x0000, &0x02AE");	//4 cycles
    9286:	82 43 ae 02 	mov	#0,	&0x02ae	;r3 As==00

0000928a <.Loc.724.1>:
		asm ("mov #0x0000, &0x02B0");	//4 cycles
    928a:	82 43 b0 02 	mov	#0,	&0x02b0	;r3 As==00

0000928e <.Loc.728.1>:

		/* and re-enable Idempotency tracking */

		asm ("mov #0x0001, &0x02A0");	// 4 cycles
    928e:	92 43 a0 02 	mov	#1,	&0x02a0	;r3 As==01

00009292 <.Loc.729.1>:
}
    9292:	03 43       	nop			
    9294:	00 13       	reti			

00009296 <ta_wait_no_lpm>:
//    TA_WAIT_NO_LPM                                 //
// ( the function implements a wait by continously ) //
// ( polling the TAR register                      ) //
//                                                   //
//---------------------------------------------------//
void ta_wait_no_lpm(unsigned int time_cnt) {
    9296:	21 83       	decd	r1		;

00009298 <.LCFI0>:
    9298:	81 4c 00 00 	mov	r12,	0(r1)	;

0000929c <.Loc.14.1>:

  // Start and re-initialize TimerA
  TACTL = TASSEL0 | TACLR | MC_2;
    929c:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    92a0:	bc 40 24 01 	mov	#292,	0(r12)	;#0x0124
    92a4:	00 00 

000092a6 <.Loc.17.1>:

  // Wait until time is over
  while(TAR < time_cnt);
    92a6:	03 43       	nop			

000092a8 <.L2>:
    92a8:	3c 40 70 01 	mov	#368,	r12	;#0x0170
    92ac:	2c 4c       	mov	@r12,	r12	;
    92ae:	2c 91       	cmp	@r1,	r12	;
    92b0:	fb 2b       	jnc	$-8      	;abs 0x92a8

000092b2 <.Loc.19.1>:

}
    92b2:	03 43       	nop			
    92b4:	21 53       	incd	r1		;
    92b6:	30 41       	ret			

000092b8 <ta_wait>:
// ( the timerA IRQ will exit the LPM0 state    )   //
//                                                  //
//--------------------------------------------------//
unsigned int periodic_val;

void ta_wait(unsigned int time_cnt) {
    92b8:	21 83       	decd	r1		;

000092ba <.LCFI1>:
    92ba:	81 4c 00 00 	mov	r12,	0(r1)	;

000092be <.Loc.32.1>:

  // Set time limit for IRQ generation
  TACCR0 = time_cnt;
    92be:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    92c2:	ac 41 00 00 	mov	@r1,	0(r12)	;

000092c6 <.Loc.33.1>:
  periodic_val = time_cnt;
    92c6:	a2 41 14 41 	mov	@r1,	&0x4114	;

000092ca <.Loc.35.1>:
  // Start and re-initialize TimerA
  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    92ca:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    92ce:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    92d2:	00 00 

000092d4 <.Loc.40.1>:

  // Go to Low-Power-Mode 0
  //LPM0;

}
    92d4:	03 43       	nop			
    92d6:	21 53       	incd	r1		;
    92d8:	30 41       	ret			

000092da <INT_timerA1>:

//--------------------------------------------------//
//    TIMER A INTERRUPT                             //
//--------------------------------------------------//
wakeup interrupt (TIMERA1_VECTOR) INT_timerA1(void) {
    92da:	0d 12       	push	r13		;

000092dc <.LCFI2>:
    92dc:	0c 12       	push	r12		;

000092de <.LCFI3>:


      //Force Reset
	 // WDTCTL = 0;
	  TACTL = TAIFG;
    92de:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    92e2:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

000092e6 <.Loc.53.1>:
	  //LED_CTRL ^= 0x0F;
	  // Set time limit for IRQ generation
	  TACCR0 = periodic_val;
    92e6:	3c 40 72 01 	mov	#370,	r12	;#0x0172
    92ea:	1d 42 14 41 	mov	&0x4114,r13	;0x4114
    92ee:	8c 4d 00 00 	mov	r13,	0(r12)	;

000092f2 <.Loc.56.1>:

	  // Start and re-initialize TimerA
	  TACTL  = TASSEL1 | TACLR | MC_1 | TAIE;
    92f2:	3c 40 60 01 	mov	#352,	r12	;#0x0160
    92f6:	bc 40 16 02 	mov	#534,	0(r12)	;#0x0216
    92fa:	00 00 

000092fc <.Loc.58.1>:

	  QWARK_CHECKPOINT();
    92fc:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    9300:	2d 4c       	mov	@r12,	r13	;
    9302:	3c 40 a0 02 	mov	#672,	r12	;#0x02a0
    9306:	3d d0 20 00 	bis	#32,	r13	;#0x0020
    930a:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000930e <.Loc.61.1>:


}
    930e:	03 43       	nop			
    9310:	b1 c0 f0 00 	bic	#240,	4(r1)	;#0x00f0
    9314:	04 00 
    9316:	3c 41       	pop	r12		;
    9318:	3d 41       	pop	r13		;
    931a:	00 13       	reti			

0000931c <UART_WriteChar>:

//--------------------------------------------------//
//                 tty_putc function                 //
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int UART_WriteChar (char txdata) {
    931c:	21 83       	decd	r1		;

0000931e <.LCFI0>:
    931e:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00009322 <.Loc.19.1>:

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    9322:	03 43       	nop			

00009324 <.L2>:
    9324:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081
    9328:	6c 4c       	mov.b	@r12,	r12	;
    932a:	7c f2       	and.b	#8,	r12	;r2 As==11
    932c:	0c 93       	cmp	#0,	r12	;r3 As==00
    932e:	fa 23       	jnz	$-10     	;abs 0x9324

00009330 <.Loc.22.1>:
  //LED_CTRL = 0xEE;
  // Write the output character
  UART_TXD = txdata;
    9330:	7c 40 84 00 	mov.b	#132,	r12	;#0x0084
    9334:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    9338:	00 00 

0000933a <.Loc.24.1>:

  return 0;
    933a:	4c 43       	clr.b	r12		;

0000933c <.Loc.25.1>:
}
    933c:	21 53       	incd	r1		;
    933e:	30 41       	ret			

00009340 <UART_WriteNumber>:


void UART_WriteNumber (int n)
{
    9340:	31 80 18 00 	sub	#24,	r1	;#0x0018

00009344 <.LCFI1>:
    9344:	81 4c 00 00 	mov	r12,	0(r1)	;

00009348 <.Loc.31.1>:
  char buf[20];
  int i = 0;
    9348:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

0000934c <.Loc.32.1>:
  if (n < 0)
    934c:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    9350:	25 34       	jge	$+76     	;abs 0x939c

00009352 <.Loc.34.1>:
    {
	  UART_WriteChar ('-');
    9352:	7c 40 2d 00 	mov.b	#45,	r12	;#0x002d
    9356:	b0 12 1c 93 	call	#37660		;#0x931c

0000935a <.Loc.35.1>:
      n = -n;
    935a:	4c 43       	clr.b	r12		;
    935c:	2c 81       	sub	@r1,	r12	;
    935e:	81 4c 00 00 	mov	r12,	0(r1)	;

00009362 <.Loc.37.1>:
    }
  while (n > 9)
    9362:	30 40 9c 93 	br	#0x939c		;

00009366 <.L7>:
    {
      buf[i++] = (n%10) + '0';
    9366:	2c 41       	mov	@r1,	r12	;
    9368:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    936c:	b0 12 b2 94 	call	#38066		;#0x94b2
    9370:	4d 4c       	mov.b	r12,	r13	;
    9372:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9376:	0e 4c       	mov	r12,	r14	;
    9378:	1e 53       	inc	r14		;
    937a:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    937e:	7d 50 30 00 	add.b	#48,	r13	;#0x0030
    9382:	4e 4d       	mov.b	r13,	r14	;
    9384:	0d 41       	mov	r1,	r13	;
    9386:	2d 53       	incd	r13		;
    9388:	0c 5d       	add	r13,	r12	;
    938a:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

0000938e <.Loc.40.1>:
      n /= 10;
    938e:	2c 41       	mov	@r1,	r12	;
    9390:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9394:	b0 12 66 94 	call	#37990		;#0x9466
    9398:	81 4c 00 00 	mov	r12,	0(r1)	;

0000939c <.L6>:
  if (n < 0)
    {
	  UART_WriteChar ('-');
      n = -n;
    }
  while (n > 9)
    939c:	7c 40 09 00 	mov.b	#9,	r12	;
    93a0:	2c 91       	cmp	@r1,	r12	;
    93a2:	e1 3b       	jl	$-60     	;abs 0x9366

000093a4 <.Loc.42.1>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
    93a4:	2c 41       	mov	@r1,	r12	;
    93a6:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    93aa:	b0 12 b2 94 	call	#38066		;#0x94b2
    93ae:	4d 4c       	mov.b	r12,	r13	;
    93b0:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    93b4:	0e 4c       	mov	r12,	r14	;
    93b6:	1e 53       	inc	r14		;
    93b8:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    93bc:	7d 50 30 00 	add.b	#48,	r13	;#0x0030
    93c0:	4e 4d       	mov.b	r13,	r14	;
    93c2:	0d 41       	mov	r1,	r13	;
    93c4:	2d 53       	incd	r13		;
    93c6:	0c 5d       	add	r13,	r12	;
    93c8:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

000093cc <.Loc.43.1>:
  while (i > 0)
    93cc:	30 40 e2 93 	br	#0x93e2		;

000093d0 <.L9>:
	  UART_WriteChar (buf[--i]);
    93d0:	b1 53 16 00 	add	#-1,	22(r1)	;r3 As==11, 0x0016
    93d4:	0c 41       	mov	r1,	r12	;
    93d6:	2c 53       	incd	r12		;
    93d8:	1c 51 16 00 	add	22(r1),	r12	;0x00016
    93dc:	6c 4c       	mov.b	@r12,	r12	;
    93de:	b0 12 1c 93 	call	#37660		;#0x931c

000093e2 <.L8>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
  while (i > 0)
    93e2:	4c 43       	clr.b	r12		;
    93e4:	1c 91 16 00 	cmp	22(r1),	r12	;0x00016
    93e8:	f3 3b       	jl	$-24     	;abs 0x93d0

000093ea <.Loc.45.1>:
	  UART_WriteChar (buf[--i]);
}
    93ea:	03 43       	nop			
    93ec:	31 50 18 00 	add	#24,	r1	;#0x0018
    93f0:	30 41       	ret			

000093f2 <UART_WriteString>:
/* This function prints a string of characters on the UART. The usage of this function is mostly    */
/* for debugging purposes.                                                                          */
/* Parameter(s)                                                                                     */
/* string      string of characters that will be printed through the UART                           */

void UART_WriteString(char* string){
    93f2:	21 82       	sub	#4,	r1	;r2 As==10

000093f4 <.LCFI2>:
    93f4:	81 4c 00 00 	mov	r12,	0(r1)	;

000093f8 <.Loc.54.1>:

    char i = 0;
    93f8:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

000093fc <.Loc.57.1>:

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    93fc:	30 40 14 94 	br	#0x9414		;

00009400 <.L12>:
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);
    9400:	5c 41 03 00 	mov.b	3(r1),	r12	;
    9404:	4d 4c       	mov.b	r12,	r13	;
    9406:	5d 53       	inc.b	r13		;
    9408:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    940c:	2c 51       	add	@r1,	r12	;
    940e:	6c 4c       	mov.b	@r12,	r12	;
    9410:	b0 12 1c 93 	call	#37660		;#0x931c

00009414 <.L11>:
void UART_WriteString(char* string){

    char i = 0;

    /* while the null character found at the end of every string is not found, keep iterating through the pointer*/
    while(string[i]!='\0')
    9414:	5c 41 03 00 	mov.b	3(r1),	r12	;
    9418:	2c 51       	add	@r1,	r12	;
    941a:	6c 4c       	mov.b	@r12,	r12	;
    941c:	0c 93       	cmp	#0,	r12	;r3 As==00
    941e:	f0 23       	jnz	$-30     	;abs 0x9400

00009420 <.Loc.63.1>:
    {
       /* if a transmission is pending, do not increment the index of the string, keep trying */
    	UART_WriteChar(string[i++]);

    }
 }
    9420:	03 43       	nop			
    9422:	21 52       	add	#4,	r1	;r2 As==10
    9424:	30 41       	ret			

00009426 <udivmodhi4>:
    9426:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011

0000942a <.Loc.35.1>:
    942a:	5b 43       	mov.b	#1,	r11	;r3 As==01

0000942c <.L2>:
    942c:	0d 9c       	cmp	r12,	r13	;
    942e:	08 28       	jnc	$+18     	;abs 0x9440

00009430 <.L15>:
    9430:	4f 43       	clr.b	r15		;

00009432 <.L4>:
    9432:	0b 93       	cmp	#0,	r11	;r3 As==00
    9434:	0e 20       	jnz	$+30     	;abs 0x9452

00009436 <.L5>:
    9436:	0e 93       	cmp	#0,	r14	;r3 As==00
    9438:	01 24       	jz	$+4      	;abs 0x943c
    943a:	0f 4c       	mov	r12,	r15	;

0000943c <.L1>:
    943c:	0c 4f       	mov	r15,	r12	;
    943e:	30 41       	ret			

00009440 <.L3>:
    9440:	3f 53       	add	#-1,	r15	;r3 As==11

00009442 <.Loc.38.1>:
    9442:	0f 93       	cmp	#0,	r15	;r3 As==00
    9444:	f8 27       	jz	$-14     	;abs 0x9436

00009446 <.Loc.38.1>:
    9446:	0d 93       	cmp	#0,	r13	;r3 As==00
    9448:	f3 3b       	jl	$-24     	;abs 0x9430

0000944a <.Loc.40.1>:
    944a:	0d 5d       	rla	r13		;

0000944c <.Loc.41.1>:
    944c:	0b 5b       	rla	r11		;
    944e:	30 40 2c 94 	br	#0x942c		;

00009452 <.L9>:
    9452:	0c 9d       	cmp	r13,	r12	;
    9454:	02 28       	jnc	$+6      	;abs 0x945a

00009456 <.Loc.47.1>:
    9456:	0c 8d       	sub	r13,	r12	;

00009458 <.Loc.48.1>:
    9458:	0f db       	bis	r11,	r15	;

0000945a <.L8>:
    945a:	12 c3       	clrc			
    945c:	0b 10       	rrc	r11		;

0000945e <.Loc.51.1>:
    945e:	12 c3       	clrc			
    9460:	0d 10       	rrc	r13		;
    9462:	30 40 32 94 	br	#0x9432		;

00009466 <__mspabi_divi>:
    9466:	0a 12       	push	r10		;

00009468 <.LCFI0>:
    9468:	0f 4c       	mov	r12,	r15	;
    946a:	0e 4d       	mov	r13,	r14	;

0000946c <.LVL14>:
    946c:	3b 40 26 94 	mov	#37926,	r11	;#0x9426

00009470 <.Loc.64.1>:
    9470:	0c 93       	cmp	#0,	r12	;r3 As==00
    9472:	1a 34       	jge	$+54     	;abs 0x94a8

00009474 <.Loc.66.1>:
    9474:	4c 43       	clr.b	r12		;

00009476 <.LVL15>:
    9476:	0c 8f       	sub	r15,	r12	;
    9478:	0f 4c       	mov	r12,	r15	;

0000947a <.LVL16>:
    947a:	0d 93       	cmp	#0,	r13	;r3 As==00
    947c:	0d 34       	jge	$+28     	;abs 0x9498

0000947e <.Loc.67.1>:
    947e:	5a 43       	mov.b	#1,	r10	;r3 As==01

00009480 <.L21>:
    9480:	0d 43       	clr	r13		;
    9482:	0d 8e       	sub	r14,	r13	;

00009484 <.LVL18>:
    9484:	4e 43       	clr.b	r14		;

00009486 <.LVL19>:
    9486:	0c 4f       	mov	r15,	r12	;

00009488 <.LVL20>:
    9488:	8b 12       	call	r11		;

0000948a <.LVL21>:
    948a:	1a 93       	cmp	#1,	r10	;r3 As==01
    948c:	03 24       	jz	$+8      	;abs 0x9494

0000948e <.L20>:
    948e:	4d 43       	clr.b	r13		;
    9490:	0d 8c       	sub	r12,	r13	;
    9492:	0c 4d       	mov	r13,	r12	;

00009494 <.L16>:
    9494:	3a 41       	pop	r10		;
    9496:	30 41       	ret			

00009498 <.L18>:
    9498:	4e 43       	clr.b	r14		;
    949a:	8b 12       	call	r11		;

0000949c <.LVL25>:
    949c:	30 40 8e 94 	br	#0x948e		;

000094a0 <.L27>:
    94a0:	4e 43       	clr.b	r14		;
    94a2:	8b 12       	call	r11		;

000094a4 <.LVL27>:
    94a4:	30 40 94 94 	br	#0x9494		;

000094a8 <.L17>:
    94a8:	0d 93       	cmp	#0,	r13	;r3 As==00
    94aa:	fa 37       	jge	$-10     	;abs 0x94a0

000094ac <.Loc.61.1>:
    94ac:	4a 43       	clr.b	r10		;
    94ae:	30 40 80 94 	br	#0x9480		;

000094b2 <__mspabi_remi>:
    94b2:	0a 12       	push	r10		;

000094b4 <.LCFI1>:
    94b4:	0c 93       	cmp	#0,	r12	;r3 As==00
    94b6:	13 34       	jge	$+40     	;abs 0x94de

000094b8 <.Loc.92.1>:
    94b8:	4e 43       	clr.b	r14		;
    94ba:	0e 8c       	sub	r12,	r14	;
    94bc:	0c 4e       	mov	r14,	r12	;

000094be <.LVL31>:
    94be:	5a 43       	mov.b	#1,	r10	;r3 As==01

000094c0 <.L29>:
    94c0:	0d 93       	cmp	#0,	r13	;r3 As==00
    94c2:	03 34       	jge	$+8      	;abs 0x94ca
    94c4:	4e 43       	clr.b	r14		;
    94c6:	0e 8d       	sub	r13,	r14	;
    94c8:	0d 4e       	mov	r14,	r13	;

000094ca <.L30>:
    94ca:	5e 43       	mov.b	#1,	r14	;r3 As==01
    94cc:	b0 12 26 94 	call	#37926		;#0x9426

000094d0 <.LVL34>:
    94d0:	0a 93       	cmp	#0,	r10	;r3 As==00
    94d2:	03 24       	jz	$+8      	;abs 0x94da

000094d4 <.LVL35>:
    94d4:	4d 43       	clr.b	r13		;
    94d6:	0d 8c       	sub	r12,	r13	;
    94d8:	0c 4d       	mov	r13,	r12	;

000094da <.L28>:
    94da:	3a 41       	pop	r10		;
    94dc:	30 41       	ret			

000094de <.L32>:
    94de:	4a 43       	clr.b	r10		;
    94e0:	30 40 c0 94 	br	#0x94c0		;

000094e4 <__mspabi_divu>:
    94e4:	4e 43       	clr.b	r14		;
    94e6:	b0 12 26 94 	call	#37926		;#0x9426

000094ea <.LVL39>:
    94ea:	30 41       	ret			

000094ec <__mspabi_remu>:
    94ec:	5e 43       	mov.b	#1,	r14	;r3 As==01
    94ee:	b0 12 26 94 	call	#37926		;#0x9426

000094f2 <.LVL41>:
    94f2:	30 41       	ret			

000094f4 <__mspabi_func_epilog_7>:
    94f4:	34 41       	pop	r4		;

000094f6 <__mspabi_func_epilog_6>:
    94f6:	35 41       	pop	r5		;

000094f8 <__mspabi_func_epilog_5>:
    94f8:	36 41       	pop	r6		;

000094fa <__mspabi_func_epilog_4>:
    94fa:	37 41       	pop	r7		;

000094fc <__mspabi_func_epilog_3>:
    94fc:	38 41       	pop	r8		;

000094fe <__mspabi_func_epilog_2>:
    94fe:	39 41       	pop	r9		;

00009500 <__mspabi_func_epilog_1>:
    9500:	3a 41       	pop	r10		;
    9502:	30 41       	ret			

00009504 <__mspabi_srli_15>:
    9504:	12 c3       	clrc			
    9506:	0c 10       	rrc	r12		;

00009508 <__mspabi_srli_14>:
    9508:	12 c3       	clrc			
    950a:	0c 10       	rrc	r12		;

0000950c <__mspabi_srli_13>:
    950c:	12 c3       	clrc			
    950e:	0c 10       	rrc	r12		;

00009510 <__mspabi_srli_12>:
    9510:	12 c3       	clrc			
    9512:	0c 10       	rrc	r12		;

00009514 <__mspabi_srli_11>:
    9514:	12 c3       	clrc			
    9516:	0c 10       	rrc	r12		;

00009518 <__mspabi_srli_10>:
    9518:	12 c3       	clrc			
    951a:	0c 10       	rrc	r12		;

0000951c <__mspabi_srli_9>:
    951c:	12 c3       	clrc			
    951e:	0c 10       	rrc	r12		;

00009520 <__mspabi_srli_8>:
    9520:	12 c3       	clrc			
    9522:	0c 10       	rrc	r12		;

00009524 <__mspabi_srli_7>:
    9524:	12 c3       	clrc			
    9526:	0c 10       	rrc	r12		;

00009528 <__mspabi_srli_6>:
    9528:	12 c3       	clrc			
    952a:	0c 10       	rrc	r12		;

0000952c <__mspabi_srli_5>:
    952c:	12 c3       	clrc			
    952e:	0c 10       	rrc	r12		;

00009530 <__mspabi_srli_4>:
    9530:	12 c3       	clrc			
    9532:	0c 10       	rrc	r12		;

00009534 <__mspabi_srli_3>:
    9534:	12 c3       	clrc			
    9536:	0c 10       	rrc	r12		;

00009538 <__mspabi_srli_2>:
    9538:	12 c3       	clrc			
    953a:	0c 10       	rrc	r12		;

0000953c <__mspabi_srli_1>:
    953c:	12 c3       	clrc			
    953e:	0c 10       	rrc	r12		;
    9540:	30 41       	ret			

00009542 <.L11>:
    9542:	3d 53       	add	#-1,	r13	;r3 As==11
    9544:	12 c3       	clrc			
    9546:	0c 10       	rrc	r12		;

00009548 <__mspabi_srli>:
    9548:	0d 93       	cmp	#0,	r13	;r3 As==00
    954a:	fb 23       	jnz	$-8      	;abs 0x9542
    954c:	30 41       	ret			

0000954e <__mspabi_srll_15>:
    954e:	12 c3       	clrc			
    9550:	0d 10       	rrc	r13		;
    9552:	0c 10       	rrc	r12		;

00009554 <__mspabi_srll_14>:
    9554:	12 c3       	clrc			
    9556:	0d 10       	rrc	r13		;
    9558:	0c 10       	rrc	r12		;

0000955a <__mspabi_srll_13>:
    955a:	12 c3       	clrc			
    955c:	0d 10       	rrc	r13		;
    955e:	0c 10       	rrc	r12		;

00009560 <__mspabi_srll_12>:
    9560:	12 c3       	clrc			
    9562:	0d 10       	rrc	r13		;
    9564:	0c 10       	rrc	r12		;

00009566 <__mspabi_srll_11>:
    9566:	12 c3       	clrc			
    9568:	0d 10       	rrc	r13		;
    956a:	0c 10       	rrc	r12		;

0000956c <__mspabi_srll_10>:
    956c:	12 c3       	clrc			
    956e:	0d 10       	rrc	r13		;
    9570:	0c 10       	rrc	r12		;

00009572 <__mspabi_srll_9>:
    9572:	12 c3       	clrc			
    9574:	0d 10       	rrc	r13		;
    9576:	0c 10       	rrc	r12		;

00009578 <__mspabi_srll_8>:
    9578:	12 c3       	clrc			
    957a:	0d 10       	rrc	r13		;
    957c:	0c 10       	rrc	r12		;

0000957e <__mspabi_srll_7>:
    957e:	12 c3       	clrc			
    9580:	0d 10       	rrc	r13		;
    9582:	0c 10       	rrc	r12		;

00009584 <__mspabi_srll_6>:
    9584:	12 c3       	clrc			
    9586:	0d 10       	rrc	r13		;
    9588:	0c 10       	rrc	r12		;

0000958a <__mspabi_srll_5>:
    958a:	12 c3       	clrc			
    958c:	0d 10       	rrc	r13		;
    958e:	0c 10       	rrc	r12		;

00009590 <__mspabi_srll_4>:
    9590:	12 c3       	clrc			
    9592:	0d 10       	rrc	r13		;
    9594:	0c 10       	rrc	r12		;

00009596 <__mspabi_srll_3>:
    9596:	12 c3       	clrc			
    9598:	0d 10       	rrc	r13		;
    959a:	0c 10       	rrc	r12		;

0000959c <__mspabi_srll_2>:
    959c:	12 c3       	clrc			
    959e:	0d 10       	rrc	r13		;
    95a0:	0c 10       	rrc	r12		;

000095a2 <__mspabi_srll_1>:
    95a2:	12 c3       	clrc			
    95a4:	0d 10       	rrc	r13		;
    95a6:	0c 10       	rrc	r12		;
    95a8:	30 41       	ret			

000095aa <.L12>:
    95aa:	3e 53       	add	#-1,	r14	;r3 As==11
    95ac:	12 c3       	clrc			
    95ae:	0d 10       	rrc	r13		;
    95b0:	0c 10       	rrc	r12		;

000095b2 <__mspabi_srll>:
    95b2:	0e 93       	cmp	#0,	r14	;r3 As==00
    95b4:	fa 23       	jnz	$-10     	;abs 0x95aa
    95b6:	30 41       	ret			

000095b8 <__mspabi_mpyi>:
    95b8:	02 12       	push	r2		;
    95ba:	32 c2       	dint			
    95bc:	03 43       	nop			
    95be:	82 4c 30 01 	mov	r12,	&0x0130	;
    95c2:	82 4d 38 01 	mov	r13,	&0x0138	;
    95c6:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    95ca:	00 13       	reti			

000095cc <__mspabi_mpyl>:
    95cc:	02 12       	push	r2		;
    95ce:	32 c2       	dint			
    95d0:	03 43       	nop			
    95d2:	82 4c 30 01 	mov	r12,	&0x0130	;
    95d6:	82 4e 38 01 	mov	r14,	&0x0138	;
    95da:	82 4c 34 01 	mov	r12,	&0x0134	;
    95de:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    95e2:	92 42 3c 01 	mov	&0x013c,&0x013a	;0x013c
    95e6:	3a 01 
    95e8:	82 4f 38 01 	mov	r15,	&0x0138	;
    95ec:	82 4d 34 01 	mov	r13,	&0x0134	;
    95f0:	82 4e 38 01 	mov	r14,	&0x0138	;
    95f4:	1d 42 3a 01 	mov	&0x013a,r13	;0x013a
    95f8:	00 13       	reti			

000095fa <exit>:
    95fa:	0a 12       	push	r10		;

000095fc <.LCFI0>:
    95fc:	0a 4c       	mov	r12,	r10	;

000095fe <.Loc.66.1>:
    95fe:	4d 43       	clr.b	r13		;
    9600:	b0 12 18 96 	call	#38424		;#0x9618

00009604 <.LVL1>:
    9604:	1c 42 68 80 	mov	&0x8068,r12	;0x8068
    9608:	1d 4c 14 00 	mov	20(r12),r13	;0x00014
    960c:	0d 93       	cmp	#0,	r13	;r3 As==00
    960e:	01 24       	jz	$+4      	;abs 0x9612

00009610 <.Loc.69.1>:
    9610:	8d 12       	call	r13		;

00009612 <.L2>:
    9612:	0c 4a       	mov	r10,	r12	;
    9614:	b0 12 c6 97 	call	#38854		;#0x97c6

00009618 <__call_exitprocs>:
    9618:	0a 12       	push	r10		;

0000961a <.LCFI0>:
    961a:	09 12       	push	r9		;

0000961c <.LCFI1>:
    961c:	08 12       	push	r8		;

0000961e <.LCFI2>:
    961e:	07 12       	push	r7		;

00009620 <.LCFI3>:
    9620:	06 12       	push	r6		;

00009622 <.LCFI4>:
    9622:	05 12       	push	r5		;

00009624 <.LCFI5>:
    9624:	04 12       	push	r4		;

00009626 <.LCFI6>:
    9626:	31 80 0c 00 	sub	#12,	r1	;#0x000c

0000962a <.LCFI7>:
    962a:	81 4c 08 00 	mov	r12,	8(r1)	;
    962e:	05 4d       	mov	r13,	r5	;

00009630 <.Loc.84.1>:
    9630:	1e 42 68 80 	mov	&0x8068,r14	;0x8068
    9634:	3e 50 24 00 	add	#36,	r14	;#0x0024
    9638:	81 4e 0a 00 	mov	r14,	10(r1)	; 0x000a

0000963c <.L31>:
    963c:	1e 42 68 80 	mov	&0x8068,r14	;0x8068
    9640:	1a 4e 24 00 	mov	36(r14),r10	;0x00024

00009644 <.LVL2>:
    9644:	17 41 0a 00 	mov	10(r1),	r7	;0x0000a

00009648 <.LVL3>:
    9648:	36 40 00 00 	mov	#0,	r6	;

0000964c <.L2>:
    964c:	0a 93       	cmp	#0,	r10	;r3 As==00
    964e:	04 20       	jnz	$+10     	;abs 0x9658

00009650 <.L1>:
    9650:	31 50 0c 00 	add	#12,	r1	;#0x000c
    9654:	30 40 f4 94 	br	#0x94f4		;

00009658 <.L19>:
    9658:	14 4a 44 00 	mov	68(r10),r4	;0x00044

0000965c <.Loc.92.1>:
    965c:	19 4a 02 00 	mov	2(r10),	r9	;
    9660:	08 49       	mov	r9,	r8	;
    9662:	38 53       	add	#-1,	r8	;r3 As==11
    9664:	09 59       	rla	r9		;

00009666 <.L3>:
    9666:	08 93       	cmp	#0,	r8	;r3 As==00
    9668:	14 34       	jge	$+42     	;abs 0x9692

0000966a <.Loc.136.1>:
    966a:	06 93       	cmp	#0,	r6	;r3 As==00
    966c:	f1 27       	jz	$-28     	;abs 0x9650
    966e:	2c 4a       	mov	@r10,	r12	;

00009670 <.Loc.141.1>:
    9670:	8a 93 02 00 	cmp	#0,	2(r10)	;r3 As==00
    9674:	6b 20       	jnz	$+216    	;abs 0x974c

00009676 <.Loc.141.1>:
    9676:	0c 93       	cmp	#0,	r12	;r3 As==00
    9678:	69 24       	jz	$+212    	;abs 0x974c

0000967a <.Loc.144.1>:
    967a:	87 4c 00 00 	mov	r12,	0(r7)	;

0000967e <.Loc.146.1>:
    967e:	04 93       	cmp	#0,	r4	;r3 As==00
    9680:	02 24       	jz	$+6      	;abs 0x9686

00009682 <.Loc.147.1>:
    9682:	0c 44       	mov	r4,	r12	;
    9684:	86 12       	call	r6		;

00009686 <.L17>:
    9686:	0c 4a       	mov	r10,	r12	;
    9688:	86 12       	call	r6		;

0000968a <.LVL8>:
    968a:	2c 47       	mov	@r7,	r12	;

0000968c <.L18>:
    968c:	0a 4c       	mov	r12,	r10	;
    968e:	30 40 4c 96 	br	#0x964c		;

00009692 <.L14>:
    9692:	05 93       	cmp	#0,	r5	;r3 As==00
    9694:	0c 24       	jz	$+26     	;abs 0x96ae

00009696 <.Loc.99.1>:
    9696:	04 93       	cmp	#0,	r4	;r3 As==00
    9698:	05 20       	jnz	$+12     	;abs 0x96a4

0000969a <.L6>:
    969a:	38 53       	add	#-1,	r8	;r3 As==11

0000969c <.LVL11>:
    969c:	39 50 fe ff 	add	#65534,	r9	;#0xfffe
    96a0:	30 40 66 96 	br	#0x9666		;

000096a4 <.L5>:
    96a4:	0c 44       	mov	r4,	r12	;
    96a6:	0c 59       	add	r9,	r12	;
    96a8:	8c 95 3e 00 	cmp	r5,	62(r12)	; 0x003e
    96ac:	f6 23       	jnz	$-18     	;abs 0x969a

000096ae <.L4>:
    96ae:	0c 4a       	mov	r10,	r12	;
    96b0:	0c 59       	add	r9,	r12	;

000096b2 <.Loc.104.1>:
    96b2:	1f 4c 02 00 	mov	2(r12),	r15	;

000096b6 <.LVL13>:
    96b6:	1d 4a 02 00 	mov	2(r10),	r13	;
    96ba:	3d 53       	add	#-1,	r13	;r3 As==11
    96bc:	0d 98       	cmp	r8,	r13	;
    96be:	2c 20       	jnz	$+90     	;abs 0x9718

000096c0 <.Loc.106.1>:
    96c0:	8a 48 02 00 	mov	r8,	2(r10)	;

000096c4 <.L8>:
    96c4:	0f 93       	cmp	#0,	r15	;r3 As==00
    96c6:	e9 27       	jz	$-44     	;abs 0x969a

000096c8 <.Loc.114.1>:
    96c8:	91 4a 02 00 	mov	2(r10),	6(r1)	;
    96cc:	06 00 

000096ce <.LVL14>:
    96ce:	04 93       	cmp	#0,	r4	;r3 As==00
    96d0:	19 24       	jz	$+52     	;abs 0x9704

000096d2 <.Loc.96.1>:
    96d2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    96d4:	0d 48       	mov	r8,	r13	;
    96d6:	81 4f 00 00 	mov	r15,	0(r1)	;
    96da:	b0 12 76 97 	call	#38774		;#0x9776

000096de <.LVL15>:
    96de:	0d 4c       	mov	r12,	r13	;
    96e0:	3d b0 00 80 	bit	#32768,	r13	;#0x8000
    96e4:	0e 7e       	subc	r14,	r14	;
    96e6:	3e e3       	inv	r14		;
    96e8:	81 4d 02 00 	mov	r13,	2(r1)	;
    96ec:	81 4e 04 00 	mov	r14,	4(r1)	;
    96f0:	1b 44 80 00 	mov	128(r4),r11	;0x00080
    96f4:	0b fc       	and	r12,	r11	;
    96f6:	1d 44 82 00 	mov	130(r4),r13	;0x00082
    96fa:	0d fe       	and	r14,	r13	;
    96fc:	0d db       	bis	r11,	r13	;
    96fe:	2f 41       	mov	@r1,	r15	;

00009700 <.LVL16>:
    9700:	0d 93       	cmp	#0,	r13	;r3 As==00
    9702:	0e 20       	jnz	$+30     	;abs 0x9720

00009704 <.L9>:
    9704:	8f 12       	call	r15		;

00009706 <.L11>:
    9706:	9a 91 06 00 	cmp	6(r1),	2(r10)	;
    970a:	02 00 
    970c:	97 23       	jnz	$-208    	;abs 0x963c

0000970e <.Loc.127.1>:
    970e:	87 9a 00 00 	cmp	r10,	0(r7)	;
    9712:	c3 27       	jz	$-120    	;abs 0x969a
    9714:	30 40 3c 96 	br	#0x963c		;

00009718 <.L7>:
    9718:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    971c:	30 40 c4 96 	br	#0x96c4		;

00009720 <.L10>:
    9720:	0d 44       	mov	r4,	r13	;
    9722:	0d 59       	add	r9,	r13	;
    9724:	1d 4d fe ff 	mov	-2(r13),r13	;

00009728 <.Loc.119.1>:
    9728:	1c f4 84 00 	and	132(r4),r12	;0x00084
    972c:	1b 44 86 00 	mov	134(r4),r11	;0x00086
    9730:	1b f1 04 00 	and	4(r1),	r11	;
    9734:	0c db       	bis	r11,	r12	;
    9736:	0c 93       	cmp	#0,	r12	;r3 As==00
    9738:	05 20       	jnz	$+12     	;abs 0x9744

0000973a <.Loc.120.1>:
    973a:	1c 41 08 00 	mov	8(r1),	r12	;
    973e:	8f 12       	call	r15		;

00009740 <.LVL20>:
    9740:	30 40 06 97 	br	#0x9706		;

00009744 <.L12>:
    9744:	0c 4d       	mov	r13,	r12	;
    9746:	8f 12       	call	r15		;

00009748 <.LVL22>:
    9748:	30 40 06 97 	br	#0x9706		;

0000974c <.L16>:
    974c:	07 4a       	mov	r10,	r7	;

0000974e <.LVL24>:
    974e:	30 40 8c 96 	br	#0x968c		;

00009752 <__mspabi_slli_15>:
    9752:	0c 5c       	rla	r12		;

00009754 <__mspabi_slli_14>:
    9754:	0c 5c       	rla	r12		;

00009756 <__mspabi_slli_13>:
    9756:	0c 5c       	rla	r12		;

00009758 <__mspabi_slli_12>:
    9758:	0c 5c       	rla	r12		;

0000975a <__mspabi_slli_11>:
    975a:	0c 5c       	rla	r12		;

0000975c <__mspabi_slli_10>:
    975c:	0c 5c       	rla	r12		;

0000975e <__mspabi_slli_9>:
    975e:	0c 5c       	rla	r12		;

00009760 <__mspabi_slli_8>:
    9760:	0c 5c       	rla	r12		;

00009762 <__mspabi_slli_7>:
    9762:	0c 5c       	rla	r12		;

00009764 <__mspabi_slli_6>:
    9764:	0c 5c       	rla	r12		;

00009766 <__mspabi_slli_5>:
    9766:	0c 5c       	rla	r12		;

00009768 <__mspabi_slli_4>:
    9768:	0c 5c       	rla	r12		;

0000976a <__mspabi_slli_3>:
    976a:	0c 5c       	rla	r12		;

0000976c <__mspabi_slli_2>:
    976c:	0c 5c       	rla	r12		;

0000976e <__mspabi_slli_1>:
    976e:	0c 5c       	rla	r12		;
    9770:	30 41       	ret			

00009772 <.L11>:
    9772:	3d 53       	add	#-1,	r13	;r3 As==11
    9774:	0c 5c       	rla	r12		;

00009776 <__mspabi_slli>:
    9776:	0d 93       	cmp	#0,	r13	;r3 As==00
    9778:	fc 23       	jnz	$-6      	;abs 0x9772
    977a:	30 41       	ret			

0000977c <__mspabi_slll_15>:
    977c:	0c 5c       	rla	r12		;
    977e:	0d 6d       	rlc	r13		;

00009780 <__mspabi_slll_14>:
    9780:	0c 5c       	rla	r12		;
    9782:	0d 6d       	rlc	r13		;

00009784 <__mspabi_slll_13>:
    9784:	0c 5c       	rla	r12		;
    9786:	0d 6d       	rlc	r13		;

00009788 <__mspabi_slll_12>:
    9788:	0c 5c       	rla	r12		;
    978a:	0d 6d       	rlc	r13		;

0000978c <__mspabi_slll_11>:
    978c:	0c 5c       	rla	r12		;
    978e:	0d 6d       	rlc	r13		;

00009790 <__mspabi_slll_10>:
    9790:	0c 5c       	rla	r12		;
    9792:	0d 6d       	rlc	r13		;

00009794 <__mspabi_slll_9>:
    9794:	0c 5c       	rla	r12		;
    9796:	0d 6d       	rlc	r13		;

00009798 <__mspabi_slll_8>:
    9798:	0c 5c       	rla	r12		;
    979a:	0d 6d       	rlc	r13		;

0000979c <__mspabi_slll_7>:
    979c:	0c 5c       	rla	r12		;
    979e:	0d 6d       	rlc	r13		;

000097a0 <__mspabi_slll_6>:
    97a0:	0c 5c       	rla	r12		;
    97a2:	0d 6d       	rlc	r13		;

000097a4 <__mspabi_slll_5>:
    97a4:	0c 5c       	rla	r12		;
    97a6:	0d 6d       	rlc	r13		;

000097a8 <__mspabi_slll_4>:
    97a8:	0c 5c       	rla	r12		;
    97aa:	0d 6d       	rlc	r13		;

000097ac <__mspabi_slll_3>:
    97ac:	0c 5c       	rla	r12		;
    97ae:	0d 6d       	rlc	r13		;

000097b0 <__mspabi_slll_2>:
    97b0:	0c 5c       	rla	r12		;
    97b2:	0d 6d       	rlc	r13		;

000097b4 <__mspabi_slll_1>:
    97b4:	0c 5c       	rla	r12		;
    97b6:	0d 6d       	rlc	r13		;
    97b8:	30 41       	ret			

000097ba <.L12>:
    97ba:	3e 53       	add	#-1,	r14	;r3 As==11
    97bc:	0c 5c       	rla	r12		;
    97be:	0d 6d       	rlc	r13		;

000097c0 <__mspabi_slll>:
    97c0:	0e 93       	cmp	#0,	r14	;r3 As==00
    97c2:	fb 23       	jnz	$-8      	;abs 0x97ba
    97c4:	30 41       	ret			

000097c6 <_exit>:
    97c6:	30 40 c6 97 	br	#0x97c6		;

000097ca <memmove>:
    97ca:	0d 9c       	cmp	r12,	r13	;
    97cc:	0a 28       	jnc	$+22     	;abs 0x97e2

000097ce <.L5>:
    97ce:	0f 4c       	mov	r12,	r15	;
    97d0:	0e 5c       	add	r12,	r14	;

000097d2 <.L3>:
    97d2:	0e 9f       	cmp	r15,	r14	;
    97d4:	0d 24       	jz	$+28     	;abs 0x97f0

000097d6 <.LVL3>:
    97d6:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    97da:	1f 53       	inc	r15		;

000097dc <.LVL4>:
    97dc:	1d 53       	inc	r13		;
    97de:	30 40 d2 97 	br	#0x97d2		;

000097e2 <.L2>:
    97e2:	0f 4d       	mov	r13,	r15	;
    97e4:	0f 5e       	add	r14,	r15	;
    97e6:	0c 9f       	cmp	r15,	r12	;
    97e8:	f2 2f       	jc	$-26     	;abs 0x97ce

000097ea <.L4>:
    97ea:	3e 53       	add	#-1,	r14	;r3 As==11

000097ec <.LVL7>:
    97ec:	3e 93       	cmp	#-1,	r14	;r3 As==11
    97ee:	01 20       	jnz	$+4      	;abs 0x97f2

000097f0 <.L10>:
    97f0:	30 41       	ret			

000097f2 <.L6>:
    97f2:	0b 4c       	mov	r12,	r11	;
    97f4:	0b 5e       	add	r14,	r11	;
    97f6:	0f 4d       	mov	r13,	r15	;
    97f8:	0f 5e       	add	r14,	r15	;
    97fa:	eb 4f 00 00 	mov.b	@r15,	0(r11)	;
    97fe:	30 40 ea 97 	br	#0x97ea		;

00009802 <memset>:
    9802:	0f 4c       	mov	r12,	r15	;
    9804:	0e 5c       	add	r12,	r14	;

00009806 <.L2>:
    9806:	0f 9e       	cmp	r14,	r15	;
    9808:	01 20       	jnz	$+4      	;abs 0x980c

0000980a <.Loc.104.1>:
    980a:	30 41       	ret			

0000980c <.L3>:
    980c:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    9810:	1f 53       	inc	r15		;

00009812 <.LVL4>:
    9812:	30 40 06 98 	br	#0x9806		;

00009816 <__do_global_ctors_aux>:
    9816:	0a 12       	push	r10		;
    9818:	3a 40 74 80 	mov	#32884,	r10	;#0x8074

0000981c <.L2>:
    981c:	2c 4a       	mov	@r10,	r12	;
    981e:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9820:	02 20       	jnz	$+6      	;abs 0x9826
    9822:	3a 41       	pop	r10		;
    9824:	30 41       	ret			

00009826 <.L3>:
    9826:	8c 12       	call	r12		;
    9828:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    982c:	30 40 1c 98 	br	#0x981c		;

00009830 <__msp430_init>:
    9830:	b0 12 48 83 	call	#33608		;#0x8348
    9834:	b0 12 16 98 	call	#38934		;#0x9816

00009838 <L0>:
    9838:	b0 12 84 82 	call	#33412		;#0x8284

0000983c <.Loc.19.1>:
    983c:	b0 12 76 82 	call	#33398		;#0x8276

00009840 <.Loc.20.1>:
    9840:	30 41       	ret			

00009842 <__msp430_fini>:
    9842:	b0 12 92 82 	call	#33426		;#0x8292

00009846 <L0>:
    9846:	b0 12 fa 82 	call	#33530		;#0x82fa

0000984a <L0>:
    984a:	30 41       	ret			
